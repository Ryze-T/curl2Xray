var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-6972f9df.js"(exports, module) {
    function makeMap(str, expectsLowerCase) {
      const map2 = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map2[list[i]] = true;
      }
      return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
    }
    function normalizeStyle(value) {
      if (isArray$2(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value)) {
        return value;
      } else if (isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*.*?\*\//gs;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const onRE = /^on[^a-z]/;
    const isOn = (key) => onRE.test(key);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$d = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
    const isArray$2 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
    const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    const createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    const newTracked = (dep) => (dep.n & trackOpBit) > 0;
    const initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].w |= trackOpBit;
        }
      }
    };
    const finalizeDepMarkers = (effect) => {
      const { deps } = effect;
      if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
          const dep = deps[i];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    let effectTrackDepth = 0;
    let trackOpBit = 1;
    const maxMarkerBits = 30;
    let activeEffect;
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    class ReactiveEffect {
      constructor(fn, scheduler2 = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler2;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
          if (parent === this) {
            return;
          }
          parent = parent.parent;
        }
        try {
          this.parent = activeEffect;
          activeEffect = this;
          shouldTrack = true;
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          activeEffect = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
          if (this.deferStop) {
            this.stop();
          }
        }
      }
      stop() {
        if (activeEffect === this) {
          this.deferStop = true;
        } else if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    }
    function cleanupEffect(effect) {
      const { deps } = effect;
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].delete(effect);
        }
        deps.length = 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type2, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep());
        }
        trackEffects(dep);
      }
    }
    function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack2 = false;
      if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
          dep.n |= trackOpBit;
          shouldTrack2 = !wasTracked(dep);
        }
      } else {
        shouldTrack2 = !dep.has(activeEffect);
      }
      if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
      }
    }
    function trigger$1(target, type2, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type2 === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$2(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type2) {
          case "add":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      if (deps.length === 1) {
        if (deps[0]) {
          {
            triggerEffects(deps[0]);
          }
        }
      } else {
        const effects = [];
        for (const dep of deps) {
          if (dep) {
            effects.push(...dep);
          }
        }
        {
          triggerEffects(createDep(effects));
        }
      }
    }
    function triggerEffects(dep, debuggerEventExtraInfo) {
      const effects = isArray$2(dep) ? dep : [...dep];
      for (const effect of effects) {
        if (effect.computed) {
          triggerEffect(effect);
        }
      }
      for (const effect of effects) {
        if (!effect.computed) {
          triggerEffect(effect);
        }
      }
    }
    function triggerEffect(effect, debuggerEventExtraInfo) {
      if (effect !== activeEffect || effect.allowRecurse) {
        if (effect.scheduler) {
          effect.scheduler();
        } else {
          effect.run();
        }
      }
    }
    function getDepFromReactive(object2, key) {
      var _a;
      return (_a = targetMap.get(object2)) === null || _a === void 0 ? void 0 : _a.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    const get$1 = /* @__PURE__ */ createGetter();
    const shallowGet = /* @__PURE__ */ createGetter(false, true);
    const readonlyGet = /* @__PURE__ */ createGetter(true);
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          const res = toRaw(this)[key].apply(this, args);
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$c(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    function createGetter(isReadonly2 = false, shallow = false) {
      return function get2(target, key, receiver) {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = isArray$2(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$c;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      };
    }
    const set$1 = /* @__PURE__ */ createSetter();
    const shallowSet = /* @__PURE__ */ createSetter(true);
    function createSetter(shallow = false) {
      return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
          return false;
        }
        if (!shallow) {
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger$1(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger$1(target, "set", key, value);
          }
        }
        return result;
      };
    }
    function deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger$1(target, "delete", key, void 0);
      }
      return result;
    }
    function has$1(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    function ownKeys(target) {
      track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
      return Reflect.ownKeys(target);
    }
    const mutableHandlers = {
      get: get$1,
      set: set$1,
      deleteProperty,
      has: has$1,
      ownKeys
    };
    const readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
        return true;
      },
      deleteProperty(target, key) {
        return true;
      }
    };
    const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet
    });
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target[
        "__v_raw"
        /* ReactiveFlags.RAW */
      ];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this[
        "__v_raw"
        /* ReactiveFlags.RAW */
      ];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size$1(target, isReadonly2 = false) {
      target = target[
        "__v_raw"
        /* ReactiveFlags.RAW */
      ];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger$1(target, "add", value, value);
      }
      return this;
    }
    function set(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger$1(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger$1(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger$1(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed[
          "__v_raw"
          /* ReactiveFlags.RAW */
        ];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method2, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this[
          "__v_raw"
          /* ReactiveFlags.RAW */
        ];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method2 === "entries" || method2 === Symbol.iterator && targetIsMap;
        const isKeyOnly = method2 === "keys" && targetIsMap;
        const innerIterator = target[method2](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type2) {
      return function(...args) {
        return type2 === "delete" ? false : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$2(this, key);
        },
        get size() {
          return size$1(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$2(this, key, false, true);
        },
        get size() {
          return size$1(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$2(this, key, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod(
          "add"
          /* TriggerOpTypes.ADD */
        ),
        set: createReadonlyMethod(
          "set"
          /* TriggerOpTypes.SET */
        ),
        delete: createReadonlyMethod(
          "delete"
          /* TriggerOpTypes.DELETE */
        ),
        clear: createReadonlyMethod(
          "clear"
          /* TriggerOpTypes.CLEAR */
        ),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$2(this, key, true, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod(
          "add"
          /* TriggerOpTypes.ADD */
        ),
        set: createReadonlyMethod(
          "set"
          /* TriggerOpTypes.SET */
        ),
        delete: createReadonlyMethod(
          "delete"
          /* TriggerOpTypes.DELETE */
        ),
        clear: createReadonlyMethod(
          "clear"
          /* TriggerOpTypes.CLEAR */
        ),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method2) => {
        mutableInstrumentations2[method2] = createIterableMethod(method2, false, false);
        readonlyInstrumentations2[method2] = createIterableMethod(method2, true, false);
        shallowInstrumentations2[method2] = createIterableMethod(method2, false, true);
        shallowReadonlyInstrumentations2[method2] = createIterableMethod(method2, true, true);
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value[
        "__v_skip"
        /* ReactiveFlags.SKIP */
      ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
    }
    function shallowReactive(target) {
      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
    }
    function readonly(target) {
      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        return target;
      }
      if (target[
        "__v_raw"
        /* ReactiveFlags.RAW */
      ] && !(isReadonly2 && target[
        "__v_isReactive"
        /* ReactiveFlags.IS_REACTIVE */
      ])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value[
          "__v_raw"
          /* ReactiveFlags.RAW */
        ]);
      }
      return !!(value && value[
        "__v_isReactive"
        /* ReactiveFlags.IS_REACTIVE */
      ]);
    }
    function isReadonly(value) {
      return !!(value && value[
        "__v_isReadonly"
        /* ReactiveFlags.IS_READONLY */
      ]);
    }
    function isShallow(value) {
      return !!(value && value[
        "__v_isShallow"
        /* ReactiveFlags.IS_SHALLOW */
      ]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed[
        "__v_raw"
        /* ReactiveFlags.RAW */
      ];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        {
          trackEffects(ref2.dep || (ref2.dep = createDep()));
        }
      }
    }
    function triggerRefValue(ref2, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        {
          triggerEffects(dep);
        }
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    function toRef(object2, key, defaultValue) {
      const val = object2[key];
      return isRef(val) ? val : new ObjectRefImpl(object2, key, defaultValue);
    }
    var _a$1;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this[_a$1] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this[
          "__v_isReadonly"
          /* ReactiveFlags.IS_READONLY */
        ] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    }
    _a$1 = "__v_isReadonly";
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$1(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function warn$3(msg2, ...args) {
      return;
    }
    function callWithErrorHandling(fn, instance, type2, args) {
      let res;
      try {
        res = args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type2);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn, instance, type2, args) {
      if (isFunction$1(fn)) {
        const res = callWithErrorHandling(fn, instance, type2, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type2);
          });
        }
        return res;
      }
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
      }
      return values;
    }
    function handleError(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = type2;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
          return;
        }
      }
      logError(err, type2, contextVNode, throwInDev);
    }
    function logError(err, type2, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$2(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
          queue.splice(i, 1);
          i--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff = getId(a) - getId(b);
      if (diff === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      const check = NOOP;
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(
              job,
              null,
              14
              /* ErrorCodes.SCHEDULER */
            );
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
        if (trim) {
          args = rawArgs.map((a) => isString(a) ? a.trim() : a);
        }
        if (number2) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6, args);
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, null);
        }
        return null;
      }
      if (isArray$2(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache2.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn, ctx2 = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx2)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx2);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render2, renderCache, data, setupState, ctx: ctx2, inheritAttrs } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx2));
          fallthroughAttrs = attrs;
        } else {
          const render3 = Component;
          if (false)
            ;
          result = normalizeVNode(render3.length > 1 ? render3(props, false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }) : render3(
            props,
            null
            /* we know it doesn't need it */
          ));
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(
          err,
          instance,
          1
          /* ErrorCodes.RENDER_FUNCTION */
        );
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      }
    }
    const isSuspense = (type2) => type2.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$2(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance) {
        const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function watchEffect(effect, options) {
      return doWatch(effect, null, options);
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
      const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => source;
        deep = true;
      } else if (isArray$2(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return traverse(s);
          } else if (isFunction$1(s)) {
            return callWithErrorHandling(
              s,
              instance,
              2
              /* ErrorCodes.WATCH_GETTER */
            );
          } else
            ;
        });
      } else if (isFunction$1(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(
            source,
            instance,
            2
            /* ErrorCodes.WATCH_GETTER */
          );
        } else {
          getter = () => {
            if (instance && instance.isUnmounted) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
          callWithErrorHandling(
            fn,
            instance,
            4
            /* ErrorCodes.WATCH_CLEANUP */
          );
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx2 = useSSRContext();
          ssrCleanup = ctx2.__watcherHandles || (ctx2.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect.active) {
          return;
        }
        if (cb) {
          const newValue = effect.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler2;
      if (flush === "sync") {
        scheduler2 = job;
      } else if (flush === "post") {
        scheduler2 = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler2 = () => queueJob(job);
      }
      const effect = new ReactiveEffect(getter, scheduler2);
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
      } else {
        effect.run();
      }
      const unwatch = () => {
        effect.stop();
        if (instance && instance.scope) {
          remove(instance.scope.effects, effect);
        }
      };
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$1(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const cur = currentInstance;
      setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      if (cur) {
        setCurrentInstance(cur);
      } else {
        unsetCurrentInstance();
      }
      return res;
    }
    function createPathGetter(ctx2, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx2;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, seen) {
      if (!isObject$1(value) || value[
        "__v_skip"
        /* ReactiveFlags.SKIP */
      ]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, seen);
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], seen);
        }
      }
      return value;
    }
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c2 of children) {
              if (c2.type !== Comment) {
                child = c2;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el._leaveCb = () => {
                  earlyRemove();
                  el._leaveCb = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$2(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el._leaveCb) {
            el._leaveCb(
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
            leavingVNode.el._leaveCb();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el._enterCb = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el._enterCb = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el._enterCb) {
            el._enterCb(
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el._leaveCb = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el._leaveCb = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    function defineComponent(options) {
      return isFunction$1(options) ? { setup: options, name: options.name } : options;
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type2, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type2, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type2, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
      const injected = injectHook(
        type2,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type2], injected);
      }, target);
    }
    function injectHook(type2, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type2] || (target[type2] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type2, args);
          unsetCurrentInstance();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook(
      "bm"
      /* LifecycleHooks.BEFORE_MOUNT */
    );
    const onMounted = createHook(
      "m"
      /* LifecycleHooks.MOUNTED */
    );
    const onBeforeUpdate = createHook(
      "bu"
      /* LifecycleHooks.BEFORE_UPDATE */
    );
    const onUpdated = createHook(
      "u"
      /* LifecycleHooks.UPDATED */
    );
    const onBeforeUnmount = createHook(
      "bum"
      /* LifecycleHooks.BEFORE_UNMOUNT */
    );
    const onUnmounted = createHook(
      "um"
      /* LifecycleHooks.UNMOUNTED */
    );
    const onServerPrefetch = createHook(
      "sp"
      /* LifecycleHooks.SERVER_PREFETCH */
    );
    const onRenderTriggered = createHook(
      "rtg"
      /* LifecycleHooks.RENDER_TRIGGERED */
    );
    const onRenderTracked = createHook(
      "rtc"
      /* LifecycleHooks.RENDER_TRACKED */
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function withDirectives(vnode, directives) {
      const internalInstance = currentRenderingInstance;
      if (internalInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const COMPONENTS = "components";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol();
    function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type2 === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
            /* do not include inferred name to avoid breaking existing code */
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type2] || Component[type2], name) || // global registration
          resolve(instance.appContext[type2], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode$1(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
        /* PatchFlags.BAIL */
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode$1(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode$1(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx: ctx2, setupState, data, props, accessCache, type: type2, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx2[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
            accessCache[key] = 4;
            return ctx2[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
          accessCache[key] = 4;
          return ctx2[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx: ctx2 } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx2[key] = value;
          }
        }
        return true;
      },
      has({ _: { data, setupState, accessCache, ctx: ctx2, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx2, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx2 = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(
          options.beforeCreate,
          instance,
          "bc"
          /* LifecycleHooks.BEFORE_CREATE */
        );
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx2, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              ctx2[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$1(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v) => c2.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx2, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(
          created,
          instance,
          "c"
          /* LifecycleHooks.CREATED */
        );
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$2(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$2(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx2, checkDuplicateProperties = NOOP, unwrapRef = false) {
      if (isArray$2(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
              /* treat default function as factory */
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          if (unwrapRef) {
            Object.defineProperty(ctx2, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v) => injected.value = v
            });
          } else {
            ctx2[key] = injected;
          }
        } else {
          ctx2[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type2) {
      callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type2);
    }
    function createWatcher(raw, ctx2, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString(raw)) {
        const handler = ctx2[raw];
        if (isFunction$1(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$1(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$1(raw)) {
        if (isArray$2(raw)) {
          raw.forEach((r) => createWatcher(r, ctx2, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx2[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
      const cached = cache2.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base2, optionMergeStrategies);
      }
      if (isObject$1(base2)) {
        cache2.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeObjectOptions,
      emits: mergeObjectOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend(isFunction$1(to) ? to.call(this, this) : to, isFunction$1(from) ? from.call(this, this) : from);
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$2(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const { props, attrs, vnode: { patchFlag } } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                  /* isAbsent */
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                  /* isAbsent */
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger$1(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(null, props);
              unsetCurrentInstance();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* BooleanFlags.shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* BooleanFlags.shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$2(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : Object.assign({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* BooleanFlags.shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* BooleanFlags.shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache2.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match2 = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
      return match2 ? match2[2] : ctor === null ? "null" : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type2, expectedTypes) {
      if (isArray$2(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type2));
      } else if (isFunction$1(expectedTypes)) {
        return isSameType(expectedTypes, type2) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx2) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx2);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx2 = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot(key, value, ctx2);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          instance.slots = toRaw(children);
          def(children, "_", type2);
        } else {
          normalizeObjectSlots(children, instance.slots = {});
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          if (optimized && type2 === 1) {
            needDeletionCheck = false;
          } else {
            extend(slots, children);
            if (!optimized && type2 === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
            delete slots[key];
          }
        }
      }
    };
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = Object.assign({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted2 = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin2, ...options) {
            if (installedPlugins.has(plugin2))
              ;
            else if (plugin2 && isFunction$1(plugin2.install)) {
              installedPlugins.add(plugin2);
              plugin2.install(app, ...options);
            } else if (isFunction$1(plugin2)) {
              installedPlugins.add(plugin2);
              plugin2(app, ...options);
            } else
              ;
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, isSVG2) {
            if (!isMounted2) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, isSVG2);
              }
              isMounted2 = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted2) {
              render2(null, app._container);
              delete app._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app;
          }
        };
        return app;
      };
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$2(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref2 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref2) {
        if (isString(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref2)) {
        callWithErrorHandling(ref2, owner, 12, [value, refs]);
      } else {
        const _isString = isString(ref2);
        const _isRef = isRef(ref2);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
              if (isUnmount) {
                isArray$2(existing) && remove(existing, refValue);
              } else {
                if (!isArray$2(existing)) {
                  if (_isString) {
                    refs[ref2] = [refValue];
                    if (hasOwn(setupState, ref2)) {
                      setupState[ref2] = refs[ref2];
                    }
                  } else {
                    ref2.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref2.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref2] = value;
              if (hasOwn(setupState, ref2)) {
                setupState[ref2] = value;
              }
            } else if (_isRef) {
              ref2.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
      const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG2 = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n12 === n2) {
          return;
        }
        if (n12 && !isSameVNodeType(n12, n2)) {
          anchor = getNextHostNode(n12);
          unmount2(n12, parentComponent, parentSuspense, true);
          n12 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type: type2, ref: ref2, shapeFlag } = n2;
        switch (type2) {
          case Text:
            processText(n12, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n12, n2, container, anchor);
            break;
          case Static:
            if (n12 == null) {
              mountStaticNode(n2, container, anchor, isSVG2);
            }
            break;
          case Fragment:
            processFragment(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            break;
          default:
            if (shapeFlag & 1) {
              processElement(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            } else if (shapeFlag & 6) {
              processComponent(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            } else if (shapeFlag & 64) {
              type2.process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals);
            } else if (shapeFlag & 128) {
              type2.process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals);
            } else
              ;
        }
        if (ref2 != null && parentComponent) {
          setRef(ref2, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
        }
      };
      const processText = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        } else {
          const el = n2.el = n12.el;
          if (n2.children !== n12.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        } else {
          n2.el = n12.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, isSVG2) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG2, n2.el, n2.anchor);
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        isSVG2 = isSVG2 || n2.type === "svg";
        if (n12 == null) {
          mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        } else {
          patchElement(n12, n2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type: type2, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, isSVG2, props && props.is, props);
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG2 && type2 !== "foreignObject", slotScopeIds, optimized);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], isSVG2, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        }
      };
      const patchElement = (n12, n2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        const el = n2.el = n12.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n12.patchFlag & 16;
        const oldProps = n12.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        const areChildrenSVG = isSVG2 && n2.type !== "foreignObject";
        if (dynamicChildren) {
          patchBlockChildren(n12.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
        } else if (!optimized) {
          patchChildren(n12, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG2);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, isSVG2);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG2);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, isSVG2, n12.children, parentComponent, parentSuspense, unmountChildren);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n12.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG2);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
            dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG2, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, true);
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG2) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(el, key, oldProps[key], null, isSVG2, vnode.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, isSVG2, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value);
          }
        }
      };
      const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n12 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n12.dynamicChildren) {
            patchBlockChildren(n12.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG2, slotScopeIds);
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n12,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(n12, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
          }
        }
      };
      const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n12 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(n2, container, anchor, isSVG2, optimized);
          } else {
            mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG2, optimized);
          }
        } else {
          updateComponent(n12, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG2, optimized) => {
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
          return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG2, optimized);
      };
      const updateComponent = (n12, n2, optimized) => {
        const instance = n2.component = n12.component;
        if (shouldUpdateComponent(n12, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.update();
          }
        } else {
          n2.el = n12.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG2, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(null, subTree, container, anchor, instance, parentSuspense, isSVG2);
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              isSVG2
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
            }
          }
        };
        const effect = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => effect.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs();
        resetTracking();
      };
      const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized = false) => {
        const c1 = n12 && n12.children;
        const prevShapeFlag = n12 ? n12.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
          unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        } else {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, commonLength);
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n12 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n12, n2)) {
            patch(n12, n2, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n12 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n12, n2)) {
            patch(n12, n2, container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount2(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move2(
                  nextChild,
                  container,
                  anchor,
                  2
                  /* MoveType.REORDER */
                );
              } else {
                j--;
              }
            }
          }
        }
      };
      const move2 = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type: type2, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move2(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type2.move(vnode, container, anchor, internals);
          return;
        }
        if (type2 === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move2(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type2 === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove3 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove3();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove3, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type: type2, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref2 != null) {
          setRef(ref2, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
          } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type: type2, el, anchor, transition } = vnode;
        if (type2 === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type2 === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount2(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount2(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      const render2 = (vnode, container, isSVG2) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount2(container._vnode, null, null, true);
          }
        } else {
          patch(container._vnode || null, vnode, container, null, null, null, isSVG2);
        }
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount2,
        m: move2,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
      }
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2, hydrate)
      };
    }
    function toggleRecurse({ effect, update }, allowed) {
      effect.allowRecurse = update.allowRecurse = allowed;
    }
    function traverseStaticChildren(n12, n2, shallow = false) {
      const ch1 = n12.children;
      const ch2 = n2.children;
      if (isArray$2(ch1) && isArray$2(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c2;
      const len2 = arr.length;
      for (i = 0; i < len2; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c2 = u + v >> 1;
            if (arr[result[c2]] < arrI) {
              u = c2 + 1;
            } else {
              v = c2;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    const isTeleport = (type2) => type2.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      __isTeleport: true,
      process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n12 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            isSVG2 = isSVG2 || isTargetSVG(target);
          }
          const mount2 = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized);
            }
          };
          if (disabled) {
            mount2(container, mainAnchor);
          } else if (target) {
            mount2(target, targetAnchor);
          }
        } else {
          n2.el = n12.el;
          const mainAnchor = n2.anchor = n12.anchor;
          const target = n2.target = n12.target;
          const targetAnchor = n2.targetAnchor = n12.targetAnchor;
          const wasDisabled = isTeleportDisabled(n12.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          isSVG2 = isSVG2 || isTargetSVG(target);
          if (dynamicChildren) {
            patchBlockChildren(n12.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG2, slotScopeIds);
            traverseStaticChildren(n12, n2, true);
          } else if (!optimized) {
            patchChildren(n12, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, false);
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
                /* TeleportMoveTypes.TOGGLE */
              );
            }
          } else {
            if ((n2.props && n2.props.to) !== (n12.props && n12.props.to)) {
              const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                  /* TeleportMoveTypes.TARGET_CHANGE */
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
                /* TeleportMoveTypes.TOGGLE */
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        if (doRemove || !isTeleportDisabled(props)) {
          hostRemove(anchor);
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              unmount2(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move2 }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move2(
              children[i],
              container,
              parentAnchor,
              2
              /* MoveType.REORDER */
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
      const target = vnode.target = resolveTarget(vnode.props, querySelector);
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx2 = vnode.ctx;
      if (ctx2 && ctx2.ut) {
        let node = vnode.children[0].el;
        while (node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx2.uid);
          node = node.nextSibling;
        }
        ctx2.ut();
      }
    }
    const Fragment = Symbol(void 0);
    const Text = Symbol(void 0);
    const Comment = Symbol(void 0);
    const Static = Symbol(void 0);
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createBlock(type2, props, children, patchFlag, dynamicProps) {
      return setupBlock(createVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
        /* isBlock: prevent a block from tracking itself */
      ));
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n12, n2) {
      return n12.type === n2.type && n12.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
      return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
    };
    function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type: type2,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type2.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
        type2 = Comment;
      }
      if (isVNode(type2)) {
        const cloned = cloneVNode(
          type2,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type2)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type2)) {
        type2 = type2.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style: style2 } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style2)) {
          if (isProxy(style2) && !isArray$2(style2)) {
            style2 = extend({}, style2);
          }
          props.style = normalizeStyle(style2);
        }
      }
      const shapeFlag = isString(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$1(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
      return createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref2, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref2,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$2(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type2 = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$2(children)) {
        type2 = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type2 = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type2 = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type2 = 16;
          children = [createTextVNode(children)];
        } else {
          type2 = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type2;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type2 = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type: type2,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type2, appContext),
        emitsOptions: normalizeEmitsOptions(type2, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type2.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    const setCurrentInstance = (instance) => {
      currentInstance = instance;
      instance.scope.on();
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      currentInstance = null;
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isInSSRComponentSetup = false;
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup: setup2 } = Component;
      if (setup2) {
        const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(setup2, instance, 0, [instance.props, setupContext]);
        resetTracking();
        unsetCurrentInstance();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(
                e,
                instance,
                0
                /* ErrorCodes.SETUP_FUNCTION */
              );
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend(extend({
              isCustomElement,
              delimiters
            }, compilerOptions), componentCompilerOptions);
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        setCurrentInstance(instance);
        pauseTracking();
        applyOptions(instance);
        resetTracking();
        unsetCurrentInstance();
      }
    }
    function createAttrsProxy(instance) {
      return new Proxy(instance.attrs, {
        get(target, key) {
          track(instance, "get", "$attrs");
          return target[key];
        }
      });
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      let attrs;
      {
        return {
          get attrs() {
            return attrs || (attrs = createAttrsProxy(instance));
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type2, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type2, null, [propsOrChildren]);
          }
          return createVNode(type2, propsOrChildren);
        } else {
          return createVNode(type2, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type2, propsOrChildren, children);
      }
    }
    const ssrContextKey$1 = Symbol(``);
    const useSSRContext = () => {
      {
        const ctx2 = inject(ssrContextKey$1);
        return ctx2;
      }
    };
    const version = "3.2.47";
    const svgNS = "http://www.w3.org/2000/svg";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, isSVG2, is, props) => {
        const el = isSVG2 ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, isSVG2, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = isSVG2 ? `<svg>${content}</svg>` : content;
          const template = templateContainer.content;
          if (isSVG2) {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    function patchClass(el, value, isSVG2) {
      const transitionClasses = el._vtc;
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG2) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    function patchStyle(el, prev, next) {
      const style2 = el.style;
      const isCssString = isString(next);
      if (next && !isCssString) {
        if (prev && !isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style2, key, "");
            }
          }
        }
        for (const key in next) {
          setStyle(style2, key, next[key]);
        }
      } else {
        const currentDisplay = style2.display;
        if (isCssString) {
          if (prev !== next) {
            style2.cssText = next;
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
        if ("_vod" in el) {
          style2.display = currentDisplay;
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style2, name, val) {
      if (isArray$2(val)) {
        val.forEach((v) => setStyle(style2, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style2.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style2, name);
          if (importantRE.test(val)) {
            style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
          } else {
            style2[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style2, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style2) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style2) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG2, instance) {
      if (isSVG2 && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean = isSpecialBooleanAttr(key);
        if (value == null || isBoolean && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      if (key === "value" && el.tagName !== "PROGRESS" && // custom elements may use _value internally
      !el.tagName.includes("-")) {
        el._value = value;
        const newValue = value == null ? "" : value;
        if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
        // textContent if no value attribute is present. And setting .value for
        // OPTION has no side effect
        el.tagName === "OPTION") {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type2 = typeof el[key];
        if (type2 === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type2 === "string") {
          value = "";
          needRemove = true;
        } else if (type2 === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el._vei || (el._vei = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$2(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
      } else {
        return value;
      }
    }
    const nativeOnRE = /^on[a-z]/;
    const patchProp = (el, key, prevValue, nextValue, isSVG2 = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      if (key === "class") {
        patchClass(el, nextValue, isSVG2);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG2)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG2);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG2) {
      if (isSVG2) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && nativeOnRE.test(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (nativeOnRE.test(key) && isString(value)) {
        return false;
      }
      return key in el;
    }
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
    const callHook = (hook, args = []) => {
      if (isArray$2(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const { name = "v", type: type2, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type2, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type2, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$1(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
      (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
      const { _vtc } = el;
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el._vtc = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type2) {
        return resolve2();
      }
      const endEvent = type2 + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles2 = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles2[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type2 = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type2 = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type2 = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
      return {
        type: type2,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el = c2.el;
            const style2 = el.style;
            addTransitionClass(el, moveClass);
            style2.transform = style2.webkitTransform = style2.transitionDuration = "";
            const cb = el._moveCb = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el._moveCb = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
            }
          }
          if (prevChildren) {
            for (let i = 0; i < prevChildren.length; i++) {
              const child = prevChildren[i];
              setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el = c2.el;
      if (el._moveCb) {
        el._moveCb();
      }
      if (el._enterCb) {
        el._enterCb();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c2.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone = el.cloneNode();
      if (el._vtc) {
        el._vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
      clone.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
    }
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el._vod : "none";
    }
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      const { mount: mount2 } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount2(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function normalizeContainer(container) {
      if (isString(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    let onceCbs = [];
    const paramsMap = /* @__PURE__ */ new WeakMap();
    function flushOnceCallbacks() {
      onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
      onceCbs = [];
    }
    function beforeNextFrameOnce(cb, ...params) {
      paramsMap.set(cb, params);
      if (onceCbs.includes(cb))
        return;
      onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
    }
    function happensIn(e, dataSetPropName) {
      let { target } = e;
      while (target) {
        if (target.dataset) {
          if (target.dataset[dataSetPropName] !== void 0)
            return true;
        }
        target = target.parentElement;
      }
      return false;
    }
    function getPreciseEventTarget(event) {
      return event.composedPath()[0] || null;
    }
    function depx(value) {
      if (typeof value === "string") {
        if (value.endsWith("px")) {
          return Number(value.slice(0, value.length - 2));
        }
        return Number(value);
      }
      return value;
    }
    function pxfy(value) {
      if (value === void 0 || value === null)
        return void 0;
      if (typeof value === "number")
        return `${value}px`;
      if (value.endsWith("px"))
        return value;
      return `${value}px`;
    }
    function getMargin(value, position) {
      const parts = value.trim().split(/\s+/g);
      const margin = {
        top: parts[0]
      };
      switch (parts.length) {
        case 1:
          margin.right = parts[0];
          margin.bottom = parts[0];
          margin.left = parts[0];
          break;
        case 2:
          margin.right = parts[1];
          margin.left = parts[1];
          margin.bottom = parts[0];
          break;
        case 3:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[1];
          break;
        case 4:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[3];
          break;
        default:
          throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
      }
      if (position === void 0)
        return margin;
      return margin[position];
    }
    const colors = {
      black: "#000",
      silver: "#C0C0C0",
      gray: "#808080",
      white: "#FFF",
      maroon: "#800000",
      red: "#F00",
      purple: "#800080",
      fuchsia: "#F0F",
      green: "#008000",
      lime: "#0F0",
      olive: "#808000",
      yellow: "#FF0",
      navy: "#000080",
      blue: "#00F",
      teal: "#008080",
      aqua: "#0FF",
      transparent: "#0000"
    };
    const prefix$1 = "^\\s*";
    const suffix = "\\s*$";
    const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
    const hex = "([0-9A-Fa-f])";
    const dhex = "([0-9A-Fa-f]{2})";
    const rgbRegex = new RegExp(`${prefix$1}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
    const rgbaRegex = new RegExp(`${prefix$1}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
    const sHexRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${suffix}`);
    const hexRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${suffix}`);
    const sHexaRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${hex}${suffix}`);
    const hexaRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
    function parseHex(value) {
      return parseInt(value, 16);
    }
    function rgba(color) {
      try {
        let i;
        if (i = hexRegex.exec(color)) {
          return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
        } else if (i = rgbRegex.exec(color)) {
          return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
        } else if (i = rgbaRegex.exec(color)) {
          return [
            roundChannel(i[1]),
            roundChannel(i[5]),
            roundChannel(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = sHexRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            1
          ];
        } else if (i = hexaRegex.exec(color)) {
          return [
            parseHex(i[1]),
            parseHex(i[2]),
            parseHex(i[3]),
            roundAlpha(parseHex(i[4]) / 255)
          ];
        } else if (i = sHexaRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            roundAlpha(parseHex(i[4] + i[4]) / 255)
          ];
        } else if (color in colors) {
          return rgba(colors[color]);
        }
        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function normalizeAlpha(alphaValue) {
      return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
    }
    function stringifyRgba(r, g, b, a) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
    }
    function compositeChannel(v1, a1, v2, a2, a) {
      return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
    }
    function composite(background, overlay2) {
      if (!Array.isArray(background))
        background = rgba(background);
      if (!Array.isArray(overlay2))
        overlay2 = rgba(overlay2);
      const a1 = background[3];
      const a2 = overlay2[3];
      const alpha = roundAlpha(a1 + a2 - a1 * a2);
      return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a2, alpha), compositeChannel(background[1], a1, overlay2[1], a2, alpha), compositeChannel(background[2], a1, overlay2[2], a2, alpha), alpha);
    }
    function changeColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      if (options.alpha) {
        return stringifyRgba(r, g, b, options.alpha);
      }
      return stringifyRgba(r, g, b, a);
    }
    function scaleColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      const { lightness = 1, alpha = 1 } = options;
      return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
    }
    function roundAlpha(value) {
      const v = Math.round(Number(value) * 100) / 100;
      if (v > 1)
        return 1;
      if (v < 0)
        return 0;
      return v;
    }
    function roundChannel(value) {
      const v = Math.round(Number(value));
      if (v > 255)
        return 255;
      if (v < 0)
        return 0;
      return v;
    }
    function toRgbaString(base2) {
      const [r, g, b] = base2;
      if (3 in base2) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
      }
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
    }
    function createId(length = 8) {
      return Math.random().toString(16).slice(2, 2 + length);
    }
    function repeat(count, v) {
      const ret = [];
      for (let i = 0; i < count; ++i) {
        ret.push(v);
      }
      return ret;
    }
    function getSlot$1(instance, slotName = "default", fallback = []) {
      const slots = instance.$slots;
      const slot = slots[slotName];
      if (slot === void 0)
        return fallback;
      return slot();
    }
    function keep(object2, keys2 = [], rest) {
      const keepedObject = {};
      keys2.forEach((key) => {
        keepedObject[key] = object2[key];
      });
      return Object.assign(keepedObject, rest);
    }
    function omit(object2, keys2 = [], rest) {
      const omitedObject = {};
      const originalKeys = Object.getOwnPropertyNames(object2);
      originalKeys.forEach((originalKey) => {
        if (!keys2.includes(originalKey)) {
          omitedObject[originalKey] = object2[originalKey];
        }
      });
      return Object.assign(omitedObject, rest);
    }
    function flatten$3(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
        if (vNode === null)
          return;
        if (typeof vNode !== "object") {
          if (typeof vNode === "string" || typeof vNode === "number") {
            result.push(createTextVNode(String(vNode)));
          }
          return;
        }
        if (Array.isArray(vNode)) {
          flatten$3(vNode, filterCommentNode, result);
          return;
        }
        if (vNode.type === Fragment) {
          if (vNode.children === null)
            return;
          if (Array.isArray(vNode.children)) {
            flatten$3(vNode.children, filterCommentNode, result);
          }
        } else if (vNode.type !== Comment) {
          result.push(vNode);
        }
      });
      return result;
    }
    function call(funcs, ...args) {
      if (Array.isArray(funcs)) {
        funcs.forEach((func) => call(func, ...args));
      } else
        return funcs(...args);
    }
    function keysOf(obj) {
      return Object.keys(obj);
    }
    const render$1 = (r, ...args) => {
      if (typeof r === "function") {
        return r(...args);
      } else if (typeof r === "string") {
        return createTextVNode(r);
      } else if (typeof r === "number") {
        return createTextVNode(String(r));
      } else {
        return null;
      }
    };
    function warn$2(location, message) {
      console.error(`[naive/${location}]: ${message}`);
    }
    function throwError(location, message) {
      throw new Error(`[naive/${location}]: ${message}`);
    }
    function smallerSize(size2) {
      switch (size2) {
        case "tiny":
          return "mini";
        case "small":
          return "tiny";
        case "medium":
          return "small";
        case "large":
          return "medium";
        case "huge":
          return "large";
      }
      throw Error(`${size2} has no smaller size.`);
    }
    function getTitleAttribute(value) {
      switch (typeof value) {
        case "string":
          return value || void 0;
        case "number":
          return String(value);
        default:
          return void 0;
      }
    }
    function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
      const slot = slots[slotName];
      if (!slot) {
        warn$2("getFirstSlotVNode", `slot[${slotName}] is empty`);
        return null;
      }
      const slotContent = flatten$3(slot(props));
      if (slotContent.length === 1) {
        return slotContent[0];
      } else {
        warn$2("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
        return null;
      }
    }
    function createRefSetter(ref2) {
      return (inst) => {
        if (inst) {
          ref2.value = inst.$el;
        } else {
          ref2.value = null;
        }
      };
    }
    function createInjectionKey(key) {
      return key;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) {
          return true;
        }
        if (child.type === Comment) {
          return false;
        }
        if (child.type === Fragment && !ensureValidVNode(child.children)) {
          return false;
        }
        return true;
      }) ? vnodes : null;
    }
    function resolveSlot(slot, fallback) {
      return slot && ensureValidVNode(slot()) || fallback();
    }
    function resolveSlotWithProps(slot, props, fallback) {
      return slot && ensureValidVNode(slot(props)) || fallback(props);
    }
    function resolveWrappedSlot(slot, wrapper) {
      const children = slot && ensureValidVNode(slot());
      return wrapper(children || null);
    }
    function isSlotEmpty(slot) {
      return !(slot && ensureValidVNode(slot()));
    }
    function mergeEventHandlers(handlers) {
      const filteredHandlers = handlers.filter((handler) => handler !== void 0);
      if (filteredHandlers.length === 0)
        return void 0;
      if (filteredHandlers.length === 1)
        return filteredHandlers[0];
      return (e) => {
        handlers.forEach((handler) => {
          if (handler) {
            handler(e);
          }
        });
      };
    }
    const Wrapper = defineComponent({
      render() {
        var _a, _b;
        return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    });
    const pureNumberRegex = /^(\d|\.)+$/;
    const numberRegex = /(\d|\.)+/;
    function formatLength(length, { c: c2 = 1, offset = 0, attachPx = true } = {}) {
      if (typeof length === "number") {
        const result = (length + offset) * c2;
        if (result === 0)
          return "0";
        return `${result}px`;
      } else if (typeof length === "string") {
        if (pureNumberRegex.test(length)) {
          const result = (Number(length) + offset) * c2;
          if (attachPx) {
            if (result === 0)
              return "0";
            return `${result}px`;
          } else {
            return `${result}`;
          }
        } else {
          const result = numberRegex.exec(length);
          if (!result)
            return length;
          return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
        }
      }
      return length;
    }
    function color2Class(color) {
      return color.replace(/#|\(|\)|,|\s/g, "_");
    }
    function ampCount(selector) {
      let cnt = 0;
      for (let i = 0; i < selector.length; ++i) {
        if (selector[i] === "&")
          ++cnt;
      }
      return cnt;
    }
    const separatorRegex = /\s*,(?![^(]*\))\s*/g;
    const extraSpaceRegex = /\s+/g;
    function resolveSelectorWithAmp(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        let round = ampCount(partialSelector);
        if (!round) {
          amp.forEach((partialAmp) => {
            nextAmp.push(
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              (partialAmp && partialAmp + " ") + partialSelector
            );
          });
          return;
        } else if (round === 1) {
          amp.forEach((partialAmp) => {
            nextAmp.push(partialSelector.replace("&", partialAmp));
          });
          return;
        }
        let partialNextAmp = [
          partialSelector
        ];
        while (round--) {
          const nextPartialNextAmp = [];
          partialNextAmp.forEach((selectorItr) => {
            amp.forEach((partialAmp) => {
              nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
            });
          });
          partialNextAmp = nextPartialNextAmp;
        }
        partialNextAmp.forEach((part) => nextAmp.push(part));
      });
      return nextAmp;
    }
    function resolveSelector(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        amp.forEach((partialAmp) => {
          nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
        });
      });
      return nextAmp;
    }
    function parseSelectorPath(selectorPaths) {
      let amp = [""];
      selectorPaths.forEach((selector) => {
        selector = selector && selector.trim();
        if (
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          !selector
        ) {
          return;
        }
        if (selector.includes("&")) {
          amp = resolveSelectorWithAmp(amp, selector);
        } else {
          amp = resolveSelector(amp, selector);
        }
      });
      return amp.join(", ").replace(extraSpaceRegex, " ");
    }
    function removeElement(el) {
      if (!el)
        return;
      const parentElement = el.parentElement;
      if (parentElement)
        parentElement.removeChild(el);
    }
    function queryElement(id) {
      return document.querySelector(`style[cssr-id="${id}"]`);
    }
    function createElement(id) {
      const el = document.createElement("style");
      el.setAttribute("cssr-id", id);
      return el;
    }
    function isMediaOrSupports(selector) {
      if (!selector)
        return false;
      return /^\s*@(s|m)/.test(selector);
    }
    const kebabRegex = /[A-Z]/g;
    function kebabCase(pattern2) {
      return pattern2.replace(kebabRegex, (match2) => "-" + match2.toLowerCase());
    }
    function unwrapProperty(prop, indent = "  ") {
      if (typeof prop === "object" && prop !== null) {
        return " {\n" + Object.entries(prop).map((v) => {
          return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
        }).join("\n") + "\n" + indent + "}";
      }
      return `: ${prop};`;
    }
    function unwrapProperties(props, instance, params) {
      if (typeof props === "function") {
        return props({
          context: instance.context,
          props: params
        });
      }
      return props;
    }
    function createStyle(selector, props, instance, params) {
      if (!props)
        return "";
      const unwrappedProps = unwrapProperties(props, instance, params);
      if (!unwrappedProps)
        return "";
      if (typeof unwrappedProps === "string") {
        return `${selector} {
${unwrappedProps}
}`;
      }
      const propertyNames = Object.keys(unwrappedProps);
      if (propertyNames.length === 0) {
        if (instance.config.keepEmptyBlock)
          return selector + " {\n}";
        return "";
      }
      const statements = selector ? [
        selector + " {"
      ] : [];
      propertyNames.forEach((propertyName) => {
        const property2 = unwrappedProps[propertyName];
        if (propertyName === "raw") {
          statements.push("\n" + property2 + "\n");
          return;
        }
        propertyName = kebabCase(propertyName);
        if (property2 !== null && property2 !== void 0) {
          statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
        }
      });
      if (selector) {
        statements.push("}");
      }
      return statements.join("\n");
    }
    function loopCNodeListWithCallback(children, options, callback) {
      if (!children)
        return;
      children.forEach((child) => {
        if (Array.isArray(child)) {
          loopCNodeListWithCallback(child, options, callback);
        } else if (typeof child === "function") {
          const grandChildren = child(options);
          if (Array.isArray(grandChildren)) {
            loopCNodeListWithCallback(grandChildren, options, callback);
          } else if (grandChildren) {
            callback(grandChildren);
          }
        } else if (child) {
          callback(child);
        }
      });
    }
    function traverseCNode(node, selectorPaths, styles2, instance, params, styleSheet) {
      const $ = node.$;
      let blockSelector = "";
      if (!$ || typeof $ === "string") {
        if (isMediaOrSupports($)) {
          blockSelector = $;
        } else {
          selectorPaths.push($);
        }
      } else if (typeof $ === "function") {
        const selector2 = $({
          context: instance.context,
          props: params
        });
        if (isMediaOrSupports(selector2)) {
          blockSelector = selector2;
        } else {
          selectorPaths.push(selector2);
        }
      } else {
        if ($.before)
          $.before(instance.context);
        if (!$.$ || typeof $.$ === "string") {
          if (isMediaOrSupports($.$)) {
            blockSelector = $.$;
          } else {
            selectorPaths.push($.$);
          }
        } else if ($.$) {
          const selector2 = $.$({
            context: instance.context,
            props: params
          });
          if (isMediaOrSupports(selector2)) {
            blockSelector = selector2;
          } else {
            selectorPaths.push(selector2);
          }
        }
      }
      const selector = parseSelectorPath(selectorPaths);
      const style2 = createStyle(selector, node.props, instance, params);
      if (blockSelector) {
        styles2.push(`${blockSelector} {`);
        if (styleSheet && style2) {
          styleSheet.insertRule(`${blockSelector} {
${style2}
}
`);
        }
      } else {
        if (styleSheet && style2) {
          styleSheet.insertRule(style2);
        }
        if (!styleSheet && style2.length)
          styles2.push(style2);
      }
      if (node.children) {
        loopCNodeListWithCallback(node.children, {
          context: instance.context,
          props: params
        }, (childNode) => {
          if (typeof childNode === "string") {
            const style3 = createStyle(selector, { raw: childNode }, instance, params);
            if (styleSheet) {
              styleSheet.insertRule(style3);
            } else {
              styles2.push(style3);
            }
          } else {
            traverseCNode(childNode, selectorPaths, styles2, instance, params, styleSheet);
          }
        });
      }
      selectorPaths.pop();
      if (blockSelector) {
        styles2.push("}");
      }
      if ($ && $.after)
        $.after(instance.context);
    }
    function render(node, instance, props, insertRule = false) {
      const styles2 = [];
      traverseCNode(node, [], styles2, instance, props, insertRule ? node.instance.__styleSheet : void 0);
      if (insertRule)
        return "";
      return styles2.join("\n\n");
    }
    function murmur2(str) {
      var h2 = 0;
      var k, i = 0, len2 = str.length;
      for (; len2 >= 4; ++i, len2 -= 4) {
        k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
        k ^= /* k >>> r: */
        k >>> 24;
        h2 = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len2) {
        case 3:
          h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    if (typeof window !== "undefined") {
      window.__cssrContext = {};
    }
    function unmount(intance, node, id) {
      const { els } = node;
      if (id === void 0) {
        els.forEach(removeElement);
        node.els = [];
      } else {
        const target = queryElement(id);
        if (target && els.includes(target)) {
          removeElement(target);
          node.els = els.filter((el) => el !== target);
        }
      }
    }
    function addElementToList(els, target) {
      els.push(target);
    }
    function mount(instance, node, id, props, head, silent, force, anchorMetaName, ssrAdapter2) {
      if (silent && !ssrAdapter2) {
        if (id === void 0) {
          console.error("[css-render/mount]: `id` is required in `silent` mode.");
          return;
        }
        const cssrContext = window.__cssrContext;
        if (!cssrContext[id]) {
          cssrContext[id] = true;
          render(node, instance, props, silent);
        }
        return;
      }
      let style2;
      if (id === void 0) {
        style2 = node.render(props);
        id = murmur2(style2);
      }
      if (ssrAdapter2) {
        ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
        return;
      }
      const queriedTarget = queryElement(id);
      if (queriedTarget !== null && !force) {
        return queriedTarget;
      }
      const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
      if (style2 === void 0)
        style2 = node.render(props);
      target.textContent = style2;
      if (queriedTarget !== null)
        return queriedTarget;
      if (anchorMetaName) {
        const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);
        if (anchorMetaEl) {
          document.head.insertBefore(target, anchorMetaEl);
          addElementToList(node.els, target);
          return target;
        }
      }
      if (head) {
        document.head.insertBefore(target, document.head.querySelector("style, link"));
      } else {
        document.head.appendChild(target);
      }
      addElementToList(node.els, target);
      return target;
    }
    function wrappedRender(props) {
      return render(this, this.instance, props);
    }
    function wrappedMount(options = {}) {
      const { id, ssr, props, head = false, silent = false, force = false, anchorMetaName } = options;
      const targetElement = mount(this.instance, this, id, props, head, silent, force, anchorMetaName, ssr);
      return targetElement;
    }
    function wrappedUnmount(options = {}) {
      const { id } = options;
      unmount(this.instance, this, id);
    }
    const createCNode = function(instance, $, props, children) {
      return {
        instance,
        $,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
      };
    };
    const c$2 = function(instance, $, props, children) {
      if (Array.isArray($)) {
        return createCNode(instance, { $: null }, null, $);
      } else if (Array.isArray(props)) {
        return createCNode(instance, $, null, props);
      } else if (Array.isArray(children)) {
        return createCNode(instance, $, props, children);
      } else {
        return createCNode(instance, $, props, null);
      }
    };
    function CssRender(config = {}) {
      let styleSheet = null;
      const cssr2 = {
        c: (...args) => c$2(cssr2, ...args),
        use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
        find: queryElement,
        context: {},
        config,
        get __styleSheet() {
          if (!styleSheet) {
            const style2 = document.createElement("style");
            document.head.appendChild(style2);
            styleSheet = document.styleSheets[document.styleSheets.length - 1];
            return styleSheet;
          }
          return styleSheet;
        }
      };
      return cssr2;
    }
    function exists(id, ssr) {
      if (id === void 0)
        return false;
      if (ssr) {
        const { context: { ids } } = ssr;
        return ids.has(id);
      }
      return queryElement(id) !== null;
    }
    function plugin$1(options) {
      let _bPrefix = ".";
      let _ePrefix = "__";
      let _mPrefix = "--";
      let c2;
      if (options) {
        let t = options.blockPrefix;
        if (t) {
          _bPrefix = t;
        }
        t = options.elementPrefix;
        if (t) {
          _ePrefix = t;
        }
        t = options.modifierPrefix;
        if (t) {
          _mPrefix = t;
        }
      }
      const _plugin = {
        install(instance) {
          c2 = instance.c;
          const ctx2 = instance.context;
          ctx2.bem = {};
          ctx2.bem.b = null;
          ctx2.bem.els = null;
        }
      };
      function b(arg) {
        let memorizedB;
        let memorizedE;
        return {
          before(ctx2) {
            memorizedB = ctx2.bem.b;
            memorizedE = ctx2.bem.els;
            ctx2.bem.els = null;
          },
          after(ctx2) {
            ctx2.bem.b = memorizedB;
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.b = arg;
            return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
          }
        };
      }
      function e(arg) {
        let memorizedE;
        return {
          before(ctx2) {
            memorizedE = ctx2.bem.els;
          },
          after(ctx2) {
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.els = arg.split(",").map((v) => v.trim());
            return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
          }
        };
      }
      function m(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const modifiers = arg.split(",").map((v) => v.trim());
            function elementToSelector(el) {
              return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
            }
            const els = context.bem.els;
            if (els !== null) {
              return elementToSelector(els[0]);
            } else {
              return elementToSelector();
            }
          }
        };
      }
      function notM(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const els = context.bem.els;
            return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
          }
        };
      }
      const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
      const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
      const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
      const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
      Object.assign(_plugin, {
        cB: cB2,
        cE: cE2,
        cM: cM2,
        cNotM: cNotM2
      });
      return _plugin;
    }
    function createKey(prefix2, suffix2) {
      return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
    }
    createKey("abc", "def");
    const namespace = "n";
    const prefix = `.${namespace}-`;
    const elementPrefix = "__";
    const modifierPrefix = "--";
    const cssr = CssRender();
    const plugin = plugin$1({
      blockPrefix: prefix,
      elementPrefix,
      modifierPrefix
    });
    cssr.use(plugin);
    const { c: c$1, find } = cssr;
    const { cB, cE, cM, cNotM } = plugin;
    function insideModal(style2) {
      return c$1(({ props: { bPrefix } }) => `${bPrefix || prefix}modal, ${bPrefix || prefix}drawer`, [style2]);
    }
    function insidePopover(style2) {
      return c$1(({ props: { bPrefix } }) => `${bPrefix || prefix}popover`, [style2]);
    }
    function asModal(style2) {
      return c$1(({ props: { bPrefix } }) => `&${bPrefix || prefix}modal`, style2);
    }
    const cCB = (...args) => {
      return c$1(">", [cB(...args)]);
    };
    let _isJsdom;
    function isJsdom() {
      if (_isJsdom === void 0) {
        _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
      }
      return _isJsdom;
    }
    const isBrowser$2 = typeof document !== "undefined" && typeof window !== "undefined";
    const eventSet = /* @__PURE__ */ new WeakSet();
    function markEventEffectPerformed(event) {
      eventSet.add(event);
    }
    function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
      var _a;
      const injection = inject(injectionName, null);
      if (injection === null)
        return;
      const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
      watch(registerKeyRef, registerInstance);
      registerInstance(registerKeyRef.value);
      onBeforeUnmount(() => {
        registerInstance(void 0, registerKeyRef.value);
      });
      function registerInstance(key, oldKey) {
        const collection = injection[collectionKey];
        if (oldKey !== void 0)
          removeInstance(collection, oldKey);
        if (key !== void 0)
          addInstance(collection, key);
      }
      function removeInstance(collection, key) {
        if (!collection[key])
          collection[key] = [];
        collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);
      }
      function addInstance(collection, key) {
        if (!collection[key])
          collection[key] = [];
        if (!~collection[key].findIndex((instance) => instance === vm)) {
          collection[key].push(vm);
        }
      }
    }
    function useDeferredTrue(valueRef, delay, shouldDelayRef) {
      if (!delay)
        return valueRef;
      const delayedRef = ref(valueRef.value);
      let timerId = null;
      watch(valueRef, (value) => {
        if (timerId !== null)
          window.clearTimeout(timerId);
        if (value === true) {
          if (shouldDelayRef && !shouldDelayRef.value) {
            delayedRef.value = true;
          } else {
            timerId = window.setTimeout(() => {
              delayedRef.value = true;
            }, delay);
          }
        } else {
          delayedRef.value = false;
        }
      });
      return delayedRef;
    }
    function useFalseUntilTruthy(originalRef) {
      const currentRef = ref(!!originalRef.value);
      if (currentRef.value)
        return readonly(currentRef);
      const stop = watch(originalRef, (value) => {
        if (value) {
          currentRef.value = true;
          stop();
        }
      });
      return readonly(currentRef);
    }
    function useMemo(getterOrOptions) {
      const computedValueRef = computed(getterOrOptions);
      const valueRef = ref(computedValueRef.value);
      watch(computedValueRef, (value) => {
        valueRef.value = value;
      });
      if (typeof getterOrOptions === "function") {
        return valueRef;
      } else {
        return {
          __v_isRef: true,
          get value() {
            return valueRef.value;
          },
          set value(v) {
            getterOrOptions.set(v);
          }
        };
      }
    }
    function hasInstance() {
      return getCurrentInstance() !== null;
    }
    const isBrowser$1 = typeof window !== "undefined";
    let fontsReady;
    let isFontReady;
    const init = () => {
      var _a, _b;
      fontsReady = isBrowser$1 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
      isFontReady = false;
      if (fontsReady !== void 0) {
        void fontsReady.then(() => {
          isFontReady = true;
        });
      } else {
        isFontReady = true;
      }
    };
    init();
    function onFontsReady(cb) {
      if (isFontReady)
        return;
      let deactivated = false;
      onMounted(() => {
        if (!isFontReady) {
          fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
            if (deactivated)
              return;
            cb();
          });
        }
      });
      onBeforeUnmount(() => {
        deactivated = true;
      });
    }
    function getEventTarget(e) {
      const path = e.composedPath();
      return path[0];
    }
    const traps = {
      mousemoveoutside: /* @__PURE__ */ new WeakMap(),
      clickoutside: /* @__PURE__ */ new WeakMap()
    };
    function createTrapHandler(name, el, originalHandler) {
      if (name === "mousemoveoutside") {
        const moveHandler = (e) => {
          if (el.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousemove: moveHandler,
          touchstart: moveHandler
        };
      } else if (name === "clickoutside") {
        let mouseDownOutside = false;
        const downHandler = (e) => {
          mouseDownOutside = !el.contains(getEventTarget(e));
        };
        const upHanlder = (e) => {
          if (!mouseDownOutside)
            return;
          if (el.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousedown: downHandler,
          mouseup: upHanlder,
          touchstart: downHandler,
          touchend: upHanlder
        };
      }
      console.error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
      );
      return {};
    }
    function ensureTrapHandlers(name, el, handler) {
      const handlers = traps[name];
      let elHandlers = handlers.get(el);
      if (elHandlers === void 0) {
        handlers.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
      }
      let trapHandler = elHandlers.get(handler);
      if (trapHandler === void 0) {
        elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
      }
      return trapHandler;
    }
    function trapOn(name, el, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach((key) => {
          on(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function trapOff(name, el, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach((key) => {
          off(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function createDelegate() {
      if (typeof window === "undefined") {
        return {
          on: () => {
          },
          off: () => {
          }
        };
      }
      const propagationStopped = /* @__PURE__ */ new WeakMap();
      const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
      function trackPropagation() {
        propagationStopped.set(this, true);
      }
      function trackImmediate() {
        propagationStopped.set(this, true);
        immediatePropagationStopped.set(this, true);
      }
      function spy(event, propName, fn) {
        const source = event[propName];
        event[propName] = function() {
          fn.apply(event, arguments);
          return source.apply(event, arguments);
        };
        return event;
      }
      function unspy(event, propName) {
        event[propName] = Event.prototype[propName];
      }
      const currentTargets = /* @__PURE__ */ new WeakMap();
      const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
      function getCurrentTarget() {
        var _a;
        return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
      }
      function defineCurrentTarget(event, getter) {
        if (currentTargetDescriptor === void 0)
          return;
        Object.defineProperty(event, "currentTarget", {
          configurable: true,
          enumerable: true,
          get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
        });
      }
      const phaseToTypeToElToHandlers = {
        bubble: {},
        capture: {}
      };
      const typeToWindowEventHandlers = {};
      function createUnifiedHandler() {
        const delegeteHandler = function(e) {
          const { type: type2, eventPhase, bubbles } = e;
          const target = getEventTarget(e);
          if (eventPhase === 2)
            return;
          const phase = eventPhase === 1 ? "capture" : "bubble";
          let cursor = target;
          const path = [];
          while (true) {
            if (cursor === null)
              cursor = window;
            path.push(cursor);
            if (cursor === window) {
              break;
            }
            cursor = cursor.parentNode || null;
          }
          const captureElToHandlers = phaseToTypeToElToHandlers.capture[type2];
          const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type2];
          spy(e, "stopPropagation", trackPropagation);
          spy(e, "stopImmediatePropagation", trackImmediate);
          defineCurrentTarget(e, getCurrentTarget);
          if (phase === "capture") {
            if (captureElToHandlers === void 0)
              return;
            for (let i = path.length - 1; i >= 0; --i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = captureElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
              if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
                const bubbleHandlers = bubbleElToHandlers.get(target2);
                if (bubbleHandlers !== void 0) {
                  for (const handler of bubbleHandlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
              }
            }
          } else if (phase === "bubble") {
            if (bubbleElToHandlers === void 0)
              return;
            for (let i = 0; i < path.length; ++i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = bubbleElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
            }
          }
          unspy(e, "stopPropagation");
          unspy(e, "stopImmediatePropagation");
          defineCurrentTarget(e);
        };
        delegeteHandler.displayName = "evtdUnifiedHandler";
        return delegeteHandler;
      }
      function createUnifiedWindowEventHandler() {
        const delegateHandler = function(e) {
          const { type: type2, eventPhase } = e;
          if (eventPhase !== 2)
            return;
          const handlers = typeToWindowEventHandlers[type2];
          if (handlers === void 0)
            return;
          handlers.forEach((handler) => handler(e));
        };
        delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
        return delegateHandler;
      }
      const unifiedHandler = createUnifiedHandler();
      const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
      function ensureElToHandlers(phase, type2) {
        const phaseHandlers = phaseToTypeToElToHandlers[phase];
        if (phaseHandlers[type2] === void 0) {
          phaseHandlers[type2] = /* @__PURE__ */ new Map();
          window.addEventListener(type2, unifiedHandler, phase === "capture");
        }
        return phaseHandlers[type2];
      }
      function ensureWindowEventHandlers(type2) {
        const windowEventHandlers = typeToWindowEventHandlers[type2];
        if (windowEventHandlers === void 0) {
          typeToWindowEventHandlers[type2] = /* @__PURE__ */ new Set();
          window.addEventListener(type2, unfiendWindowEventHandler);
        }
        return typeToWindowEventHandlers[type2];
      }
      function ensureHandlers(elToHandlers, el) {
        let elHandlers = elToHandlers.get(el);
        if (elHandlers === void 0) {
          elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
        }
        return elHandlers;
      }
      function handlerExist(el, phase, type2, handler) {
        const elToHandlers = phaseToTypeToElToHandlers[phase][type2];
        if (elToHandlers !== void 0) {
          const handlers = elToHandlers.get(el);
          if (handlers !== void 0) {
            if (handlers.has(handler))
              return true;
          }
        }
        return false;
      }
      function windowEventHandlerExist(type2, handler) {
        const handlers = typeToWindowEventHandlers[type2];
        if (handlers !== void 0) {
          if (handlers.has(handler)) {
            return true;
          }
        }
        return false;
      }
      function on2(type2, el, handler, options) {
        let mergedHandler;
        if (typeof options === "object" && options.once === true) {
          mergedHandler = (e) => {
            off2(type2, el, mergedHandler, options);
            handler(e);
          };
        } else {
          mergedHandler = handler;
        }
        const trapped = trapOn(type2, el, mergedHandler, options);
        if (trapped)
          return;
        const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type2);
        const handlers = ensureHandlers(elToHandlers, el);
        if (!handlers.has(mergedHandler))
          handlers.add(mergedHandler);
        if (el === window) {
          const windowEventHandlers = ensureWindowEventHandlers(type2);
          if (!windowEventHandlers.has(mergedHandler)) {
            windowEventHandlers.add(mergedHandler);
          }
        }
      }
      function off2(type2, el, handler, options) {
        const trapped = trapOff(type2, el, handler, options);
        if (trapped)
          return;
        const capture = options === true || typeof options === "object" && options.capture === true;
        const phase = capture ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type2);
        const handlers = ensureHandlers(elToHandlers, el);
        if (el === window) {
          const mirrorPhase = capture ? "bubble" : "capture";
          if (!handlerExist(el, mirrorPhase, type2, handler) && windowEventHandlerExist(type2, handler)) {
            const windowEventHandlers = typeToWindowEventHandlers[type2];
            windowEventHandlers.delete(handler);
            if (windowEventHandlers.size === 0) {
              window.removeEventListener(type2, unfiendWindowEventHandler);
              typeToWindowEventHandlers[type2] = void 0;
            }
          }
        }
        if (handlers.has(handler))
          handlers.delete(handler);
        if (handlers.size === 0) {
          elToHandlers.delete(el);
        }
        if (elToHandlers.size === 0) {
          window.removeEventListener(type2, unifiedHandler, phase === "capture");
          phaseToTypeToElToHandlers[phase][type2] = void 0;
        }
      }
      return {
        on: on2,
        off: off2
      };
    }
    const { on, off } = createDelegate();
    function useMergedState(controlledStateRef, uncontrolledStateRef) {
      watch(controlledStateRef, (value) => {
        if (value !== void 0) {
          uncontrolledStateRef.value = value;
        }
      });
      return computed(() => {
        if (controlledStateRef.value === void 0) {
          return uncontrolledStateRef.value;
        }
        return controlledStateRef.value;
      });
    }
    function isMounted() {
      const isMounted2 = ref(false);
      onMounted(() => {
        isMounted2.value = true;
      });
      return readonly(isMounted2);
    }
    function useCompitable(reactive2, keys2) {
      return computed(() => {
        for (const key of keys2) {
          if (reactive2[key] !== void 0)
            return reactive2[key];
        }
        return reactive2[keys2[keys2.length - 1]];
      });
    }
    const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    !window.MSStream;
    function useIsIos() {
      return isIos;
    }
    function useKeyboard(options = {}, enabledRef) {
      const state = reactive({
        ctrl: false,
        command: false,
        win: false,
        shift: false,
        tab: false
      });
      const { keydown, keyup } = options;
      const keydownHandler = (e) => {
        switch (e.key) {
          case "Control":
            state.ctrl = true;
            break;
          case "Meta":
            state.command = true;
            state.win = true;
            break;
          case "Shift":
            state.shift = true;
            break;
          case "Tab":
            state.tab = true;
            break;
        }
        if (keydown !== void 0) {
          Object.keys(keydown).forEach((key) => {
            if (key !== e.key)
              return;
            const handler = keydown[key];
            if (typeof handler === "function") {
              handler(e);
            } else {
              const { stop = false, prevent = false } = handler;
              if (stop)
                e.stopPropagation();
              if (prevent)
                e.preventDefault();
              handler.handler(e);
            }
          });
        }
      };
      const keyupHandler = (e) => {
        switch (e.key) {
          case "Control":
            state.ctrl = false;
            break;
          case "Meta":
            state.command = false;
            state.win = false;
            break;
          case "Shift":
            state.shift = false;
            break;
          case "Tab":
            state.tab = false;
            break;
        }
        if (keyup !== void 0) {
          Object.keys(keyup).forEach((key) => {
            if (key !== e.key)
              return;
            const handler = keyup[key];
            if (typeof handler === "function") {
              handler(e);
            } else {
              const { stop = false, prevent = false } = handler;
              if (stop)
                e.stopPropagation();
              if (prevent)
                e.preventDefault();
              handler.handler(e);
            }
          });
        }
      };
      const setup2 = () => {
        if (enabledRef === void 0 || enabledRef.value) {
          on("keydown", document, keydownHandler);
          on("keyup", document, keyupHandler);
        }
        if (enabledRef !== void 0) {
          watch(enabledRef, (value) => {
            if (value) {
              on("keydown", document, keydownHandler);
              on("keyup", document, keyupHandler);
            } else {
              off("keydown", document, keydownHandler);
              off("keyup", document, keyupHandler);
            }
          });
        }
      };
      if (hasInstance()) {
        onBeforeMount(setup2);
        onBeforeUnmount(() => {
          if (enabledRef === void 0 || enabledRef.value) {
            off("keydown", document, keydownHandler);
            off("keyup", document, keyupHandler);
          }
        });
      } else {
        setup2();
      }
      return readonly(state);
    }
    const internalSelectionMenuInjectionKey = createInjectionKey("n-internal-select-menu");
    const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
    const modalBodyInjectionKey = createInjectionKey("n-modal-body");
    const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
    const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
    const teleportDisabled = "__disabled__";
    function useAdjustedTo(props) {
      const modal = inject(modalBodyInjectionKey, null);
      const drawer = inject(drawerBodyInjectionKey, null);
      const popover = inject(popoverBodyInjectionKey, null);
      const selectMenu = inject(internalSelectionMenuBodyInjectionKey, null);
      const fullscreenElementRef = ref();
      if (typeof document !== "undefined") {
        fullscreenElementRef.value = document.fullscreenElement;
        const handleFullscreenChange = () => {
          fullscreenElementRef.value = document.fullscreenElement;
        };
        onMounted(() => {
          on("fullscreenchange", document, handleFullscreenChange);
        });
        onBeforeUnmount(() => {
          off("fullscreenchange", document, handleFullscreenChange);
        });
      }
      return useMemo(() => {
        var _a;
        const { to } = props;
        if (to !== void 0) {
          if (to === false)
            return teleportDisabled;
          if (to === true)
            return fullscreenElementRef.value || "body";
          return to;
        }
        if (modal === null || modal === void 0 ? void 0 : modal.value) {
          return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
        }
        if (drawer === null || drawer === void 0 ? void 0 : drawer.value)
          return drawer.value;
        if (popover === null || popover === void 0 ? void 0 : popover.value)
          return popover.value;
        if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value)
          return selectMenu.value;
        return to !== null && to !== void 0 ? to : fullscreenElementRef.value || "body";
      });
    }
    useAdjustedTo.tdkey = teleportDisabled;
    useAdjustedTo.propTo = {
      type: [String, Object, Boolean],
      default: void 0
    };
    function getSlot(scope, slots, slotName = "default") {
      const slot = slots[slotName];
      if (slot === void 0) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      return slot();
    }
    function flatten$2(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
        if (vNode === null)
          return;
        if (typeof vNode !== "object") {
          if (typeof vNode === "string" || typeof vNode === "number") {
            result.push(createTextVNode(String(vNode)));
          }
          return;
        }
        if (Array.isArray(vNode)) {
          flatten$2(vNode, filterCommentNode, result);
          return;
        }
        if (vNode.type === Fragment) {
          if (vNode.children === null)
            return;
          if (Array.isArray(vNode.children)) {
            flatten$2(vNode.children, filterCommentNode, result);
          }
        } else if (vNode.type !== Comment) {
          result.push(vNode);
        }
      });
      return result;
    }
    function getFirstVNode(scope, slots, slotName = "default") {
      const slot = slots[slotName];
      if (slot === void 0) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      const content = flatten$2(slot());
      if (content.length === 1) {
        return content[0];
      } else {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
      }
    }
    let viewMeasurer = null;
    function ensureViewBoundingRect() {
      if (viewMeasurer === null) {
        viewMeasurer = document.getElementById("v-binder-view-measurer");
        if (viewMeasurer === null) {
          viewMeasurer = document.createElement("div");
          viewMeasurer.id = "v-binder-view-measurer";
          const { style: style2 } = viewMeasurer;
          style2.position = "fixed";
          style2.left = "0";
          style2.right = "0";
          style2.top = "0";
          style2.bottom = "0";
          style2.pointerEvents = "none";
          style2.visibility = "hidden";
          document.body.appendChild(viewMeasurer);
        }
      }
      return viewMeasurer.getBoundingClientRect();
    }
    function getPointRect(x, y) {
      const viewRect = ensureViewBoundingRect();
      return {
        top: y,
        left: x,
        height: 0,
        width: 0,
        right: viewRect.width - x,
        bottom: viewRect.height - y
      };
    }
    function getRect(el) {
      const elRect = el.getBoundingClientRect();
      const viewRect = ensureViewBoundingRect();
      return {
        left: elRect.left - viewRect.left,
        top: elRect.top - viewRect.top,
        bottom: viewRect.height + viewRect.top - elRect.bottom,
        right: viewRect.width + viewRect.left - elRect.right,
        width: elRect.width,
        height: elRect.height
      };
    }
    function getParentNode(node) {
      if (node.nodeType === 9) {
        return null;
      }
      return node.parentNode;
    }
    function getScrollParent(node) {
      if (node === null)
        return null;
      const parentNode = getParentNode(node);
      if (parentNode === null) {
        return null;
      }
      if (parentNode.nodeType === 9) {
        return document;
      }
      if (parentNode.nodeType === 1) {
        const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
          return parentNode;
        }
      }
      return getScrollParent(parentNode);
    }
    const Binder = defineComponent({
      name: "Binder",
      props: {
        syncTargetWithParent: Boolean,
        syncTarget: {
          type: Boolean,
          default: true
        }
      },
      setup(props) {
        var _a;
        provide("VBinder", (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
        const VBinder2 = inject("VBinder", null);
        const targetRef = ref(null);
        const setTargetRef = (el) => {
          targetRef.value = el;
          if (VBinder2 && props.syncTargetWithParent) {
            VBinder2.setTargetRef(el);
          }
        };
        let scrollableNodes = [];
        const ensureScrollListener = () => {
          let cursor = targetRef.value;
          while (true) {
            cursor = getScrollParent(cursor);
            if (cursor === null)
              break;
            scrollableNodes.push(cursor);
          }
          for (const el of scrollableNodes) {
            on("scroll", el, onScroll, true);
          }
        };
        const removeScrollListeners = () => {
          for (const el of scrollableNodes) {
            off("scroll", el, onScroll, true);
          }
          scrollableNodes = [];
        };
        const followerScrollListeners = /* @__PURE__ */ new Set();
        const addScrollListener = (listener) => {
          if (followerScrollListeners.size === 0) {
            ensureScrollListener();
          }
          if (!followerScrollListeners.has(listener)) {
            followerScrollListeners.add(listener);
          }
        };
        const removeScrollListener = (listener) => {
          if (followerScrollListeners.has(listener)) {
            followerScrollListeners.delete(listener);
          }
          if (followerScrollListeners.size === 0) {
            removeScrollListeners();
          }
        };
        const onScroll = () => {
          beforeNextFrameOnce(onScrollRaf);
        };
        const onScrollRaf = () => {
          followerScrollListeners.forEach((listener) => listener());
        };
        const followerResizeListeners = /* @__PURE__ */ new Set();
        const addResizeListener = (listener) => {
          if (followerResizeListeners.size === 0) {
            on("resize", window, onResize);
          }
          if (!followerResizeListeners.has(listener)) {
            followerResizeListeners.add(listener);
          }
        };
        const removeResizeListener = (listener) => {
          if (followerResizeListeners.has(listener)) {
            followerResizeListeners.delete(listener);
          }
          if (followerResizeListeners.size === 0) {
            off("resize", window, onResize);
          }
        };
        const onResize = () => {
          followerResizeListeners.forEach((listener) => listener());
        };
        onBeforeUnmount(() => {
          off("resize", window, onResize);
          removeScrollListeners();
        });
        return {
          targetRef,
          setTargetRef,
          addScrollListener,
          removeScrollListener,
          addResizeListener,
          removeResizeListener
        };
      },
      render() {
        return getSlot("binder", this.$slots);
      }
    });
    const VBinder = Binder;
    const VTarget = defineComponent({
      name: "Target",
      setup() {
        const { setTargetRef, syncTarget } = inject("VBinder");
        const setTargetDirective = {
          mounted: setTargetRef,
          updated: setTargetRef
        };
        return {
          syncTarget,
          setTargetDirective
        };
      },
      render() {
        const { syncTarget, setTargetDirective } = this;
        if (syncTarget) {
          return withDirectives(getFirstVNode("follower", this.$slots), [
            [setTargetDirective]
          ]);
        }
        return getFirstVNode("follower", this.$slots);
      }
    });
    const ctxKey$1 = "@@mmoContext";
    const mousemoveoutside = {
      mounted(el, { value }) {
        el[ctxKey$1] = {
          handler: void 0
        };
        if (typeof value === "function") {
          el[ctxKey$1].handler = value;
          on("mousemoveoutside", el, value);
        }
      },
      updated(el, { value }) {
        const ctx2 = el[ctxKey$1];
        if (typeof value === "function") {
          if (ctx2.handler) {
            if (ctx2.handler !== value) {
              off("mousemoveoutside", el, ctx2.handler);
              ctx2.handler = value;
              on("mousemoveoutside", el, value);
            }
          } else {
            el[ctxKey$1].handler = value;
            on("mousemoveoutside", el, value);
          }
        } else {
          if (ctx2.handler) {
            off("mousemoveoutside", el, ctx2.handler);
            ctx2.handler = void 0;
          }
        }
      },
      unmounted(el) {
        const { handler } = el[ctxKey$1];
        if (handler) {
          off("mousemoveoutside", el, handler);
        }
        el[ctxKey$1].handler = void 0;
      }
    };
    const mousemoveoutside$1 = mousemoveoutside;
    const ctxKey = "@@coContext";
    const clickoutside = {
      mounted(el, { value, modifiers }) {
        el[ctxKey] = {
          handler: void 0
        };
        if (typeof value === "function") {
          el[ctxKey].handler = value;
          on("clickoutside", el, value, {
            capture: modifiers.capture
          });
        }
      },
      updated(el, { value, modifiers }) {
        const ctx2 = el[ctxKey];
        if (typeof value === "function") {
          if (ctx2.handler) {
            if (ctx2.handler !== value) {
              off("clickoutside", el, ctx2.handler, {
                capture: modifiers.capture
              });
              ctx2.handler = value;
              on("clickoutside", el, value, {
                capture: modifiers.capture
              });
            }
          } else {
            el[ctxKey].handler = value;
            on("clickoutside", el, value, {
              capture: modifiers.capture
            });
          }
        } else {
          if (ctx2.handler) {
            off("clickoutside", el, ctx2.handler, {
              capture: modifiers.capture
            });
            ctx2.handler = void 0;
          }
        }
      },
      unmounted(el, { modifiers }) {
        const { handler } = el[ctxKey];
        if (handler) {
          off("clickoutside", el, handler, {
            capture: modifiers.capture
          });
        }
        el[ctxKey].handler = void 0;
      }
    };
    const clickoutside$1 = clickoutside;
    function warn$1(location, message) {
      console.error(`[vdirs/${location}]: ${message}`);
    }
    class ZIndexManager {
      constructor() {
        this.elementZIndex = /* @__PURE__ */ new Map();
        this.nextZIndex = 2e3;
      }
      get elementCount() {
        return this.elementZIndex.size;
      }
      ensureZIndex(el, zIndex) {
        const { elementZIndex } = this;
        if (zIndex !== void 0) {
          el.style.zIndex = `${zIndex}`;
          elementZIndex.delete(el);
          return;
        }
        const { nextZIndex } = this;
        if (elementZIndex.has(el)) {
          const currentZIndex = elementZIndex.get(el);
          if (currentZIndex + 1 === this.nextZIndex)
            return;
        }
        el.style.zIndex = `${nextZIndex}`;
        elementZIndex.set(el, nextZIndex);
        this.nextZIndex = nextZIndex + 1;
        this.squashState();
      }
      unregister(el, zIndex) {
        const { elementZIndex } = this;
        if (elementZIndex.has(el)) {
          elementZIndex.delete(el);
        } else if (zIndex === void 0) {
          warn$1("z-index-manager/unregister-element", "Element not found when unregistering.");
        }
        this.squashState();
      }
      squashState() {
        const { elementCount } = this;
        if (!elementCount) {
          this.nextZIndex = 2e3;
        }
        if (this.nextZIndex - elementCount > 2500)
          this.rearrange();
      }
      rearrange() {
        const elementZIndexPair = Array.from(this.elementZIndex.entries());
        elementZIndexPair.sort((pair1, pair2) => {
          return pair1[1] - pair2[1];
        });
        this.nextZIndex = 2e3;
        elementZIndexPair.forEach((pair) => {
          const el = pair[0];
          const zIndex = this.nextZIndex++;
          if (`${zIndex}` !== el.style.zIndex)
            el.style.zIndex = `${zIndex}`;
        });
      }
    }
    const zIndexManager = new ZIndexManager();
    const ctx = "@@ziContext";
    const zindexable = {
      mounted(el, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        el[ctx] = {
          enabled: !!enabled,
          initialized: false
        };
        if (enabled) {
          zIndexManager.ensureZIndex(el, zIndex);
          el[ctx].initialized = true;
        }
      },
      updated(el, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        const cachedEnabled = el[ctx].enabled;
        if (enabled && !cachedEnabled) {
          zIndexManager.ensureZIndex(el, zIndex);
          el[ctx].initialized = true;
        }
        el[ctx].enabled = !!enabled;
      },
      unmounted(el, bindings) {
        if (!el[ctx].initialized)
          return;
        const { value = {} } = bindings;
        const { zIndex } = value;
        zIndexManager.unregister(el, zIndex);
      }
    };
    const zindexable$1 = zindexable;
    const ssrContextKey = Symbol("@css-render/vue3-ssr");
    function createStyleString(id, style2) {
      return `<style cssr-id="${id}">
${style2}
</style>`;
    }
    function ssrAdapter(id, style2) {
      const ssrContext = inject(ssrContextKey, null);
      if (ssrContext === null) {
        console.error("[css-render/vue3-ssr]: no ssr context found.");
        return;
      }
      const { styles: styles2, ids } = ssrContext;
      if (ids.has(id))
        return;
      if (styles2 !== null) {
        ids.add(id);
        styles2.push(createStyleString(id, style2));
      }
    }
    const isBrowser = typeof document !== "undefined";
    function useSsrAdapter() {
      if (isBrowser)
        return void 0;
      const context = inject(ssrContextKey, null);
      if (context === null)
        return void 0;
      return {
        adapter: ssrAdapter,
        context
      };
    }
    function warn(location, message) {
      console.error(`[vueuc/${location}]: ${message}`);
    }
    const { c } = CssRender();
    const cssrAnchorMetaName$1 = "vueuc-style";
    function lowBit(n) {
      return n & -n;
    }
    class FinweckTree {
      /**
       * @param l length of the array
       * @param min min value of the array
       */
      constructor(l, min) {
        this.l = l;
        this.min = min;
        const ft = new Array(l + 1);
        for (let i = 0; i < l + 1; ++i) {
          ft[i] = 0;
        }
        this.ft = ft;
      }
      /**
       * Add arr[i] by n, start from 0
       * @param i the index of the element to be added
       * @param n the value to be added
       */
      add(i, n) {
        if (n === 0)
          return;
        const { l, ft } = this;
        i += 1;
        while (i <= l) {
          ft[i] += n;
          i += lowBit(i);
        }
      }
      /**
       * Get the value of index i
       * @param i index
       * @returns value of the index
       */
      get(i) {
        return this.sum(i + 1) - this.sum(i);
      }
      /**
       * Get the sum of first i elements
       * @param i count of head elements to be added
       * @returns the sum of first i elements
       */
      sum(i) {
        if (i === void 0)
          i = this.l;
        if (i <= 0)
          return 0;
        const { ft, min, l } = this;
        if (i > l)
          throw new Error("[FinweckTree.sum]: `i` is larger than length.");
        let ret = i * min;
        while (i > 0) {
          ret += ft[i];
          i -= lowBit(i);
        }
        return ret;
      }
      /**
       * Get the largest count of head elements whose sum are <= threshold
       * @param threshold
       * @returns the largest count of head elements whose sum are <= threshold
       */
      getBound(threshold) {
        let l = 0;
        let r = this.l;
        while (r > l) {
          const m = Math.floor((l + r) / 2);
          const sumM = this.sum(m);
          if (sumM > threshold) {
            r = m;
            continue;
          } else if (sumM < threshold) {
            if (l === m) {
              if (this.sum(l + 1) <= threshold)
                return l + 1;
              return m;
            }
            l = m;
          } else {
            return m;
          }
        }
        return l;
      }
    }
    function resolveTo(selector) {
      if (typeof selector === "string") {
        return document.querySelector(selector);
      }
      return selector();
    }
    const LazyTeleport = defineComponent({
      name: "LazyTeleport",
      props: {
        to: {
          type: [String, Object],
          default: void 0
        },
        disabled: Boolean,
        show: {
          type: Boolean,
          required: true
        }
      },
      setup(props) {
        return {
          showTeleport: useFalseUntilTruthy(toRef(props, "show")),
          mergedTo: computed(() => {
            const { to } = props;
            return to !== null && to !== void 0 ? to : "body";
          })
        };
      },
      render() {
        return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : h(Teleport, {
          disabled: this.disabled,
          to: this.mergedTo
        }, getSlot("lazy-teleport", this.$slots)) : null;
      }
    });
    const oppositionPositions = {
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    };
    const oppositeAligns = {
      start: "end",
      center: "center",
      end: "start"
    };
    const propToCompare = {
      top: "height",
      bottom: "height",
      left: "width",
      right: "width"
    };
    const transformOrigins = {
      "bottom-start": "top left",
      bottom: "top center",
      "bottom-end": "top right",
      "top-start": "bottom left",
      top: "bottom center",
      "top-end": "bottom right",
      "right-start": "top left",
      right: "center left",
      "right-end": "bottom left",
      "left-start": "top right",
      left: "center right",
      "left-end": "bottom right"
    };
    const overlapTransformOrigin = {
      "bottom-start": "bottom left",
      bottom: "bottom center",
      "bottom-end": "bottom right",
      "top-start": "top left",
      top: "top center",
      "top-end": "top right",
      "right-start": "top right",
      right: "center right",
      "right-end": "bottom right",
      "left-start": "top left",
      left: "center left",
      "left-end": "bottom left"
    };
    const oppositeAlignCssPositionProps = {
      "bottom-start": "right",
      "bottom-end": "left",
      "top-start": "right",
      "top-end": "left",
      "right-start": "bottom",
      "right-end": "top",
      "left-start": "bottom",
      "left-end": "top"
    };
    const keepOffsetDirection = {
      top: true,
      bottom: false,
      left: true,
      right: false
      // left--
    };
    const cssPositionToOppositeAlign = {
      top: "end",
      bottom: "start",
      left: "end",
      right: "start"
    };
    function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
      if (!flip || overlap) {
        return { placement, top: 0, left: 0 };
      }
      const [position, align] = placement.split("-");
      let properAlign = align !== null && align !== void 0 ? align : "center";
      let properOffset = {
        top: 0,
        left: 0
      };
      const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
        let left = 0;
        let top = 0;
        const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
        if (diff > 0 && shift) {
          if (offsetVertically2) {
            top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
          } else {
            left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
          }
        }
        return {
          left,
          top
        };
      };
      const offsetVertically = position === "left" || position === "right";
      if (properAlign !== "center") {
        const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
        const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
        const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
        if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
          if (
            // current space is not enough
            // ----------[ target ]---------|
            // -------[     follower        ]
            targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
          ) {
            const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
            if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
              if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
                properAlign = oppositeAligns[align];
                properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
              } else {
                properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
              }
            } else {
              properAlign = "center";
            }
          }
        } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
          if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
          // ------------[   target   ]
          // ----------------[follower]
          targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
            properAlign = oppositeAligns[align];
          }
        }
      } else {
        const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
        const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
        const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
        const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
        if (
          // center is not enough
          // ----------- [ target ]--|
          // -------[     follower     ]
          targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
        ) {
          if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
            properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
            properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
          } else {
            properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
            properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
          }
        }
      }
      let properPosition = position;
      if (
        // space is not enough
        targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
        targetRect[position] < targetRect[oppositionPositions[position]]
      ) {
        properPosition = oppositionPositions[position];
      }
      return {
        placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
        left: properOffset.left,
        top: properOffset.top
      };
    }
    function getProperTransformOrigin(placement, overlap) {
      if (overlap)
        return overlapTransformOrigin[placement];
      return transformOrigins[placement];
    }
    function getOffset(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
      if (overlap) {
        switch (placement) {
          case "bottom-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: "translateY(-100%)"
            };
          case "bottom-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: "translateX(-100%) translateY(-100%)"
            };
          case "top-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: ""
            };
          case "top-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: "translateX(-100%)"
            };
          case "right-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: "translateX(-100%)"
            };
          case "right-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: "translateX(-100%) translateY(-100%)"
            };
          case "left-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: ""
            };
          case "left-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: "translateY(-100%)"
            };
          case "top":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
              transform: "translateX(-50%)"
            };
          case "right":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: "translateX(-100%) translateY(-50%)"
            };
          case "left":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: "translateY(-50%)"
            };
          case "bottom":
          default:
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
              transform: "translateX(-50%) translateY(-100%)"
            };
        }
      }
      switch (placement) {
        case "bottom-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: ""
          };
        case "bottom-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: "translateX(-100%)"
          };
        case "top-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: "translateY(-100%)"
          };
        case "top-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "right-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: ""
          };
        case "right-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: "translateY(-100%)"
          };
        case "left-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: "translateX(-100%)"
          };
        case "left-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "top":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
            transform: "translateY(-100%) translateX(-50%)"
          };
        case "right":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: "translateY(-50%)"
          };
        case "left":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: "translateY(-50%) translateX(-100%)"
          };
        case "bottom":
        default:
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
            transform: "translateX(-50%)"
          };
      }
    }
    const style$u = c([
      c(".v-binder-follower-container", {
        position: "absolute",
        left: "0",
        right: "0",
        top: "0",
        height: "0",
        pointerEvents: "none",
        zIndex: "auto"
      }),
      c(".v-binder-follower-content", {
        position: "absolute",
        zIndex: "auto"
      }, [
        c("> *", {
          pointerEvents: "all"
        })
      ])
    ]);
    const VFollower = defineComponent({
      name: "Follower",
      inheritAttrs: false,
      props: {
        show: Boolean,
        enabled: {
          type: Boolean,
          default: void 0
        },
        placement: {
          type: String,
          default: "bottom"
        },
        syncTrigger: {
          type: Array,
          default: ["resize", "scroll"]
        },
        to: [String, Object],
        flip: {
          type: Boolean,
          default: true
        },
        internalShift: Boolean,
        x: Number,
        y: Number,
        width: String,
        minWidth: String,
        containerClass: String,
        teleportDisabled: Boolean,
        zindexable: {
          type: Boolean,
          default: true
        },
        zIndex: Number,
        overlap: Boolean
      },
      setup(props) {
        const VBinder2 = inject("VBinder");
        const mergedEnabledRef = useMemo(() => {
          return props.enabled !== void 0 ? props.enabled : props.show;
        });
        const followerRef = ref(null);
        const offsetContainerRef = ref(null);
        const ensureListeners = () => {
          const { syncTrigger } = props;
          if (syncTrigger.includes("scroll")) {
            VBinder2.addScrollListener(syncPosition);
          }
          if (syncTrigger.includes("resize")) {
            VBinder2.addResizeListener(syncPosition);
          }
        };
        const removeListeners = () => {
          VBinder2.removeScrollListener(syncPosition);
          VBinder2.removeResizeListener(syncPosition);
        };
        onMounted(() => {
          if (mergedEnabledRef.value) {
            syncPosition();
            ensureListeners();
          }
        });
        const ssrAdapter2 = useSsrAdapter();
        style$u.mount({
          id: "vueuc/binder",
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter2
        });
        onBeforeUnmount(() => {
          removeListeners();
        });
        onFontsReady(() => {
          if (mergedEnabledRef.value) {
            syncPosition();
          }
        });
        const syncPosition = () => {
          if (!mergedEnabledRef.value) {
            return;
          }
          const follower = followerRef.value;
          if (follower === null)
            return;
          const target = VBinder2.targetRef;
          const { x, y, overlap } = props;
          const targetRect = x !== void 0 && y !== void 0 ? getPointRect(x, y) : getRect(target);
          follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
          follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
          const { width, minWidth, placement, internalShift, flip } = props;
          follower.setAttribute("v-placement", placement);
          if (overlap) {
            follower.setAttribute("v-overlap", "");
          } else {
            follower.removeAttribute("v-overlap");
          }
          const { style: style2 } = follower;
          if (width === "target") {
            style2.width = `${targetRect.width}px`;
          } else if (width !== void 0) {
            style2.width = width;
          } else {
            style2.width = "";
          }
          if (minWidth === "target") {
            style2.minWidth = `${targetRect.width}px`;
          } else if (minWidth !== void 0) {
            style2.minWidth = minWidth;
          } else {
            style2.minWidth = "";
          }
          const followerRect = getRect(follower);
          const offsetContainerRect = getRect(offsetContainerRef.value);
          const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
          const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
          const { left, top, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
          follower.setAttribute("v-placement", properPlacement);
          follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
          follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
          follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
          follower.style.setProperty("--v-transform-origin", properTransformOrigin);
          follower.style.transformOrigin = properTransformOrigin;
        };
        watch(mergedEnabledRef, (value) => {
          if (value) {
            ensureListeners();
            syncOnNextTick();
          } else {
            removeListeners();
          }
        });
        const syncOnNextTick = () => {
          nextTick().then(syncPosition).catch((e) => console.error(e));
        };
        [
          "placement",
          "x",
          "y",
          "internalShift",
          "flip",
          "width",
          "overlap",
          "minWidth"
        ].forEach((prop) => {
          watch(toRef(props, prop), syncPosition);
        });
        ["teleportDisabled"].forEach((prop) => {
          watch(toRef(props, prop), syncOnNextTick);
        });
        watch(toRef(props, "syncTrigger"), (value) => {
          if (!value.includes("resize")) {
            VBinder2.removeResizeListener(syncPosition);
          } else {
            VBinder2.addResizeListener(syncPosition);
          }
          if (!value.includes("scroll")) {
            VBinder2.removeScrollListener(syncPosition);
          } else {
            VBinder2.addScrollListener(syncPosition);
          }
        });
        const isMountedRef = isMounted();
        const mergedToRef = useMemo(() => {
          const { to } = props;
          if (to !== void 0)
            return to;
          if (isMountedRef.value) {
            return void 0;
          }
          return void 0;
        });
        return {
          VBinder: VBinder2,
          mergedEnabled: mergedEnabledRef,
          offsetContainerRef,
          followerRef,
          mergedTo: mergedToRef,
          syncPosition
        };
      },
      render() {
        return h(LazyTeleport, {
          show: this.show,
          to: this.mergedTo,
          disabled: this.teleportDisabled
        }, {
          default: () => {
            var _a, _b;
            const vNode = h("div", {
              class: ["v-binder-follower-container", this.containerClass],
              ref: "offsetContainerRef"
            }, [
              h("div", {
                class: "v-binder-follower-content",
                ref: "followerRef"
              }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
            ]);
            if (this.zindexable) {
              return withDirectives(vNode, [
                [
                  zindexable$1,
                  {
                    enabled: this.mergedEnabled,
                    zIndex: this.zIndex
                  }
                ]
              ]);
            }
            return vNode;
          }
        });
      }
    });
    var resizeObservers = [];
    var hasActiveObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.activeTargets.length > 0;
      });
    };
    var hasSkippedObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.skippedTargets.length > 0;
      });
    };
    var msg = "ResizeObserver loop completed with undelivered notifications.";
    var deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
    var ResizeObserverBoxOptions;
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
    var freeze = function(obj) {
      return Object.freeze(obj);
    };
    var ResizeObserverSize = function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
    var DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
    var isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    var isHidden = function(target) {
      if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
      }
      var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    var isElement = function(obj) {
      var _a;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    var isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
    var global$1 = typeof window !== "undefined" ? window : {};
    var cache = /* @__PURE__ */ new WeakMap();
    var scrollRegexp = /auto|scroll/;
    var verticalRegexp = /^tb|vertical/;
    var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
    var parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    var size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    var zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    var calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE && cs.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    var calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
    var ResizeObserverEntry = function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
    var calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
    var broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
      });
      for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
      }
      return shallowestDepth;
    };
    var gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro.activeTargets.push(ot);
            } else {
              ro.skippedTargets.push(ot);
            }
          }
        });
      });
    };
    var process$1 = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
    var trigger;
    var callbacks = [];
    var notify = function() {
      return callbacks.splice(0).forEach(function(cb) {
        return cb();
      });
    };
    var queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
    var queueResizeObserver = function(cb) {
      queueMicroTask(function ResizeObserver2() {
        requestAnimationFrame(cb);
      });
    };
    var watching = 0;
    var isWatching = function() {
      return !!watching;
    };
    var CATCH_PERIOD = 250;
    var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    var events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    var time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    var scheduled = false;
    var Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process$1();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global$1.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global$1.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    var scheduler = new Scheduler();
    var updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
    var skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    var ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
    var ResizeObserverDetail = function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
    var observerMap = /* @__PURE__ */ new WeakMap();
    var getObservationIndex = function(observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }
      return -1;
    };
    var ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
    var ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver2.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver2.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver2.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver2.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver2;
    }();
    class ResizeObserverDelegate {
      constructor() {
        this.handleResize = this.handleResize.bind(this);
        this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
        this.elHandlersMap = /* @__PURE__ */ new Map();
      }
      handleResize(entries) {
        for (const entry of entries) {
          const handler = this.elHandlersMap.get(entry.target);
          if (handler !== void 0) {
            handler(entry);
          }
        }
      }
      registerHandler(el, handler) {
        this.elHandlersMap.set(el, handler);
        this.observer.observe(el);
      }
      unregisterHandler(el) {
        if (!this.elHandlersMap.has(el)) {
          return;
        }
        this.elHandlersMap.delete(el);
        this.observer.unobserve(el);
      }
    }
    const resizeObserverManager = new ResizeObserverDelegate();
    const VResizeObserver = defineComponent({
      name: "ResizeObserver",
      props: {
        onResize: Function
      },
      setup(props) {
        let registered = false;
        const proxy = getCurrentInstance().proxy;
        function handleResize(entry) {
          const { onResize } = props;
          if (onResize !== void 0)
            onResize(entry);
        }
        onMounted(() => {
          const el = proxy.$el;
          if (el === void 0) {
            warn("resize-observer", "$el does not exist.");
            return;
          }
          if (el.nextElementSibling !== el.nextSibling) {
            if (el.nodeType === 3 && el.nodeValue !== "") {
              warn("resize-observer", "$el can not be observed (it may be a text node).");
              return;
            }
          }
          if (el.nextElementSibling !== null) {
            resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
            registered = true;
          }
        });
        onBeforeUnmount(() => {
          if (registered) {
            resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
          }
        });
      },
      render() {
        return renderSlot(this.$slots, "default");
      }
    });
    let maybeTouch;
    function ensureMaybeTouch() {
      if (maybeTouch === void 0) {
        if ("matchMedia" in window) {
          maybeTouch = window.matchMedia("(pointer:coarse)").matches;
        } else {
          maybeTouch = false;
        }
      }
      return maybeTouch;
    }
    let wheelScale;
    function ensureWheelScale() {
      if (wheelScale === void 0) {
        wheelScale = "chrome" in window ? window.devicePixelRatio : 1;
      }
      return wheelScale;
    }
    const styles$1 = c(".v-vl", {
      maxHeight: "inherit",
      height: "100%",
      overflow: "auto",
      minWidth: "1px"
      // a zero width container won't be scrollable
    }, [
      c("&:not(.v-vl--show-scrollbar)", {
        scrollbarWidth: "none"
      }, [
        c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", {
          width: 0,
          height: 0,
          display: "none"
        })
      ])
    ]);
    const VVirtualList = defineComponent({
      name: "VirtualList",
      inheritAttrs: false,
      props: {
        showScrollbar: {
          type: Boolean,
          default: true
        },
        items: {
          type: Array,
          default: () => []
        },
        // it is suppose to be the min height
        itemSize: {
          type: Number,
          required: true
        },
        itemResizable: Boolean,
        itemsStyle: [String, Object],
        visibleItemsTag: {
          type: [String, Object],
          default: "div"
        },
        visibleItemsProps: Object,
        ignoreItemResize: Boolean,
        onScroll: Function,
        onWheel: Function,
        onResize: Function,
        defaultScrollKey: [Number, String],
        defaultScrollIndex: Number,
        keyField: {
          type: String,
          default: "key"
        },
        // Whether it is a good API?
        // ResizeObserver + footer & header is not enough.
        // Too complex for simple case
        paddingTop: {
          type: [Number, String],
          default: 0
        },
        paddingBottom: {
          type: [Number, String],
          default: 0
        }
      },
      setup(props) {
        const ssrAdapter2 = useSsrAdapter();
        styles$1.mount({
          id: "vueuc/virtual-list",
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter2
        });
        onMounted(() => {
          const { defaultScrollIndex, defaultScrollKey } = props;
          if (defaultScrollIndex !== void 0 && defaultScrollIndex !== null) {
            scrollTo({ index: defaultScrollIndex });
          } else if (defaultScrollKey !== void 0 && defaultScrollKey !== null) {
            scrollTo({ key: defaultScrollKey });
          }
        });
        let isDeactivated = false;
        let activateStateInitialized = false;
        onActivated(() => {
          isDeactivated = false;
          if (!activateStateInitialized) {
            activateStateInitialized = true;
            return;
          }
          scrollTo({ top: scrollTopRef.value, left: scrollLeft });
        });
        onDeactivated(() => {
          isDeactivated = true;
          if (!activateStateInitialized) {
            activateStateInitialized = true;
          }
        });
        const keyIndexMapRef = computed(() => {
          const map2 = /* @__PURE__ */ new Map();
          const { keyField } = props;
          props.items.forEach((item, index) => {
            map2.set(item[keyField], index);
          });
          return map2;
        });
        const listElRef = ref(null);
        const listHeightRef = ref(void 0);
        const keyToHeightOffset = /* @__PURE__ */ new Map();
        const finweckTreeRef = computed(() => {
          const { items, itemSize, keyField } = props;
          const ft = new FinweckTree(items.length, itemSize);
          items.forEach((item, index) => {
            const key = item[keyField];
            const heightOffset = keyToHeightOffset.get(key);
            if (heightOffset !== void 0) {
              ft.add(index, heightOffset);
            }
          });
          return ft;
        });
        const finweckTreeUpdateTrigger = ref(0);
        let scrollLeft = 0;
        const scrollTopRef = ref(0);
        const startIndexRef = useMemo(() => {
          return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);
        });
        const viewportItemsRef = computed(() => {
          const { value: listHeight } = listHeightRef;
          if (listHeight === void 0)
            return [];
          const { items, itemSize } = props;
          const startIndex = startIndexRef.value;
          const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);
          const viewportItems = [];
          for (let i = startIndex; i <= endIndex; ++i) {
            viewportItems.push(items[i]);
          }
          return viewportItems;
        });
        const scrollTo = (options, y) => {
          if (typeof options === "number") {
            scrollToPosition(options, y, "auto");
            return;
          }
          const { left, top, index, key, position, behavior, debounce: debounce2 = true } = options;
          if (left !== void 0 || top !== void 0) {
            scrollToPosition(left, top, behavior);
          } else if (index !== void 0) {
            scrollToIndex(index, behavior, debounce2);
          } else if (key !== void 0) {
            const toIndex = keyIndexMapRef.value.get(key);
            if (toIndex !== void 0)
              scrollToIndex(toIndex, behavior, debounce2);
          } else if (position === "bottom") {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);
          } else if (position === "top") {
            scrollToPosition(0, 0, behavior);
          }
        };
        let anchorIndex;
        let anchorTimerId = null;
        function scrollToIndex(index, behavior, debounce2) {
          const { value: ft } = finweckTreeRef;
          const targetTop = ft.sum(index) + depx(props.paddingTop);
          if (!debounce2) {
            listElRef.value.scrollTo({
              left: 0,
              top: targetTop,
              behavior
            });
          } else {
            anchorIndex = index;
            if (anchorTimerId !== null) {
              window.clearTimeout(anchorTimerId);
            }
            anchorTimerId = window.setTimeout(() => {
              anchorIndex = void 0;
              anchorTimerId = null;
            }, 16);
            const { scrollTop, offsetHeight } = listElRef.value;
            if (targetTop > scrollTop) {
              const itemSize = ft.get(index);
              if (targetTop + itemSize <= scrollTop + offsetHeight)
                ;
              else {
                listElRef.value.scrollTo({
                  left: 0,
                  top: targetTop + itemSize - offsetHeight,
                  behavior
                });
              }
            } else {
              listElRef.value.scrollTo({
                left: 0,
                top: targetTop,
                behavior
              });
            }
          }
        }
        function scrollToPosition(left, top, behavior) {
          listElRef.value.scrollTo({
            left,
            top,
            behavior
          });
        }
        function handleItemResize(key, entry) {
          var _a, _b, _c;
          if (isDeactivated)
            return;
          if (props.ignoreItemResize)
            return;
          if (isHideByVShow(entry.target))
            return;
          const { value: ft } = finweckTreeRef;
          const index = keyIndexMapRef.value.get(key);
          const previousHeight = ft.get(index);
          const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;
          if (height === previousHeight)
            return;
          const offset = height - props.itemSize;
          if (offset === 0) {
            keyToHeightOffset.delete(key);
          } else {
            keyToHeightOffset.set(key, height - props.itemSize);
          }
          const delta = height - previousHeight;
          if (delta === 0)
            return;
          ft.add(index, delta);
          const listEl = listElRef.value;
          if (listEl != null) {
            if (anchorIndex === void 0) {
              const previousHeightSum = ft.sum(index);
              if (listEl.scrollTop > previousHeightSum) {
                listEl.scrollBy(0, delta);
              }
            } else {
              if (index < anchorIndex) {
                listEl.scrollBy(0, delta);
              } else if (index === anchorIndex) {
                const previousHeightSum = ft.sum(index);
                if (height + previousHeightSum > // Note, listEl shouldn't have border, nor offsetHeight won't be
                // correct
                listEl.scrollTop + listEl.offsetHeight) {
                  listEl.scrollBy(0, delta);
                }
              }
            }
            syncViewport();
          }
          finweckTreeUpdateTrigger.value++;
        }
        const mayUseWheel = !ensureMaybeTouch();
        let wheelCatched = false;
        function handleListScroll(e) {
          var _a;
          (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
          if (!mayUseWheel || !wheelCatched) {
            syncViewport();
          }
        }
        function handleListWheel(e) {
          var _a;
          (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);
          if (mayUseWheel) {
            const listEl = listElRef.value;
            if (listEl != null) {
              if (e.deltaX === 0) {
                if (listEl.scrollTop === 0 && e.deltaY <= 0) {
                  return;
                }
                if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight && e.deltaY >= 0) {
                  return;
                }
              }
              e.preventDefault();
              listEl.scrollTop += e.deltaY / ensureWheelScale();
              listEl.scrollLeft += e.deltaX / ensureWheelScale();
              syncViewport();
              wheelCatched = true;
              beforeNextFrameOnce(() => {
                wheelCatched = false;
              });
            }
          }
        }
        function handleListResize(entry) {
          if (isDeactivated)
            return;
          if (isHideByVShow(entry.target))
            return;
          if (entry.contentRect.height === listHeightRef.value)
            return;
          listHeightRef.value = entry.contentRect.height;
          const { onResize } = props;
          if (onResize !== void 0)
            onResize(entry);
        }
        function syncViewport() {
          const { value: listEl } = listElRef;
          if (listEl == null)
            return;
          scrollTopRef.value = listEl.scrollTop;
          scrollLeft = listEl.scrollLeft;
        }
        function isHideByVShow(el) {
          let cursor = el;
          while (cursor !== null) {
            if (cursor.style.display === "none")
              return true;
            cursor = cursor.parentElement;
          }
          return false;
        }
        return {
          listHeight: listHeightRef,
          listStyle: {
            overflow: "auto"
          },
          keyToIndex: keyIndexMapRef,
          itemsStyle: computed(() => {
            const { itemResizable } = props;
            const height = pxfy(finweckTreeRef.value.sum());
            finweckTreeUpdateTrigger.value;
            return [
              props.itemsStyle,
              {
                boxSizing: "content-box",
                height: itemResizable ? "" : height,
                minHeight: itemResizable ? height : "",
                paddingTop: pxfy(props.paddingTop),
                paddingBottom: pxfy(props.paddingBottom)
              }
            ];
          }),
          visibleItemsStyle: computed(() => {
            finweckTreeUpdateTrigger.value;
            return {
              transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`
            };
          }),
          viewportItems: viewportItemsRef,
          listElRef,
          itemsElRef: ref(null),
          scrollTo,
          handleListResize,
          handleListScroll,
          handleListWheel,
          handleItemResize
        };
      },
      render() {
        const { itemResizable, keyField, keyToIndex, visibleItemsTag } = this;
        return h(VResizeObserver, {
          onResize: this.handleListResize
        }, {
          default: () => {
            var _a, _b;
            return h("div", mergeProps(this.$attrs, {
              class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"],
              onScroll: this.handleListScroll,
              onWheel: this.handleListWheel,
              ref: "listElRef"
            }), [
              this.items.length !== 0 ? h("div", {
                ref: "itemsElRef",
                class: "v-vl-items",
                style: this.itemsStyle
              }, [
                h(visibleItemsTag, Object.assign({
                  class: "v-vl-visible-items",
                  style: this.visibleItemsStyle
                }, this.visibleItemsProps), {
                  default: () => this.viewportItems.map((item) => {
                    const key = item[keyField];
                    const index = keyToIndex.get(key);
                    const itemVNode = this.$slots.default({
                      item,
                      index
                    })[0];
                    if (itemResizable) {
                      return h(VResizeObserver, {
                        key,
                        onResize: (entry) => this.handleItemResize(key, entry)
                      }, {
                        default: () => itemVNode
                      });
                    }
                    itemVNode.key = key;
                    return itemVNode;
                  })
                })
              ]) : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)
            ]);
          }
        });
      }
    });
    const styles = c(".v-x-scroll", {
      overflow: "auto",
      scrollbarWidth: "none"
    }, [
      c("&::-webkit-scrollbar", {
        width: 0,
        height: 0
      })
    ]);
    const VXScroll = defineComponent({
      name: "XScroll",
      props: {
        disabled: Boolean,
        onScroll: Function
      },
      setup() {
        const selfRef = ref(null);
        function handleWheel(e) {
          const preventYWheel = e.currentTarget.offsetWidth < e.currentTarget.scrollWidth;
          if (!preventYWheel || e.deltaY === 0)
            return;
          e.currentTarget.scrollLeft += e.deltaY + e.deltaX;
          e.preventDefault();
        }
        const ssrAdapter2 = useSsrAdapter();
        styles.mount({
          id: "vueuc/x-scroll",
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter2
        });
        const exposedMethods = {
          scrollTo(...args) {
            var _a;
            (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(...args);
          }
        };
        return Object.assign({
          selfRef,
          handleWheel
        }, exposedMethods);
      },
      render() {
        return h("div", {
          ref: "selfRef",
          onScroll: this.onScroll,
          onWheel: this.disabled ? void 0 : this.handleWheel,
          class: "v-x-scroll"
        }, this.$slots);
      }
    });
    const hiddenAttr = "v-hidden";
    const style$t = c("[v-hidden]", {
      display: "none!important"
    });
    const VOverflow = defineComponent({
      name: "Overflow",
      props: {
        getCounter: Function,
        getTail: Function,
        updateCounter: Function,
        onUpdateOverflow: Function
      },
      setup(props, { slots }) {
        const selfRef = ref(null);
        const counterRef = ref(null);
        function deriveCounter() {
          const { value: self2 } = selfRef;
          const { getCounter, getTail } = props;
          let counter;
          if (getCounter !== void 0)
            counter = getCounter();
          else {
            counter = counterRef.value;
          }
          if (!self2 || !counter)
            return;
          if (counter.hasAttribute(hiddenAttr)) {
            counter.removeAttribute(hiddenAttr);
          }
          const { children } = self2;
          const containerWidth = self2.offsetWidth;
          const childWidths = [];
          const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;
          let childWidthSum = tail ? tail.offsetWidth : 0;
          let overflow = false;
          const len2 = self2.children.length - (slots.tail ? 1 : 0);
          for (let i = 0; i < len2 - 1; ++i) {
            if (i < 0)
              continue;
            const child = children[i];
            if (overflow) {
              if (!child.hasAttribute(hiddenAttr)) {
                child.setAttribute(hiddenAttr, "");
              }
              continue;
            } else if (child.hasAttribute(hiddenAttr)) {
              child.removeAttribute(hiddenAttr);
            }
            const childWidth = child.offsetWidth;
            childWidthSum += childWidth;
            childWidths[i] = childWidth;
            if (childWidthSum > containerWidth) {
              const { updateCounter } = props;
              for (let j = i; j >= 0; --j) {
                const restCount = len2 - 1 - j;
                if (updateCounter !== void 0) {
                  updateCounter(restCount);
                } else {
                  counter.textContent = `${restCount}`;
                }
                const counterWidth = counter.offsetWidth;
                childWidthSum -= childWidths[j];
                if (childWidthSum + counterWidth <= containerWidth || j === 0) {
                  overflow = true;
                  i = j - 1;
                  if (tail) {
                    if (i === -1) {
                      tail.style.maxWidth = `${containerWidth - counterWidth}px`;
                      tail.style.boxSizing = "border-box";
                    } else {
                      tail.style.maxWidth = "";
                    }
                  }
                  break;
                }
              }
            }
          }
          const { onUpdateOverflow } = props;
          if (!overflow) {
            if (onUpdateOverflow !== void 0) {
              onUpdateOverflow(false);
            }
            counter.setAttribute(hiddenAttr, "");
          } else {
            if (onUpdateOverflow !== void 0) {
              onUpdateOverflow(true);
            }
          }
        }
        const ssrAdapter2 = useSsrAdapter();
        style$t.mount({
          id: "vueuc/overflow",
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter2
        });
        onMounted(deriveCounter);
        return {
          selfRef,
          counterRef,
          sync: deriveCounter
        };
      },
      render() {
        const { $slots } = this;
        nextTick(this.sync);
        return h("div", {
          class: "v-overflow",
          ref: "selfRef"
        }, [
          renderSlot($slots, "default"),
          // $slots.counter should only has 1 element
          $slots.counter ? $slots.counter() : h("span", {
            style: {
              display: "inline-block"
            },
            ref: "counterRef"
          }),
          // $slots.tail should only has 1 element
          $slots.tail ? $slots.tail() : null
        ]);
      }
    });
    function isHTMLElement(node) {
      return node instanceof HTMLElement;
    }
    function focusFirstDescendant(node) {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusFirstDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function focusLastDescendant(element) {
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
        const child = element.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusLastDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function attemptFocus(element) {
      if (!isFocusable(element)) {
        return false;
      }
      try {
        element.focus({ preventScroll: true });
      } catch (e) {
      }
      return document.activeElement === element;
    }
    function isFocusable(element) {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
        return true;
      }
      if (element.getAttribute("disabled")) {
        return false;
      }
      switch (element.nodeName) {
        case "A":
          return !!element.href && element.rel !== "ignore";
        case "INPUT":
          return element.type !== "hidden" && element.type !== "file";
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA":
          return true;
        default:
          return false;
      }
    }
    let stack = [];
    const FocusTrap = defineComponent({
      name: "FocusTrap",
      props: {
        disabled: Boolean,
        active: Boolean,
        autoFocus: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        initialFocusTo: String,
        finalFocusTo: String,
        returnFocusOnDeactivated: {
          type: Boolean,
          default: true
        }
      },
      setup(props) {
        const id = createId();
        const focusableStartRef = ref(null);
        const focusableEndRef = ref(null);
        let activated = false;
        let ignoreInternalFocusChange = false;
        const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
        function isCurrentActive() {
          const currentActiveId = stack[stack.length - 1];
          return currentActiveId === id;
        }
        function handleDocumentKeydown(e) {
          var _a;
          if (e.code === "Escape") {
            if (isCurrentActive()) {
              (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
            }
          }
        }
        onMounted(() => {
          watch(() => props.active, (value) => {
            if (value) {
              activate();
              on("keydown", document, handleDocumentKeydown);
            } else {
              off("keydown", document, handleDocumentKeydown);
              if (activated) {
                deactivate();
              }
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          off("keydown", document, handleDocumentKeydown);
          if (activated)
            deactivate();
        });
        function handleDocumentFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (isCurrentActive()) {
            const mainEl = getMainEl();
            if (mainEl === null)
              return;
            if (mainEl.contains(getPreciseEventTarget(e)))
              return;
            resetFocusTo("first");
          }
        }
        function getMainEl() {
          const focusableStartEl = focusableStartRef.value;
          if (focusableStartEl === null)
            return null;
          let mainEl = focusableStartEl;
          while (true) {
            mainEl = mainEl.nextSibling;
            if (mainEl === null)
              break;
            if (mainEl instanceof Element && mainEl.tagName === "DIV") {
              break;
            }
          }
          return mainEl;
        }
        function activate() {
          var _a;
          if (props.disabled)
            return;
          stack.push(id);
          if (props.autoFocus) {
            const { initialFocusTo } = props;
            if (initialFocusTo === void 0) {
              resetFocusTo("first");
            } else {
              (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
            }
          }
          activated = true;
          document.addEventListener("focus", handleDocumentFocus, true);
        }
        function deactivate() {
          var _a;
          if (props.disabled)
            return;
          document.removeEventListener("focus", handleDocumentFocus, true);
          stack = stack.filter((idInStack) => idInStack !== id);
          if (isCurrentActive())
            return;
          const { finalFocusTo } = props;
          if (finalFocusTo !== void 0) {
            (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
          } else if (props.returnFocusOnDeactivated) {
            if (lastFocusedElement instanceof HTMLElement) {
              ignoreInternalFocusChange = true;
              lastFocusedElement.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
            }
          }
        }
        function resetFocusTo(target) {
          if (!isCurrentActive())
            return;
          if (props.active) {
            const focusableStartEl = focusableStartRef.value;
            const focusableEndEl = focusableEndRef.value;
            if (focusableStartEl !== null && focusableEndEl !== null) {
              const mainEl = getMainEl();
              if (mainEl == null || mainEl === focusableEndEl) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
                return;
              }
              ignoreInternalFocusChange = true;
              const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
              ignoreInternalFocusChange = false;
              if (!focused) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
              }
            }
          }
        }
        function handleStartFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          const mainEl = getMainEl();
          if (mainEl === null)
            return;
          if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        function handleEndFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        return {
          focusableStartRef,
          focusableEndRef,
          focusableStyle: "position: absolute; height: 0; width: 0;",
          handleStartFocus,
          handleEndFocus
        };
      },
      render() {
        const { default: defaultSlot } = this.$slots;
        if (defaultSlot === void 0)
          return null;
        if (this.disabled)
          return defaultSlot();
        const { active, focusableStyle } = this;
        return h(Fragment, null, [
          h("div", {
            "aria-hidden": "true",
            tabindex: active ? "0" : "-1",
            ref: "focusableStartRef",
            style: focusableStyle,
            onFocus: this.handleStartFocus
          }),
          defaultSlot(),
          h("div", {
            "aria-hidden": "true",
            style: focusableStyle,
            ref: "focusableEndRef",
            tabindex: active ? "0" : "-1",
            onFocus: this.handleEndFocus
          })
        ]);
      }
    });
    function useOnResize(elRef, onResize) {
      if (onResize) {
        onMounted(() => {
          const { value: el } = elRef;
          if (el) {
            resizeObserverManager.registerHandler(el, onResize);
          }
        });
        onBeforeUnmount(() => {
          const { value: el } = elRef;
          if (el) {
            resizeObserverManager.unregisterHandler(el);
          }
        });
      }
    }
    function useReactivated(callback) {
      const isDeactivatedRef = { isDeactivated: false };
      let activateStateInitialized = false;
      onActivated(() => {
        isDeactivatedRef.isDeactivated = false;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
          return;
        }
        callback();
      });
      onDeactivated(() => {
        isDeactivatedRef.isDeactivated = true;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
        }
      });
      return isDeactivatedRef;
    }
    const formItemInjectionKey = createInjectionKey("n-form-item");
    function useFormItem(props, { defaultSize = "medium", mergedSize, mergedDisabled } = {}) {
      const NFormItem2 = inject(formItemInjectionKey, null);
      provide(formItemInjectionKey, null);
      const mergedSizeRef = computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
        const { size: size2 } = props;
        if (size2)
          return size2;
        if (NFormItem2) {
          const { mergedSize: mergedSize2 } = NFormItem2;
          if (mergedSize2.value !== void 0) {
            return mergedSize2.value;
          }
        }
        return defaultSize;
      });
      const mergedDisabledRef = computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
        const { disabled } = props;
        if (disabled !== void 0) {
          return disabled;
        }
        if (NFormItem2) {
          return NFormItem2.disabled.value;
        }
        return false;
      });
      const mergedStatusRef = computed(() => {
        const { status } = props;
        if (status)
          return status;
        return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
      });
      onBeforeUnmount(() => {
        if (NFormItem2) {
          NFormItem2.restoreValidation();
        }
      });
      return {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef,
        nTriggerFormBlur() {
          if (NFormItem2) {
            NFormItem2.handleContentBlur();
          }
        },
        nTriggerFormChange() {
          if (NFormItem2) {
            NFormItem2.handleContentChange();
          }
        },
        nTriggerFormFocus() {
          if (NFormItem2) {
            NFormItem2.handleContentFocus();
          }
        },
        nTriggerFormInput() {
          if (NFormItem2) {
            NFormItem2.handleContentInput();
          }
        }
      };
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal$1 || freeSelf || Function("return this")();
    const root$1 = root;
    var Symbol$1 = root$1.Symbol;
    const Symbol$2 = Symbol$1;
    var objectProto$e = Object.prototype;
    var hasOwnProperty$b = objectProto$e.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$e.toString;
    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$d = Object.prototype;
    var nativeObjectToString = objectProto$d.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$1 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
    }
    function arrayMap(array2, iteratee) {
      var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    var isArray = Array.isArray;
    const isArray$1 = isArray;
    var INFINITY$1 = 1 / 0;
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$1(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index = string2.length;
      while (index-- && reWhitespace.test(string2.charAt(index))) {
      }
      return index;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function isObject(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    const coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function getValue$1(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue$1(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root$1, "WeakMap");
    const WeakMap$2 = WeakMap$1;
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    const baseCreate$1 = baseCreate;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array2) {
      var index = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index < length) {
        array2[index] = source[index];
      }
      return array2;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    const defineProperty$1 = defineProperty;
    var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
      return defineProperty$1(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    const baseSetToString$1 = baseSetToString;
    var setToString = shortOut(baseSetToString$1);
    const setToString$1 = setToString;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$9.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    var nativeMax$1 = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
        while (++index < length) {
          array2[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array2);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString$1(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index, object2) {
      if (!isObject(object2)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == "string" && index in object2) {
        return eq(object2[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object2 = Object(object2);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object2, source, index, customizer);
          }
        }
        return object2;
      });
    }
    var objectProto$a = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    const isArguments$1 = isArguments;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    const isBuffer$1 = isBuffer;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal$1.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    const nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    const isTypedArray$1 = isTypedArray;
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys$1(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$6.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray$1(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate$1) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root$1, "Map");
    const Map$2 = Map$1;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$2 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match2, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
      });
      return result;
    });
    const stringToPath$1 = stringToPath;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object2) {
      if (isArray$1(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath$1(toString(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index = 0, length = path.length;
      while (object2 != null && index < length) {
        object2 = object2[toKey(path[index++])];
      }
      return index && index == length ? object2 : void 0;
    }
    function get(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array2, values) {
      var index = -1, length = values.length, offset = array2.length;
      while (++index < length) {
        array2[offset + index] = values[index];
      }
      return array2;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    const getPrototype$1 = getPrototype;
    var objectTag$2 = "[object Object]";
    var funcProto = Function.prototype, objectProto$3 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
        return false;
      }
      var proto = getPrototype$1(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function baseSlice(array2, start, end) {
      var index = -1, length = array2.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array2[index + start];
      }
      return result;
    }
    function castSlice(array2, start, end) {
      var length = array2.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array2 : baseSlice(array2, start, end);
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsZWJ$1 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function asciiToArray(string2) {
      return string2.split("");
    }
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var upperFirst = createCaseFirst("toUpperCase");
    const upperFirst$1 = upperFirst;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function arrayFilter(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$2 = Object.prototype;
    var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    const getSymbols$1 = getSymbols;
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols$1);
    }
    var DataView = getNative(root$1, "DataView");
    const DataView$1 = DataView;
    var Promise$1 = getNative(root$1, "Promise");
    const Promise$2 = Promise$1;
    var Set$1 = getNative(root$1, "Set");
    const Set$2 = Set$1;
    var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag$1 = "[object DataView]";
    var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
    var getTag = baseGetTag;
    if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2()) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$1 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$1;
            case mapCtorString:
              return mapTag$1;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$1;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var Uint8Array2 = root$1.Uint8Array;
    const Uint8Array$1 = Uint8Array2;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array2);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack2) : customizer(arrValue, othValue, index, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack2.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object2);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$1(object2)) {
        if (!isBuffer$1(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack2 = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack2);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function getMatchData(object2) {
      var result = keys(object2), length = result.length;
      while (length--) {
        var key = result[length], value = object2[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object2) || isArguments$1(object2));
    }
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object2) {
        var objValue = get(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object2) {
        return baseGet(object2, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    var baseFor = createBaseFor();
    const baseFor$1 = baseFor;
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor$1(object2, iteratee, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    const baseEach$1 = baseEach;
    var now = function() {
      return root$1.Date.now();
    };
    const now$1 = now;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now$1();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now$1());
      }
      function debounced() {
        var time2 = now$1(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function assignMergeValue(object2, key, value) {
      if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray$1(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
          newValue = objValue;
          if (isArguments$1(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object2, key, newValue);
    }
    function baseMerge(object2, source, srcIndex, customizer, stack2) {
      if (object2 === source) {
        return;
      }
      baseFor$1(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn);
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach$1(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function map(collection, iteratee) {
      var func = isArray$1(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee));
    }
    var merge$1 = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    const merge$2 = merge$1;
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    const commonVariables$d = {
      fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
      fontWeight: "400",
      fontWeightStrong: "500",
      cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
      cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
      cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
      borderRadius: "3px",
      borderRadiusSmall: "2px",
      fontSize: "14px",
      fontSizeMini: "12px",
      fontSizeTiny: "12px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      lineHeight: "1.6",
      heightMini: "16px",
      heightTiny: "22px",
      heightSmall: "28px",
      heightMedium: "34px",
      heightLarge: "40px",
      heightHuge: "46px"
    };
    const {
      fontSize,
      fontFamily,
      lineHeight
    } = commonVariables$d;
    const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
    const configProviderInjectionKey = createInjectionKey("n-config-provider");
    const cssrAnchorMetaName = "naive-ui-style";
    function createTheme(theme) {
      return theme;
    }
    function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider = inject(configProviderInjectionKey, null);
      if (style2) {
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
          style2.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2
          });
          if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2
            });
          }
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          onBeforeMount(mountStyle);
        }
      }
      const mergedThemeRef = computed(() => {
        var _a;
        const { theme: { common: selfCommon, self: self2, peers = {} } = {}, themeOverrides: selfOverrides = {}, builtinThemeOverrides: builtinOverrides = {} } = props;
        const { common: selfCommonOverrides, peers: peersOverrides } = selfOverrides;
        const { common: globalCommon = void 0, [resolveId]: { common: globalSelfCommon = void 0, self: globalSelf = void 0, peers: globalPeers = {} } = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
        const { common: globalCommonOverrides = void 0, [resolveId]: globalSelfOverrides = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
        const { common: globalSelfCommonOverrides, peers: globalPeersOverrides = {} } = globalSelfOverrides;
        const mergedCommon = merge$2({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
        const mergedSelf = merge$2(
          // {}, executed every time, no need for empty obj
          (_a = self2 || globalSelf || defaultTheme.self) === null || _a === void 0 ? void 0 : _a(mergedCommon),
          builtinOverrides,
          globalSelfOverrides,
          selfOverrides
        );
        return {
          common: mergedCommon,
          self: mergedSelf,
          peers: merge$2({}, defaultTheme.peers, globalPeers, peers),
          peerOverrides: merge$2({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
        };
      });
      return mergedThemeRef;
    }
    useTheme.props = {
      theme: Object,
      themeOverrides: Object,
      builtinThemeOverrides: Object
    };
    const defaultClsPrefix = "n";
    function useConfig(props = {}, options = {
      defaultBordered: true
    }) {
      const NConfigProvider = inject(configProviderInjectionKey, null);
      return {
        // NConfigProvider,
        inlineThemeDisabled: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled,
        mergedRtlRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef,
        mergedComponentPropsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef,
        mergedBreakpointsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef,
        mergedBorderedRef: computed(() => {
          var _a, _b;
          const { bordered } = props;
          if (bordered !== void 0)
            return bordered;
          return (_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true;
        }),
        mergedClsPrefixRef: computed(() => {
          const clsPrefix = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedClsPrefixRef.value;
          return clsPrefix || defaultClsPrefix;
        }),
        namespaceRef: computed(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
      };
    }
    const enUS = {
      name: "en-US",
      global: {
        undo: "Undo",
        redo: "Redo",
        confirm: "Confirm",
        clear: "Clear"
      },
      Popconfirm: {
        positiveText: "Confirm",
        negativeText: "Cancel"
      },
      Cascader: {
        placeholder: "Please Select",
        loading: "Loading",
        loadingRequiredMessage: (label) => `Please load all ${label}'s descendants before checking it.`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Clear",
        now: "Now",
        confirm: "Confirm",
        selectTime: "Select Time",
        selectDate: "Select Date",
        datePlaceholder: "Select Date",
        datetimePlaceholder: "Select Date and Time",
        monthPlaceholder: "Select Month",
        yearPlaceholder: "Select Year",
        quarterPlaceholder: "Select Quarter",
        startDatePlaceholder: "Start Date",
        endDatePlaceholder: "End Date",
        startDatetimePlaceholder: "Start Date and Time",
        endDatetimePlaceholder: "End Date and Time",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: "Today"
      },
      DataTable: {
        checkTableAll: "Select all in the table",
        uncheckTableAll: "Unselect all in the table",
        confirm: "Confirm",
        clear: "Clear"
      },
      LegacyTransfer: {
        sourceTitle: "Source",
        targetTitle: "Target"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: (num) => `Total ${num} items`,
        selected: (num) => `${num} items selected`
      },
      Empty: {
        description: "No Data"
      },
      Select: {
        placeholder: "Please Select"
      },
      TimePicker: {
        placeholder: "Select Time",
        positiveText: "OK",
        negativeText: "Cancel",
        now: "Now"
      },
      Pagination: {
        goto: "Goto",
        selectionSuffix: "page"
      },
      DynamicTags: {
        add: "Add"
      },
      Log: {
        loading: "Loading"
      },
      Input: {
        placeholder: "Please Input"
      },
      InputNumber: {
        placeholder: "Please Input"
      },
      DynamicInput: {
        create: "Create"
      },
      ThemeEditor: {
        title: "Theme Editor",
        clearAllVars: "Clear All Variables",
        clearSearch: "Clear Search",
        filterCompName: "Filter Component Name",
        filterVarName: "Filter Variable Name",
        import: "Import",
        export: "Export",
        restore: "Reset to Default"
      },
      Image: {
        tipPrevious: "Previous picture (←)",
        tipNext: "Next picture (→)",
        tipCounterclockwise: "Counterclockwise",
        tipClockwise: "Clockwise",
        tipZoomOut: "Zoom out",
        tipZoomIn: "Zoom in",
        tipClose: "Close (Esc)",
        // TODO: translation
        tipOriginalSize: "Zoom to original size"
      }
    };
    const enUS$1 = enUS;
    function buildFormatLongFn(args) {
      return function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format2 = args.formats[width] || args.formats[args.defaultWidth];
        return format2;
      };
    }
    function buildLocalizeFn(args) {
      return function(dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
        var valuesArray;
        if (context === "formatting" && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;
          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }
        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }
    function buildMatchFn(args) {
      return function(string2) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string2.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern2) {
          return pattern2.test(matchedString);
        }) : findKey(parsePatterns, function(pattern2) {
          return pattern2.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string2.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    function findKey(object2, predicate) {
      for (var key in object2) {
        if (object2.hasOwnProperty(key) && predicate(object2[key])) {
          return key;
        }
      }
      return void 0;
    }
    function findIndex(array2, predicate) {
      for (var key = 0; key < array2.length; key++) {
        if (predicate(array2[key])) {
          return key;
        }
      }
      return void 0;
    }
    function buildMatchPatternFn(args) {
      return function(string2) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var matchResult = string2.match(args.matchPattern);
        if (!matchResult)
          return null;
        var matchedString = matchResult[0];
        var parseResult = string2.match(args.parsePattern);
        if (!parseResult)
          return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string2.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    var formatDistance = function formatDistance2(token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    const formatDistance$1 = formatDistance;
    var dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    var timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    const formatLong$1 = formatLong;
    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    };
    const formatRelative$1 = formatRelative;
    var eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    var quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    var monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    var dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };
    var dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
      var number2 = Number(dirtyNumber);
      var rem100 = number2 % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number2 + "st";
          case 2:
            return number2 + "nd";
          case 3:
            return number2 + "rd";
        }
      }
      return number2 + "th";
    };
    var localize = {
      ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    const localize$1 = localize;
    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    const match$1 = match;
    var locale = {
      code: "en-US",
      formatDistance: formatDistance$1,
      formatLong: formatLong$1,
      formatRelative: formatRelative$1,
      localize: localize$1,
      match: match$1,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    const defaultLocale = locale;
    const dateEnUs = {
      name: "en-US",
      locale: defaultLocale
    };
    const dateEnUS = dateEnUs;
    function useLocale(ns) {
      const { mergedLocaleRef, mergedDateLocaleRef } = inject(configProviderInjectionKey, null) || {};
      const localeRef = computed(() => {
        var _a, _b;
        return (_b = (_a = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a === void 0 ? void 0 : _a[ns]) !== null && _b !== void 0 ? _b : enUS$1[ns];
      });
      const dateLocaleRef = computed(() => {
        var _a;
        return (_a = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a !== void 0 ? _a : dateEnUS;
      });
      return {
        dateLocaleRef,
        localeRef
      };
    }
    function useStyle(mountId, style2, clsPrefixRef) {
      if (!style2) {
        return;
      }
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
        style2.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter2
        });
        if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2
          });
        }
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
    }
    function useThemeClass(componentName, hashRef, cssVarsRef, props) {
      var _a;
      if (!cssVarsRef)
        throwError("useThemeClass", "cssVarsRef is not passed");
      const mergedThemeHashRef = (_a = inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedThemeHashRef;
      const themeClassRef = ref("");
      const ssrAdapter2 = useSsrAdapter();
      let renderCallback;
      const hashClassPrefix = `__${componentName}`;
      const mountStyle = () => {
        let finalThemeHash = hashClassPrefix;
        const hashValue = hashRef ? hashRef.value : void 0;
        const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
        if (themeHash)
          finalThemeHash += "-" + themeHash;
        if (hashValue)
          finalThemeHash += "-" + hashValue;
        const { themeOverrides, builtinThemeOverrides } = props;
        if (themeOverrides) {
          finalThemeHash += "-" + murmur2(JSON.stringify(themeOverrides));
        }
        if (builtinThemeOverrides) {
          finalThemeHash += "-" + murmur2(JSON.stringify(builtinThemeOverrides));
        }
        themeClassRef.value = finalThemeHash;
        renderCallback = () => {
          const cssVars = cssVarsRef.value;
          let style2 = "";
          for (const key in cssVars) {
            style2 += `${key}: ${cssVars[key]};`;
          }
          c$1(`.${finalThemeHash}`, style2).mount({
            id: finalThemeHash,
            ssr: ssrAdapter2
          });
          renderCallback = void 0;
        };
      };
      watchEffect(() => {
        mountStyle();
      });
      return {
        themeClass: themeClassRef,
        onRender: () => {
          renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
        }
      };
    }
    function useRtl(mountId, rtlStateRef, clsPrefixRef) {
      if (!rtlStateRef)
        return void 0;
      const ssrAdapter2 = useSsrAdapter();
      const componentRtlStateRef = computed(() => {
        const { value: rtlState } = rtlStateRef;
        if (!rtlState) {
          return void 0;
        }
        const componentRtlState = rtlState[mountId];
        if (!componentRtlState) {
          return void 0;
        }
        return componentRtlState;
      });
      const mountStyle = () => {
        watchEffect(() => {
          const { value: clsPrefix } = clsPrefixRef;
          const id = `${clsPrefix}${mountId}Rtl`;
          if (exists(id, ssrAdapter2))
            return;
          const { value: componentRtlState } = componentRtlStateRef;
          if (!componentRtlState)
            return;
          componentRtlState.style.mount({
            id,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter2
          });
        });
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
      return componentRtlStateRef;
    }
    const AddIcon = defineComponent({
      name: "Add",
      render() {
        return h(
          "svg",
          { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          h("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" })
        );
      }
    });
    const ArrowDownIcon = defineComponent({
      name: "ArrowDown",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
          h(
            "g",
            { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
            h(
              "g",
              { "fill-rule": "nonzero" },
              h("path", { d: "M23.7916,15.2664 C24.0788,14.9679 24.0696,14.4931 23.7711,14.206 C23.4726,13.9188 22.9978,13.928 22.7106,14.2265 L14.7511,22.5007 L14.7511,3.74792 C14.7511,3.33371 14.4153,2.99792 14.0011,2.99792 C13.5869,2.99792 13.2511,3.33371 13.2511,3.74793 L13.2511,22.4998 L5.29259,14.2265 C5.00543,13.928 4.53064,13.9188 4.23213,14.206 C3.93361,14.4931 3.9244,14.9679 4.21157,15.2664 L13.2809,24.6944 C13.6743,25.1034 14.3289,25.1034 14.7223,24.6944 L23.7916,15.2664 Z" })
            )
          )
        );
      }
    });
    const ArrowUpIcon = defineComponent({
      name: "ArrowUp",
      render() {
        return h(
          "svg",
          { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" },
          h(
            "g",
            { fill: "none" },
            h("path", { d: "M3.13 9.163a.5.5 0 1 0 .74.674L9.5 3.67V17.5a.5.5 0 0 0 1 0V3.672l5.63 6.165a.5.5 0 0 0 .738-.674l-6.315-6.916a.746.746 0 0 0-.632-.24a.746.746 0 0 0-.476.24L3.131 9.163z", fill: "currentColor" })
          )
        );
      }
    });
    function replaceable(name, icon) {
      return defineComponent({
        name: upperFirst$1(name),
        setup() {
          var _a;
          const mergedIconsRef = (_a = inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedIconsRef;
          return () => {
            var _a2;
            const iconOverride = (_a2 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a2 === void 0 ? void 0 : _a2[name];
            return iconOverride ? iconOverride() : icon;
          };
        }
      });
    }
    const BackwardIcon = defineComponent({
      name: "Backward",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          h("path", { d: "M12.2674 15.793C11.9675 16.0787 11.4927 16.0672 11.2071 15.7673L6.20572 10.5168C5.9298 10.2271 5.9298 9.7719 6.20572 9.48223L11.2071 4.23177C11.4927 3.93184 11.9675 3.92031 12.2674 4.206C12.5673 4.49169 12.5789 4.96642 12.2932 5.26634L7.78458 9.99952L12.2932 14.7327C12.5789 15.0326 12.5673 15.5074 12.2674 15.793Z", fill: "currentColor" })
        );
      }
    });
    const FinishedIcon = defineComponent({
      name: "Checkmark",
      render() {
        return h(
          "svg",
          { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" },
          h(
            "g",
            { fill: "none" },
            h("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })
          )
        );
      }
    });
    const ChevronRightIcon = defineComponent({
      name: "ChevronRight",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          h("path", { d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z", fill: "currentColor" })
        );
      }
    });
    const ErrorIcon = replaceable("close", h(
      "svg",
      { viewBox: "0 0 12 12", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": true },
      h(
        "g",
        { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
        h(
          "g",
          { fill: "currentColor", "fill-rule": "nonzero" },
          h("path", { d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z" })
        )
      )
    ));
    const EyeIcon = defineComponent({
      name: "Eye",
      render() {
        return h(
          "svg",
          { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
          h("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }),
          h("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" })
        );
      }
    });
    const EyeOffIcon = defineComponent({
      name: "EyeOff",
      render() {
        return h(
          "svg",
          { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
          h("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }),
          h("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }),
          h("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }),
          h("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }),
          h("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" })
        );
      }
    });
    const EmptyIcon = defineComponent({
      name: "Empty",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          h("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }),
          h("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" })
        );
      }
    });
    const FastBackwardIcon = defineComponent({
      name: "FastBackward",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
          h(
            "g",
            { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
            h(
              "g",
              { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M8.73171,16.7949 C9.03264,17.0795 9.50733,17.0663 9.79196,16.7654 C10.0766,16.4644 10.0634,15.9897 9.76243,15.7051 L4.52339,10.75 L17.2471,10.75 C17.6613,10.75 17.9971,10.4142 17.9971,10 C17.9971,9.58579 17.6613,9.25 17.2471,9.25 L4.52112,9.25 L9.76243,4.29275 C10.0634,4.00812 10.0766,3.53343 9.79196,3.2325 C9.50733,2.93156 9.03264,2.91834 8.73171,3.20297 L2.31449,9.27241 C2.14819,9.4297 2.04819,9.62981 2.01448,9.8386 C2.00308,9.89058 1.99707,9.94459 1.99707,10 C1.99707,10.0576 2.00356,10.1137 2.01585,10.1675 C2.05084,10.3733 2.15039,10.5702 2.31449,10.7254 L8.73171,16.7949 Z" })
            )
          )
        );
      }
    });
    const FastForwardIcon = defineComponent({
      name: "FastForward",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
          h(
            "g",
            { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
            h(
              "g",
              { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z" })
            )
          )
        );
      }
    });
    const FilterIcon = defineComponent({
      name: "Filter",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
          h(
            "g",
            { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
            h(
              "g",
              { "fill-rule": "nonzero" },
              h("path", { d: "M17,19 C17.5522847,19 18,19.4477153 18,20 C18,20.5522847 17.5522847,21 17,21 L11,21 C10.4477153,21 10,20.5522847 10,20 C10,19.4477153 10.4477153,19 11,19 L17,19 Z M21,13 C21.5522847,13 22,13.4477153 22,14 C22,14.5522847 21.5522847,15 21,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4477153 6.44771525,13 7,13 L21,13 Z M24,7 C24.5522847,7 25,7.44771525 25,8 C25,8.55228475 24.5522847,9 24,9 L4,9 C3.44771525,9 3,8.55228475 3,8 C3,7.44771525 3.44771525,7 4,7 L24,7 Z" })
            )
          )
        );
      }
    });
    const ForwardIcon = defineComponent({
      name: "Forward",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          h("path", { d: "M7.73271 4.20694C8.03263 3.92125 8.50737 3.93279 8.79306 4.23271L13.7944 9.48318C14.0703 9.77285 14.0703 10.2281 13.7944 10.5178L8.79306 15.7682C8.50737 16.0681 8.03263 16.0797 7.73271 15.794C7.43279 15.5083 7.42125 15.0336 7.70694 14.7336L12.2155 10.0005L7.70694 5.26729C7.42125 4.96737 7.43279 4.49264 7.73271 4.20694Z", fill: "currentColor" })
        );
      }
    });
    const MoreIcon = defineComponent({
      name: "More",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
          h(
            "g",
            { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
            h(
              "g",
              { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M4,7 C4.55228,7 5,7.44772 5,8 C5,8.55229 4.55228,9 4,9 C3.44772,9 3,8.55229 3,8 C3,7.44772 3.44772,7 4,7 Z M8,7 C8.55229,7 9,7.44772 9,8 C9,8.55229 8.55229,9 8,9 C7.44772,9 7,8.55229 7,8 C7,7.44772 7.44772,7 8,7 Z M12,7 C12.5523,7 13,7.44772 13,8 C13,8.55229 12.5523,9 12,9 C11.4477,9 11,8.55229 11,8 C11,7.44772 11.4477,7 12,7 Z" })
            )
          )
        );
      }
    });
    const RemoveIcon = defineComponent({
      name: "Remove",
      render() {
        return h(
          "svg",
          { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
          h("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      " })
        );
      }
    });
    const ChevronDownIcon = defineComponent({
      name: "ChevronDown",
      render() {
        return h(
          "svg",
          { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          h("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" })
        );
      }
    });
    const ClearIcon = replaceable("clear", h(
      "svg",
      { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h(
        "g",
        { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
        h(
          "g",
          { fill: "currentColor", "fill-rule": "nonzero" },
          h("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" })
        )
      )
    ));
    const NIconSwitchTransition = defineComponent({
      name: "BaseIconSwitchTransition",
      setup(_, { slots }) {
        const isMountedRef = isMounted();
        return () => h(Transition, { name: "icon-switch-transition", appear: isMountedRef.value }, slots);
      }
    });
    const NFadeInExpandTransition = defineComponent({
      name: "FadeInExpandTransition",
      props: {
        appear: Boolean,
        group: Boolean,
        mode: String,
        onLeave: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        width: Boolean,
        // reverse mode is only used in tree
        // it make it from expanded to collapsed after mounted
        reverse: Boolean
      },
      setup(props, { slots }) {
        function handleBeforeLeave(el) {
          if (props.width) {
            el.style.maxWidth = `${el.offsetWidth}px`;
          } else {
            el.style.maxHeight = `${el.offsetHeight}px`;
          }
          void el.offsetWidth;
        }
        function handleLeave(el) {
          if (props.width) {
            el.style.maxWidth = "0";
          } else {
            el.style.maxHeight = "0";
          }
          void el.offsetWidth;
          const { onLeave } = props;
          if (onLeave)
            onLeave();
        }
        function handleAfterLeave(el) {
          if (props.width) {
            el.style.maxWidth = "";
          } else {
            el.style.maxHeight = "";
          }
          const { onAfterLeave } = props;
          if (onAfterLeave)
            onAfterLeave();
        }
        function handleEnter(el) {
          el.style.transition = "none";
          if (props.width) {
            const memorizedWidth = el.offsetWidth;
            el.style.maxWidth = "0";
            void el.offsetWidth;
            el.style.transition = "";
            el.style.maxWidth = `${memorizedWidth}px`;
          } else {
            if (props.reverse) {
              el.style.maxHeight = `${el.offsetHeight}px`;
              void el.offsetHeight;
              el.style.transition = "";
              el.style.maxHeight = "0";
            } else {
              const memorizedHeight = el.offsetHeight;
              el.style.maxHeight = "0";
              void el.offsetWidth;
              el.style.transition = "";
              el.style.maxHeight = `${memorizedHeight}px`;
            }
          }
          void el.offsetWidth;
        }
        function handleAfterEnter(el) {
          var _a;
          if (props.width) {
            el.style.maxWidth = "";
          } else {
            if (!props.reverse) {
              el.style.maxHeight = "";
            }
          }
          (_a = props.onAfterEnter) === null || _a === void 0 ? void 0 : _a.call(props);
        }
        return () => {
          const type2 = props.group ? TransitionGroup : Transition;
          return h(type2, {
            name: props.width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
            mode: props.mode,
            appear: props.appear,
            onEnter: handleEnter,
            onAfterEnter: handleAfterEnter,
            onBeforeLeave: handleBeforeLeave,
            onLeave: handleLeave,
            onAfterLeave: handleAfterLeave
          }, slots);
        };
      }
    });
    const style$s = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c$1("svg", `
 height: 1em;
 width: 1em;
 `)]);
    const NBaseIcon = defineComponent({
      name: "BaseIcon",
      props: {
        role: String,
        ariaLabel: String,
        ariaDisabled: {
          type: Boolean,
          default: void 0
        },
        ariaHidden: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function,
        onMousedown: Function,
        onMouseup: Function
      },
      setup(props) {
        useStyle("-base-icon", style$s, toRef(props, "clsPrefix"));
      },
      render() {
        return h("i", { class: `${this.clsPrefix}-base-icon`, onClick: this.onClick, onMousedown: this.onMousedown, onMouseup: this.onMouseup, role: this.role, "aria-label": this.ariaLabel, "aria-hidden": this.ariaHidden, "aria-disabled": this.ariaDisabled }, this.$slots);
      }
    });
    const style$r = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c$1("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM("round", [c$1("&::before", `
 border-radius: 50%;
 `)])]);
    const NBaseClose = defineComponent({
      name: "BaseClose",
      props: {
        isButtonTag: {
          type: Boolean,
          default: true
        },
        clsPrefix: {
          type: String,
          required: true
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        focusable: {
          type: Boolean,
          default: true
        },
        round: Boolean,
        onClick: Function,
        absolute: Boolean
      },
      setup(props) {
        useStyle("-base-close", style$r, toRef(props, "clsPrefix"));
        return () => {
          const { clsPrefix, disabled, absolute, round, isButtonTag } = props;
          const Tag = isButtonTag ? "button" : "div";
          return h(
            Tag,
            { type: isButtonTag ? "button" : void 0, tabindex: disabled || !props.focusable ? -1 : 0, "aria-disabled": disabled, "aria-label": "close", role: isButtonTag ? void 0 : "button", disabled, class: [
              `${clsPrefix}-base-close`,
              absolute && `${clsPrefix}-base-close--absolute`,
              disabled && `${clsPrefix}-base-close--disabled`,
              round && `${clsPrefix}-base-close--round`
            ], onMousedown: (e) => {
              if (!props.focusable) {
                e.preventDefault();
              }
            }, onClick: props.onClick },
            h(NBaseIcon, { clsPrefix }, {
              default: () => h(ErrorIcon, null)
            })
          );
        };
      }
    });
    const FocusDetector = defineComponent({
      props: {
        onFocus: Function,
        onBlur: Function
      },
      setup(props) {
        return () => h("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: props.onFocus, onBlur: props.onBlur });
      }
    });
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$3
    } = commonVariables$d;
    function iconSwitchTransition({
      originalTransform = "",
      left = 0,
      top = 0,
      transition = `all .3s ${cubicBezierEaseInOut$3} !important`
    } = {}) {
      return [c$1("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
        transform: originalTransform + " scale(0.75)",
        left,
        top,
        opacity: 0
      }), c$1("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
        transform: `scale(1) ${originalTransform}`,
        left,
        top,
        opacity: 1
      }), c$1("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
        transformOrigin: "center",
        position: "absolute",
        left,
        top,
        transition
      })];
    }
    const style$q = c$1([c$1("@keyframes loading-container-rotate", `
 to {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }
 `), c$1("@keyframes loading-layer-rotate", `
 12.5% {
 -webkit-transform: rotate(135deg);
 transform: rotate(135deg);
 }
 25% {
 -webkit-transform: rotate(270deg);
 transform: rotate(270deg);
 }
 37.5% {
 -webkit-transform: rotate(405deg);
 transform: rotate(405deg);
 }
 50% {
 -webkit-transform: rotate(540deg);
 transform: rotate(540deg);
 }
 62.5% {
 -webkit-transform: rotate(675deg);
 transform: rotate(675deg);
 }
 75% {
 -webkit-transform: rotate(810deg);
 transform: rotate(810deg);
 }
 87.5% {
 -webkit-transform: rotate(945deg);
 transform: rotate(945deg);
 }
 100% {
 -webkit-transform: rotate(1080deg);
 transform: rotate(1080deg);
 } 
 `), c$1("@keyframes loading-left-spin", `
 from {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 50% {
 -webkit-transform: rotate(130deg);
 transform: rotate(130deg);
 }
 to {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 `), c$1("@keyframes loading-right-spin", `
 from {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 50% {
 -webkit-transform: rotate(-130deg);
 transform: rotate(-130deg);
 }
 to {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 `), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE("container", `
 display: inline-flex;
 position: relative;
 direction: ltr;
 line-height: 0;
 animation: loading-container-rotate 1568.2352941176ms linear infinite;
 font-size: 0;
 letter-spacing: 0;
 white-space: nowrap;
 opacity: 1;
 width: 100%;
 height: 100%;
 `, [cE("svg", `
 stroke: var(--n-text-color);
 fill: transparent;
 position: absolute;
 height: 100%;
 overflow: hidden;
 `), cE("container-layer", `
 position: absolute;
 width: 100%;
 height: 100%;
 animation: loading-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 `, [cE("container-layer-left", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 animation: loading-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 width: 200%;
 `)]), cE("container-layer-patch", `
 position: absolute;
 top: 0;
 left: 47.5%;
 box-sizing: border-box;
 width: 5%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 left: -900%;
 width: 2000%;
 transform: rotate(180deg);
 `)]), cE("container-layer-right", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 animation: loading-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 left: -100%;
 width: 200%;
 `)])])]), cE("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })])])]);
    const exposedLoadingProps = {
      strokeWidth: {
        type: Number,
        default: 28
      },
      stroke: {
        type: String,
        default: void 0
      }
    };
    const NBaseLoading = defineComponent({
      name: "BaseLoading",
      props: Object.assign({ clsPrefix: {
        type: String,
        required: true
      }, show: {
        type: Boolean,
        default: true
      }, scale: {
        type: Number,
        default: 1
      }, radius: {
        type: Number,
        default: 100
      } }, exposedLoadingProps),
      setup(props) {
        useStyle("-base-loading", style$q, toRef(props, "clsPrefix"));
      },
      render() {
        const { clsPrefix, radius, strokeWidth, stroke, scale } = this;
        const scaledRadius = radius / scale;
        return h(
          "div",
          { class: `${clsPrefix}-base-loading`, role: "img", "aria-label": "loading" },
          h(NIconSwitchTransition, null, {
            default: () => this.show ? h(
              "div",
              { key: "icon", class: `${clsPrefix}-base-loading__transition-wrapper` },
              h(
                "div",
                { class: `${clsPrefix}-base-loading__container` },
                h(
                  "div",
                  { class: `${clsPrefix}-base-loading__container-layer` },
                  h(
                    "div",
                    { class: `${clsPrefix}-base-loading__container-layer-left` },
                    h(
                      "svg",
                      { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                    )
                  ),
                  h(
                    "div",
                    { class: `${clsPrefix}-base-loading__container-layer-patch` },
                    h(
                      "svg",
                      { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                    )
                  ),
                  h(
                    "div",
                    { class: `${clsPrefix}-base-loading__container-layer-right` },
                    h(
                      "svg",
                      { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                    )
                  )
                )
              )
            ) : h("div", { key: "placeholder", class: `${clsPrefix}-base-loading__placeholder` }, this.$slots)
          })
        );
      }
    });
    function toArray(arg) {
      if (Array.isArray(arg))
        return arg;
      return [arg];
    }
    const TRAVERSE_COMMAND = {
      STOP: "STOP"
    };
    function traverseWithCb(treeNode, callback) {
      const command = callback(treeNode);
      if (treeNode.children !== void 0 && command !== TRAVERSE_COMMAND.STOP) {
        treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
      }
    }
    function getNonLeafKeys(treeNodes, options = {}) {
      const { preserveGroup = false } = options;
      const keys2 = [];
      const cb = preserveGroup ? (node) => {
        if (!node.isLeaf) {
          keys2.push(node.key);
          traverse2(node.children);
        }
      } : (node) => {
        if (!node.isLeaf) {
          if (!node.isGroup)
            keys2.push(node.key);
          traverse2(node.children);
        }
      };
      function traverse2(nodes) {
        nodes.forEach(cb);
      }
      traverse2(treeNodes);
      return keys2;
    }
    function isLeaf(rawNode, getChildren) {
      const { isLeaf: isLeaf2 } = rawNode;
      if (isLeaf2 !== void 0)
        return isLeaf2;
      else if (!getChildren(rawNode))
        return true;
      return false;
    }
    function defaultGetChildren(node) {
      return node.children;
    }
    function defaultGetKey(node) {
      return node.key;
    }
    function isIgnored() {
      return false;
    }
    function isShallowLoaded(rawNode, getChildren) {
      const { isLeaf: isLeaf2 } = rawNode;
      if (isLeaf2 === false && !Array.isArray(getChildren(rawNode)))
        return false;
      return true;
    }
    function isDisabled(rawNode) {
      return rawNode.disabled === true;
    }
    function isExpilicitlyNotLoaded(rawNode, getChildren) {
      return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
    }
    function unwrapCheckedKeys(result) {
      var _a;
      if (result === void 0 || result === null)
        return [];
      if (Array.isArray(result))
        return result;
      return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];
    }
    function unwrapIndeterminateKeys(result) {
      var _a;
      if (result === void 0 || result === null || Array.isArray(result)) {
        return [];
      }
      return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
    }
    function merge(originalKeys, keysToAdd) {
      const set2 = new Set(originalKeys);
      keysToAdd.forEach((key) => {
        if (!set2.has(key)) {
          set2.add(key);
        }
      });
      return Array.from(set2);
    }
    function minus(originalKeys, keysToRemove) {
      const set2 = new Set(originalKeys);
      keysToRemove.forEach((key) => {
        if (set2.has(key)) {
          set2.delete(key);
        }
      });
      return Array.from(set2);
    }
    function isGroup(rawNode) {
      return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
    }
    function createIndexGetter(treeNodes) {
      const map2 = /* @__PURE__ */ new Map();
      treeNodes.forEach((treeNode, i) => {
        map2.set(treeNode.key, i);
      });
      return (key) => {
        var _a;
        return (_a = map2.get(key)) !== null && _a !== void 0 ? _a : null;
      };
    }
    class SubtreeNotLoadedError extends Error {
      constructor() {
        super();
        this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
      }
    }
    function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
      return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
    }
    function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
      const visitedKeys = /* @__PURE__ */ new Set();
      uncheckedKeys.forEach((uncheckedKey) => {
        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
        if (uncheckedTreeNode !== void 0) {
          let nodeCursor = uncheckedTreeNode.parent;
          while (nodeCursor !== null) {
            if (nodeCursor.disabled)
              break;
            if (visitedKeys.has(nodeCursor.key))
              break;
            else {
              visitedKeys.add(nodeCursor.key);
            }
            nodeCursor = nodeCursor.parent;
          }
        }
      });
      return visitedKeys;
    }
    function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
      const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
      const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
      const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
      const keysToRemove = [];
      extendedCheckedKeySet.forEach((key) => {
        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
          keysToRemove.push(key);
        }
      });
      keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
      return extendedCheckedKeySet;
    }
    function getCheckedKeys(options, treeMate) {
      const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
      if (!cascade) {
        if (keysToCheck !== void 0) {
          return {
            checkedKeys: merge(checkedKeys, keysToCheck),
            indeterminateKeys: Array.from(indeterminateKeys)
          };
        } else if (keysToUncheck !== void 0) {
          return {
            checkedKeys: minus(checkedKeys, keysToUncheck),
            indeterminateKeys: Array.from(indeterminateKeys)
          };
        } else {
          return {
            checkedKeys: Array.from(checkedKeys),
            indeterminateKeys: Array.from(indeterminateKeys)
          };
        }
      }
      const { levelTreeNodeMap } = treeMate;
      let extendedCheckedKeySet;
      if (keysToUncheck !== void 0) {
        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
      } else if (keysToCheck !== void 0) {
        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
      } else {
        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
      }
      const checkStrategyIsParent = checkStrategy === "parent";
      const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
      const syntheticCheckedKeySet = extendedCheckedKeySet;
      const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
      const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
      for (let level = maxLevel; level >= 0; level -= 1) {
        const levelIsZero = level === 0;
        const levelTreeNodes = levelTreeNodeMap.get(level);
        for (const levelTreeNode of levelTreeNodes) {
          if (levelTreeNode.isLeaf)
            continue;
          const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
          if (checkStrategyIsChild && shallowLoaded) {
            levelTreeNode.children.forEach((v) => {
              if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
                syntheticCheckedKeySet.delete(v.key);
              }
            });
          }
          if (levelTreeNode.disabled || !shallowLoaded) {
            continue;
          }
          let fullyChecked = true;
          let partialChecked = false;
          let allDisabled = true;
          for (const childNode of levelTreeNode.children) {
            const childKey = childNode.key;
            if (childNode.disabled)
              continue;
            if (allDisabled)
              allDisabled = false;
            if (syntheticCheckedKeySet.has(childKey)) {
              partialChecked = true;
            } else if (syntheticIndeterminateKeySet.has(childKey)) {
              partialChecked = true;
              fullyChecked = false;
              break;
            } else {
              fullyChecked = false;
              if (partialChecked) {
                break;
              }
            }
          }
          if (fullyChecked && !allDisabled) {
            if (checkStrategyIsParent) {
              levelTreeNode.children.forEach((v) => {
                if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
                  syntheticCheckedKeySet.delete(v.key);
                }
              });
            }
            syntheticCheckedKeySet.add(levelTreeNodeKey);
          } else if (partialChecked) {
            syntheticIndeterminateKeySet.add(levelTreeNodeKey);
          }
          if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
            syntheticCheckedKeySet.delete(levelTreeNodeKey);
          }
        }
      }
      return {
        checkedKeys: Array.from(syntheticCheckedKeySet),
        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
      };
    }
    function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
      const { treeNodeMap, getChildren } = treeMate;
      const visitedKeySet = /* @__PURE__ */ new Set();
      const extendedKeySet = new Set(checkedKeys);
      checkedKeys.forEach((checkedKey) => {
        const checkedTreeNode = treeNodeMap.get(checkedKey);
        if (checkedTreeNode !== void 0) {
          traverseWithCb(checkedTreeNode, (treeNode) => {
            if (treeNode.disabled) {
              return TRAVERSE_COMMAND.STOP;
            }
            const { key } = treeNode;
            if (visitedKeySet.has(key))
              return;
            visitedKeySet.add(key);
            extendedKeySet.add(key);
            if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
              if (isUnchecking) {
                return TRAVERSE_COMMAND.STOP;
              } else if (!allowNotLoaded) {
                throw new SubtreeNotLoadedError();
              }
            }
          });
        }
      });
      return extendedKeySet;
    }
    function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
      var _a;
      const treeNodeMap = treeMate.treeNodeMap;
      let treeNode = key === null || key === void 0 ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;
      const mergedPath = {
        keyPath: [],
        treeNodePath: [],
        treeNode
      };
      if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
        mergedPath.treeNode = null;
        return mergedPath;
      }
      while (treeNode) {
        if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
          mergedPath.treeNodePath.push(treeNode);
        }
        treeNode = treeNode.parent;
      }
      mergedPath.treeNodePath.reverse();
      if (!includeSelf)
        mergedPath.treeNodePath.pop();
      mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
      return mergedPath;
    }
    function getFirstAvailableNode(nodes) {
      if (nodes.length === 0)
        return null;
      const node = nodes[0];
      if (node.isGroup || node.ignored || node.disabled) {
        return node.getNext();
      }
      return node;
    }
    function rawGetNext(node, loop) {
      const sibs = node.siblings;
      const l = sibs.length;
      const { index } = node;
      if (loop) {
        return sibs[(index + 1) % l];
      } else {
        if (index === sibs.length - 1)
          return null;
        return sibs[index + 1];
      }
    }
    function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
      const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
      const getChildOptions = {
        reverse: dir === "prev"
      };
      let meet = false;
      let endNode = null;
      function traverse2(node) {
        if (node === null)
          return;
        if (node === fromNode) {
          if (!meet) {
            meet = true;
          } else if (!fromNode.disabled && !fromNode.isGroup) {
            endNode = fromNode;
            return;
          }
        } else {
          if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
            endNode = node;
            return;
          }
        }
        if (node.isGroup) {
          const child = getChild(node, getChildOptions);
          if (child !== null) {
            endNode = child;
          } else {
            traverse2(iterate(node, loop));
          }
        } else {
          const nextNode = iterate(node, false);
          if (nextNode !== null) {
            traverse2(nextNode);
          } else {
            const parent = rawGetParent(node);
            if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
              traverse2(iterate(parent, loop));
            } else if (loop) {
              traverse2(iterate(node, true));
            }
          }
        }
      }
      traverse2(fromNode);
      return endNode;
    }
    function rawGetPrev(node, loop) {
      const sibs = node.siblings;
      const l = sibs.length;
      const { index } = node;
      if (loop) {
        return sibs[(index - 1 + l) % l];
      } else {
        if (index === 0)
          return null;
        return sibs[index - 1];
      }
    }
    function rawGetParent(node) {
      return node.parent;
    }
    function getChild(node, options = {}) {
      const { reverse = false } = options;
      const { children } = node;
      if (children) {
        const { length } = children;
        const start = reverse ? length - 1 : 0;
        const end = reverse ? -1 : length;
        const delta = reverse ? -1 : 1;
        for (let i = start; i !== end; i += delta) {
          const child = children[i];
          if (!child.disabled && !child.ignored) {
            if (child.isGroup) {
              const childInGroup = getChild(child, options);
              if (childInGroup !== null)
                return childInGroup;
            } else {
              return child;
            }
          }
        }
      }
      return null;
    }
    const moveMethods = {
      getChild() {
        if (this.ignored)
          return null;
        return getChild(this);
      },
      getParent() {
        const { parent } = this;
        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
          return parent.getParent();
        }
        return parent;
      },
      getNext(options = {}) {
        return move(this, "next", options);
      },
      getPrev(options = {}) {
        return move(this, "prev", options);
      }
    };
    function flatten$1(treeNodes, expandedKeys) {
      const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
      const flattenedNodes = [];
      function traverse2(treeNodes2) {
        treeNodes2.forEach((treeNode) => {
          flattenedNodes.push(treeNode);
          if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
            return;
          if (treeNode.isGroup) {
            traverse2(treeNode.children);
          } else if (
            // normal non-leaf node
            expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
          ) {
            traverse2(treeNode.children);
          }
        });
      }
      traverse2(treeNodes);
      return flattenedNodes;
    }
    function contains(parent, child) {
      const parentKey = parent.key;
      while (child) {
        if (child.key === parentKey)
          return true;
        child = child.parent;
      }
      return false;
    }
    function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
      const treeNodes = [];
      rawNodes.forEach((rawNode, index) => {
        var _a;
        const treeNode = Object.create(nodeProto);
        treeNode.rawNode = rawNode;
        treeNode.siblings = treeNodes;
        treeNode.level = level;
        treeNode.index = index;
        treeNode.isFirstChild = index === 0;
        treeNode.isLastChild = index + 1 === rawNodes.length;
        treeNode.parent = parent;
        if (!treeNode.ignored) {
          const rawChildren = getChildren(rawNode);
          if (Array.isArray(rawChildren)) {
            treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
          }
        }
        treeNodes.push(treeNode);
        treeNodeMap.set(treeNode.key, treeNode);
        if (!levelTreeNodeMap.has(level))
          levelTreeNodeMap.set(level, []);
        (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
      });
      return treeNodes;
    }
    function createTreeMate(rawNodes, options = {}) {
      var _a;
      const treeNodeMap = /* @__PURE__ */ new Map();
      const levelTreeNodeMap = /* @__PURE__ */ new Map();
      const { getDisabled = isDisabled, getIgnored: getIgnored2 = isIgnored, getIsGroup: getIsGroup2 = isGroup, getKey = defaultGetKey } = options;
      const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;
      const getChildren = options.ignoreEmptyChildren ? (node) => {
        const children = _getChildren(node);
        if (Array.isArray(children)) {
          if (!children.length)
            return null;
          return children;
        }
        return children;
      } : _getChildren;
      const nodeProto = Object.assign({
        get key() {
          return getKey(this.rawNode);
        },
        get disabled() {
          return getDisabled(this.rawNode);
        },
        get isGroup() {
          return getIsGroup2(this.rawNode);
        },
        get isLeaf() {
          return isLeaf(this.rawNode, getChildren);
        },
        get shallowLoaded() {
          return isShallowLoaded(this.rawNode, getChildren);
        },
        get ignored() {
          return getIgnored2(this.rawNode);
        },
        contains(node) {
          return contains(this, node);
        }
      }, moveMethods);
      const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
      function getNode(key) {
        if (key === null || key === void 0)
          return null;
        const tmNode = treeNodeMap.get(key);
        if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
          return tmNode;
        }
        return null;
      }
      function _getNode(key) {
        if (key === null || key === void 0)
          return null;
        const tmNode = treeNodeMap.get(key);
        if (tmNode && !tmNode.ignored) {
          return tmNode;
        }
        return null;
      }
      function getPrev(key, options2) {
        const node = _getNode(key);
        if (!node)
          return null;
        return node.getPrev(options2);
      }
      function getNext(key, options2) {
        const node = _getNode(key);
        if (!node)
          return null;
        return node.getNext(options2);
      }
      function getParent(key) {
        const node = _getNode(key);
        if (!node)
          return null;
        return node.getParent();
      }
      function getChild2(key) {
        const node = _getNode(key);
        if (!node)
          return null;
        return node.getChild();
      }
      const treemate = {
        treeNodes,
        treeNodeMap,
        levelTreeNodeMap,
        maxLevel: Math.max(...levelTreeNodeMap.keys()),
        getChildren,
        getFlattenedNodes(expandedKeys) {
          return flatten$1(treeNodes, expandedKeys);
        },
        getNode,
        getPrev,
        getNext,
        getParent,
        getChild: getChild2,
        getFirstAvailableNode() {
          return getFirstAvailableNode(treeNodes);
        },
        getPath(key, options2 = {}) {
          return getPath(key, options2, treemate);
        },
        getCheckedKeys(checkedKeys, options2 = {}) {
          const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
          return getCheckedKeys({
            checkedKeys: unwrapCheckedKeys(checkedKeys),
            indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
            cascade,
            leafOnly,
            checkStrategy,
            allowNotLoaded
          }, treemate);
        },
        check(keysToCheck, checkedKeys, options2 = {}) {
          const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
          return getCheckedKeys({
            checkedKeys: unwrapCheckedKeys(checkedKeys),
            indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
            keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray(keysToCheck),
            cascade,
            leafOnly,
            checkStrategy,
            allowNotLoaded
          }, treemate);
        },
        uncheck(keysToUncheck, checkedKeys, options2 = {}) {
          const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
          return getCheckedKeys({
            checkedKeys: unwrapCheckedKeys(checkedKeys),
            indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
            keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray(keysToUncheck),
            cascade,
            leafOnly,
            checkStrategy,
            allowNotLoaded
          }, treemate);
        },
        getNonLeafKeys(options2 = {}) {
          return getNonLeafKeys(treeNodes, options2);
        }
      };
      return treemate;
    }
    const base = {
      neutralBase: "#FFF",
      neutralInvertBase: "#000",
      neutralTextBase: "#000",
      neutralPopover: "#fff",
      neutralCard: "#fff",
      neutralModal: "#fff",
      neutralBody: "#fff",
      alpha1: "0.82",
      alpha2: "0.72",
      alpha3: "0.38",
      alpha4: "0.24",
      alpha5: "0.18",
      alphaClose: "0.6",
      alphaDisabled: "0.5",
      alphaDisabledInput: "0.02",
      alphaPending: "0.05",
      alphaTablePending: "0.02",
      alphaPressed: "0.07",
      alphaAvatar: "0.2",
      alphaRail: "0.14",
      alphaProgressRail: ".08",
      alphaBorder: "0.12",
      alphaDivider: "0.06",
      alphaInput: "0",
      alphaAction: "0.02",
      alphaTab: "0.04",
      alphaScrollbar: "0.25",
      alphaScrollbarHover: "0.4",
      alphaCode: "0.05",
      alphaTag: "0.02",
      // primary
      primaryHover: "#36ad6a",
      primaryDefault: "#18a058",
      primaryActive: "#0c7a43",
      primarySuppl: "#36ad6a",
      // info
      infoHover: "#4098fc",
      infoDefault: "#2080f0",
      infoActive: "#1060c9",
      infoSuppl: "#4098fc",
      // error
      errorHover: "#de576d",
      errorDefault: "#d03050",
      errorActive: "#ab1f3f",
      errorSuppl: "#de576d",
      // warning
      warningHover: "#fcb040",
      warningDefault: "#f0a020",
      warningActive: "#c97c10",
      warningSuppl: "#fcb040",
      // success
      successHover: "#36ad6a",
      successDefault: "#18a058",
      successActive: "#0c7a43",
      successSuppl: "#36ad6a"
    };
    const baseBackgroundRgb = rgba(base.neutralBase);
    const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
    const overlayPrefix = "rgba(" + baseInvertBackgroundRgb.slice(0, 3).join(", ") + ", ";
    function overlay(alpha) {
      return overlayPrefix + String(alpha) + ")";
    }
    function neutral(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb, overlayRgba);
    }
    const derived = Object.assign(Object.assign({ name: "common" }, commonVariables$d), {
      baseColor: base.neutralBase,
      // primary color
      primaryColor: base.primaryDefault,
      primaryColorHover: base.primaryHover,
      primaryColorPressed: base.primaryActive,
      primaryColorSuppl: base.primarySuppl,
      // info color
      infoColor: base.infoDefault,
      infoColorHover: base.infoHover,
      infoColorPressed: base.infoActive,
      infoColorSuppl: base.infoSuppl,
      // success color
      successColor: base.successDefault,
      successColorHover: base.successHover,
      successColorPressed: base.successActive,
      successColorSuppl: base.successSuppl,
      // warning color
      warningColor: base.warningDefault,
      warningColorHover: base.warningHover,
      warningColorPressed: base.warningActive,
      warningColorSuppl: base.warningSuppl,
      // error color
      errorColor: base.errorDefault,
      errorColorHover: base.errorHover,
      errorColorPressed: base.errorActive,
      errorColorSuppl: base.errorSuppl,
      // text color
      textColorBase: base.neutralTextBase,
      textColor1: "rgb(31, 34, 37)",
      textColor2: "rgb(51, 54, 57)",
      textColor3: "rgb(118, 124, 130)",
      // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
      // textColor5: neutral(base.alpha5),
      textColorDisabled: neutral(base.alpha4),
      placeholderColor: neutral(base.alpha4),
      placeholderColorDisabled: neutral(base.alpha5),
      iconColor: neutral(base.alpha4),
      iconColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }),
      iconColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }),
      iconColorDisabled: neutral(base.alpha5),
      opacity1: base.alpha1,
      opacity2: base.alpha2,
      opacity3: base.alpha3,
      opacity4: base.alpha4,
      opacity5: base.alpha5,
      dividerColor: "rgb(239, 239, 245)",
      borderColor: "rgb(224, 224, 230)",
      // close
      closeIconColor: neutral(Number(base.alphaClose)),
      closeIconColorHover: neutral(Number(base.alphaClose)),
      closeIconColorPressed: neutral(Number(base.alphaClose)),
      closeColorHover: "rgba(0, 0, 0, .09)",
      closeColorPressed: "rgba(0, 0, 0, .13)",
      // clear
      clearColor: neutral(base.alpha4),
      clearColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }),
      clearColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }),
      scrollbarColor: overlay(base.alphaScrollbar),
      scrollbarColorHover: overlay(base.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: neutral(base.alphaProgressRail),
      railColor: "rgb(219, 219, 223)",
      popoverColor: base.neutralPopover,
      tableColor: base.neutralCard,
      cardColor: base.neutralCard,
      modalColor: base.neutralModal,
      bodyColor: base.neutralBody,
      tagColor: "#eee",
      avatarColor: neutral(base.alphaAvatar),
      invertedColor: "rgb(0, 20, 40)",
      inputColor: neutral(base.alphaInput),
      codeColor: "rgb(244, 244, 248)",
      tabColor: "rgb(247, 247, 250)",
      actionColor: "rgb(250, 250, 252)",
      tableHeaderColor: "rgb(250, 250, 252)",
      hoverColor: "rgb(243, 243, 245)",
      // use color with alpha since it can be nested with header filter & sorter effect
      tableColorHover: "rgba(0, 0, 100, 0.03)",
      tableColorStriped: "rgba(0, 0, 100, 0.02)",
      pressedColor: "rgb(237, 237, 239)",
      opacityDisabled: base.alphaDisabled,
      inputColorDisabled: "rgb(250, 250, 252)",
      // secondary button color
      // can also be used in tertiary button & quaternary button
      buttonColor2: "rgba(46, 51, 56, .05)",
      buttonColor2Hover: "rgba(46, 51, 56, .09)",
      buttonColor2Pressed: "rgba(46, 51, 56, .13)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const commonLight = derived;
    const commonVars$2 = {
      iconSizeSmall: "34px",
      iconSizeMedium: "40px",
      iconSizeLarge: "46px",
      iconSizeHuge: "52px"
    };
    const self$l = (vars) => {
      const { textColorDisabled, iconColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge } = vars;
      return Object.assign(Object.assign({}, commonVars$2), {
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        textColor: textColorDisabled,
        iconColor,
        extraTextColor: textColor2
      });
    };
    const emptyLight = {
      name: "Empty",
      common: commonLight,
      self: self$l
    };
    const emptyLight$1 = emptyLight;
    const style$p = cB("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [cE("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [c$1("+", [cE("description", `
 margin-top: 8px;
 `)])]), cE("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]);
    const emptyProps = Object.assign(Object.assign({}, useTheme.props), { description: String, showDescription: {
      type: Boolean,
      default: true
    }, showIcon: {
      type: Boolean,
      default: true
    }, size: {
      type: String,
      default: "medium"
    }, renderIcon: Function });
    const NEmpty = defineComponent({
      name: "Empty",
      props: emptyProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Empty", "-empty", style$p, emptyLight$1, props, mergedClsPrefixRef);
        const { localeRef } = useLocale("Empty");
        const NConfigProvider = inject(configProviderInjectionKey, null);
        const mergedDescriptionRef = computed(() => {
          var _a, _b, _c;
          return (_a = props.description) !== null && _a !== void 0 ? _a : (_c = (_b = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _b === void 0 ? void 0 : _b.Empty) === null || _c === void 0 ? void 0 : _c.description;
        });
        const mergedRenderIconRef = computed(() => {
          var _a, _b;
          return ((_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Empty) === null || _b === void 0 ? void 0 : _b.renderIcon) || (() => h(EmptyIcon, null));
        });
        const cssVarsRef = computed(() => {
          const { size: size2 } = props;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { [createKey("iconSize", size2)]: iconSize, [createKey("fontSize", size2)]: fontSize2, textColor, iconColor, extraTextColor } } = themeRef.value;
          return {
            "--n-icon-size": iconSize,
            "--n-font-size": fontSize2,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-text-color": textColor,
            "--n-icon-color": iconColor,
            "--n-extra-text-color": extraTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("empty", computed(() => {
          let hash = "";
          const { size: size2 } = props;
          hash += size2[0];
          return hash;
        }), cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedRenderIcon: mergedRenderIconRef,
          localizedDescription: computed(() => {
            return mergedDescriptionRef.value || localeRef.value.description;
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { $slots, mergedClsPrefix, onRender } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h(
          "div",
          { class: [`${mergedClsPrefix}-empty`, this.themeClass], style: this.cssVars },
          this.showIcon ? h("div", { class: `${mergedClsPrefix}-empty__icon` }, $slots.icon ? $slots.icon() : h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: this.mergedRenderIcon })) : null,
          this.showDescription ? h("div", { class: `${mergedClsPrefix}-empty__description` }, $slots.default ? $slots.default() : this.localizedDescription) : null,
          $slots.extra ? h("div", { class: `${mergedClsPrefix}-empty__extra` }, $slots.extra()) : null
        );
      }
    });
    const self$k = (vars) => {
      const { scrollbarColor, scrollbarColorHover } = vars;
      return {
        color: scrollbarColor,
        colorHover: scrollbarColorHover
      };
    };
    const scrollbarLight = {
      name: "Scrollbar",
      common: commonLight,
      self: self$k
    };
    const scrollbarLight$1 = scrollbarLight;
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$2
    } = commonVariables$d;
    function fadeInTransition({
      name = "fade-in",
      enterDuration = "0.2s",
      leaveDuration = "0.2s",
      enterCubicBezier = cubicBezierEaseInOut$2,
      leaveCubicBezier = cubicBezierEaseInOut$2
    } = {}) {
      return [c$1(`&.${name}-transition-enter-active`, {
        transition: `all ${enterDuration} ${enterCubicBezier}!important`
      }), c$1(`&.${name}-transition-leave-active`, {
        transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
      }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0
      }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
        opacity: 1
      })];
    }
    const style$o = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 -webkit-user-select: none;
 `, [cM("horizontal", `
 left: 2px;
 right: 2px;
 bottom: 4px;
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("vertical", `
 right: 4px;
 top: 2px;
 bottom: 2px;
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("disabled", [c$1(">", [cE("scrollbar", {
      pointerEvents: "none"
    })])]), c$1(">", [cE("scrollbar", `
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", {
      backgroundColor: "var(--n-scrollbar-color-hover)"
    })])])])])]);
    const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
      size: {
        type: Number,
        default: 5
      },
      duration: {
        type: Number,
        default: 0
      },
      scrollable: {
        type: Boolean,
        default: true
      },
      xScrollable: Boolean,
      trigger: {
        type: String,
        default: "hover"
      },
      useUnifiedContainer: Boolean,
      triggerDisplayManually: Boolean,
      // If container is set, resize observer won't not attached
      container: Function,
      content: Function,
      containerClass: String,
      containerStyle: [String, Object],
      contentClass: String,
      contentStyle: [String, Object],
      horizontalRailStyle: [String, Object],
      verticalRailStyle: [String, Object],
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      internalOnUpdateScrollLeft: Function,
      internalHoistYRail: Boolean
    });
    const Scrollbar = defineComponent({
      name: "Scrollbar",
      props: scrollbarProps,
      inheritAttrs: false,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
        const wrapperRef = ref(null);
        const containerRef = ref(null);
        const contentRef = ref(null);
        const yRailRef = ref(null);
        const xRailRef = ref(null);
        const contentHeightRef = ref(null);
        const contentWidthRef = ref(null);
        const containerHeightRef = ref(null);
        const containerWidthRef = ref(null);
        const yRailSizeRef = ref(null);
        const xRailSizeRef = ref(null);
        const containerScrollTopRef = ref(0);
        const containerScrollLeftRef = ref(0);
        const isShowXBarRef = ref(false);
        const isShowYBarRef = ref(false);
        let yBarPressed = false;
        let xBarPressed = false;
        let xBarVanishTimerId;
        let yBarVanishTimerId;
        let memoYTop = 0;
        let memoXLeft = 0;
        let memoMouseX = 0;
        let memoMouseY = 0;
        const isIos2 = useIsIos();
        const yBarSizeRef = computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yRailSize } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + props.size * 1.5);
          }
        });
        const yBarSizePxRef = computed(() => {
          return `${yBarSizeRef.value}px`;
        });
        const xBarSizeRef = computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xRailSize } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            return xRailSize * containerWidth / contentWidth + props.size * 1.5;
          }
        });
        const xBarSizePxRef = computed(() => {
          return `${xBarSizeRef.value}px`;
        });
        const yBarTopRef = computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: containerScrollTop } = containerScrollTopRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yRailSize } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            const heightDiff = contentHeight - containerHeight;
            if (!heightDiff)
              return 0;
            return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
          }
        });
        const yBarTopPxRef = computed(() => {
          return `${yBarTopRef.value}px`;
        });
        const xBarLeftRef = computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: containerScrollLeft } = containerScrollLeftRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xRailSize } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            const widthDiff = contentWidth - containerWidth;
            if (!widthDiff)
              return 0;
            return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
          }
        });
        const xBarLeftPxRef = computed(() => {
          return `${xBarLeftRef.value}px`;
        });
        const needYBarRef = computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
        });
        const needXBarRef = computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
        });
        const mergedShowXBarRef = computed(() => {
          const { trigger: trigger2 } = props;
          return trigger2 === "none" || isShowXBarRef.value;
        });
        const mergedShowYBarRef = computed(() => {
          const { trigger: trigger2 } = props;
          return trigger2 === "none" || isShowYBarRef.value;
        });
        const mergedContainerRef = computed(() => {
          const { container } = props;
          if (container)
            return container();
          return containerRef.value;
        });
        const mergedContentRef = computed(() => {
          const { content } = props;
          if (content)
            return content();
          return contentRef.value;
        });
        const activateState = useReactivated(() => {
          if (!props.container) {
            scrollTo({
              top: containerScrollTopRef.value,
              left: containerScrollLeftRef.value
            });
          }
        });
        const handleContentResize = () => {
          if (activateState.isDeactivated)
            return;
          sync();
        };
        const handleContainerResize = (e) => {
          if (activateState.isDeactivated)
            return;
          const { onResize } = props;
          if (onResize)
            onResize(e);
          sync();
        };
        const scrollTo = (options, y) => {
          if (!props.scrollable)
            return;
          if (typeof options === "number") {
            scrollToPosition(y !== null && y !== void 0 ? y : 0, options, 0, false, "auto");
            return;
          }
          const { left, top, index, elSize, position, behavior, el, debounce: debounce2 = true } = options;
          if (left !== void 0 || top !== void 0) {
            scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
          }
          if (el !== void 0) {
            scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce2, behavior);
          } else if (index !== void 0 && elSize !== void 0) {
            scrollToPosition(0, index * elSize, elSize, debounce2, behavior);
          } else if (position === "bottom") {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
          } else if (position === "top") {
            scrollToPosition(0, 0, 0, false, behavior);
          }
        };
        const scrollBy = (options, y) => {
          if (!props.scrollable)
            return;
          const { value: container } = mergedContainerRef;
          if (!container)
            return;
          if (typeof options === "object") {
            container.scrollBy(options);
          } else {
            container.scrollBy(options, y || 0);
          }
        };
        function scrollToPosition(left, top, elSize, debounce2, behavior) {
          const { value: container } = mergedContainerRef;
          if (!container)
            return;
          if (debounce2) {
            const { scrollTop, offsetHeight } = container;
            if (top > scrollTop) {
              if (top + elSize <= scrollTop + offsetHeight)
                ;
              else {
                container.scrollTo({
                  left,
                  top: top + elSize - offsetHeight,
                  behavior
                });
              }
              return;
            }
          }
          container.scrollTo({
            left,
            top,
            behavior
          });
        }
        function handleMouseEnterWrapper() {
          showXBar();
          showYBar();
          sync();
        }
        function handleMouseLeaveWrapper() {
          hideBar();
        }
        function hideBar() {
          hideYBar();
          hideXBar();
        }
        function hideYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          yBarVanishTimerId = window.setTimeout(() => {
            isShowYBarRef.value = false;
          }, props.duration);
        }
        function hideXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          xBarVanishTimerId = window.setTimeout(() => {
            isShowXBarRef.value = false;
          }, props.duration);
        }
        function showXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          isShowXBarRef.value = true;
        }
        function showYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          isShowYBarRef.value = true;
        }
        function handleScroll(e) {
          const { onScroll } = props;
          if (onScroll)
            onScroll(e);
          syncScrollState();
        }
        function syncScrollState() {
          const { value: container } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          }
        }
        function syncPositionState() {
          const { value: content } = mergedContentRef;
          if (content) {
            contentHeightRef.value = content.offsetHeight;
            contentWidthRef.value = content.offsetWidth;
          }
          const { value: container } = mergedContainerRef;
          if (container) {
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
          }
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function syncUnifiedContainer() {
          const { value: container } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
            contentHeightRef.value = container.scrollHeight;
            contentWidthRef.value = container.scrollWidth;
          }
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function sync() {
          if (!props.scrollable)
            return;
          if (props.useUnifiedContainer) {
            syncUnifiedContainer();
          } else {
            syncPositionState();
            syncScrollState();
          }
        }
        function isMouseUpAway(e) {
          var _a;
          return !((_a = wrapperRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)));
        }
        function handleXScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          xBarPressed = true;
          on("mousemove", window, handleXScrollMouseMove, true);
          on("mouseup", window, handleXScrollMouseUp, true);
          memoXLeft = containerScrollLeftRef.value;
          memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
        }
        function handleXScrollMouseMove(e) {
          if (!xBarPressed)
            return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xBarSize } = xBarSizeRef;
          if (containerWidth === null || contentWidth === null)
            return;
          const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
          const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
          const toScrollLeftUpperBound = contentWidth - containerWidth;
          let toScrollLeft = memoXLeft + dScrollLeft;
          toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
          toScrollLeft = Math.max(toScrollLeft, 0);
          const { value: container } = mergedContainerRef;
          if (container) {
            container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            const { internalOnUpdateScrollLeft } = props;
            if (internalOnUpdateScrollLeft)
              internalOnUpdateScrollLeft(toScrollLeft);
          }
        }
        function handleXScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleXScrollMouseMove, true);
          off("mouseup", window, handleXScrollMouseUp, true);
          xBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        function handleYScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          yBarPressed = true;
          on("mousemove", window, handleYScrollMouseMove, true);
          on("mouseup", window, handleYScrollMouseUp, true);
          memoYTop = containerScrollTopRef.value;
          memoMouseY = e.clientY;
        }
        function handleYScrollMouseMove(e) {
          if (!yBarPressed)
            return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yBarSize } = yBarSizeRef;
          if (containerHeight === null || contentHeight === null)
            return;
          const dY = e.clientY - memoMouseY;
          const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
          const toScrollTopUpperBound = contentHeight - containerHeight;
          let toScrollTop = memoYTop + dScrollTop;
          toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
          toScrollTop = Math.max(toScrollTop, 0);
          const { value: container } = mergedContainerRef;
          if (container) {
            container.scrollTop = toScrollTop;
          }
        }
        function handleYScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
          yBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        watchEffect(() => {
          const { value: needXBar } = needXBarRef;
          const { value: needYBar } = needYBarRef;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            if (!needXBar) {
              xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
          if (yRailEl) {
            if (!needYBar) {
              yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
        });
        onMounted(() => {
          if (props.container)
            return;
          sync();
        });
        onBeforeUnmount(() => {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
        });
        const themeRef = useTheme("Scrollbar", "-scrollbar", style$o, scrollbarLight$1, props, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, scrollbarBorderRadius, scrollbarHeight, scrollbarWidth }, self: { color, colorHover } } = themeRef.value;
          return {
            "--n-scrollbar-bezier": cubicBezierEaseInOut2,
            "--n-scrollbar-color": color,
            "--n-scrollbar-color-hover": colorHover,
            "--n-scrollbar-border-radius": scrollbarBorderRadius,
            "--n-scrollbar-width": scrollbarWidth,
            "--n-scrollbar-height": scrollbarHeight
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
        const exposedMethods = {
          scrollTo,
          scrollBy,
          sync,
          syncUnifiedContainer,
          handleMouseEnterWrapper,
          handleMouseLeaveWrapper
        };
        return Object.assign(Object.assign({}, exposedMethods), {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          containerScrollTop: containerScrollTopRef,
          wrapperRef,
          containerRef,
          contentRef,
          yRailRef,
          xRailRef,
          needYBar: needYBarRef,
          needXBar: needXBarRef,
          yBarSizePx: yBarSizePxRef,
          xBarSizePx: xBarSizePxRef,
          yBarTopPx: yBarTopPxRef,
          xBarLeftPx: xBarLeftPxRef,
          isShowXBar: mergedShowXBarRef,
          isShowYBar: mergedShowYBarRef,
          isIos: isIos2,
          handleScroll,
          handleContentResize,
          handleContainerResize,
          handleYScrollMouseDown,
          handleXScrollMouseDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a;
        const { $slots, mergedClsPrefix, triggerDisplayManually, rtlEnabled, internalHoistYRail } = this;
        if (!this.scrollable)
          return (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
        const triggerIsNone = this.trigger === "none";
        const createYRail = () => {
          return h("div", { ref: "yRailRef", class: [
            `${mergedClsPrefix}-scrollbar-rail`,
            `${mergedClsPrefix}-scrollbar-rail--vertical`
          ], "data-scrollbar-rail": true, style: this.verticalRailStyle, "aria-hidden": true }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
            default: () => this.needYBar && this.isShowYBar && !this.isIos ? h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
              height: this.yBarSizePx,
              top: this.yBarTopPx
            }, onMousedown: this.handleYScrollMouseDown }) : null
          }));
        };
        const createChildren = () => {
          var _a2, _b;
          (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
          return h("div", mergeProps(this.$attrs, {
            role: "none",
            ref: "wrapperRef",
            class: [
              `${mergedClsPrefix}-scrollbar`,
              this.themeClass,
              rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`
            ],
            style: this.cssVars,
            onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
            onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
          }), [
            this.container ? (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots) : h(
              "div",
              { role: "none", ref: "containerRef", class: [
                `${mergedClsPrefix}-scrollbar-container`,
                this.containerClass
              ], style: this.containerStyle, onScroll: this.handleScroll, onWheel: this.onWheel },
              h(VResizeObserver, { onResize: this.handleContentResize }, {
                default: () => h("div", { ref: "contentRef", role: "none", style: [
                  {
                    width: this.xScrollable ? "fit-content" : null
                  },
                  this.contentStyle
                ], class: [
                  `${mergedClsPrefix}-scrollbar-content`,
                  this.contentClass
                ] }, $slots)
              })
            ),
            internalHoistYRail ? null : createYRail(),
            this.xScrollable && h("div", { ref: "xRailRef", class: [
              `${mergedClsPrefix}-scrollbar-rail`,
              `${mergedClsPrefix}-scrollbar-rail--horizontal`
            ], style: this.horizontalRailStyle, "data-scrollbar-rail": true, "aria-hidden": true }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
              default: () => this.needXBar && this.isShowXBar && !this.isIos ? h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                width: this.xBarSizePx,
                right: rtlEnabled ? this.xBarLeftPx : void 0,
                left: rtlEnabled ? void 0 : this.xBarLeftPx
              }, onMousedown: this.handleXScrollMouseDown }) : null
            }))
          ]);
        };
        const scrollbarNode = this.container ? createChildren() : h(VResizeObserver, { onResize: this.handleContainerResize }, {
          default: createChildren
        });
        if (internalHoistYRail) {
          return h(
            Fragment,
            null,
            scrollbarNode,
            createYRail()
          );
        } else {
          return scrollbarNode;
        }
      }
    });
    const NScrollbar = Scrollbar;
    const XScrollbar = Scrollbar;
    const commonVariables$c = {
      height: "calc(var(--n-option-height) * 7.6)",
      paddingSmall: "4px 0",
      paddingMedium: "4px 0",
      paddingLarge: "4px 0",
      paddingHuge: "4px 0",
      optionPaddingSmall: "0 12px",
      optionPaddingMedium: "0 12px",
      optionPaddingLarge: "0 12px",
      optionPaddingHuge: "0 12px",
      loadingSize: "18px"
    };
    const self$j = (vars) => {
      const { borderRadius, popoverColor, textColor3, dividerColor, textColor2, primaryColorPressed, textColorDisabled, primaryColor, opacityDisabled, hoverColor, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge } = vars;
      return Object.assign(Object.assign({}, commonVariables$c), { optionFontSizeSmall: fontSizeSmall, optionFontSizeMedium: fontSizeMedium, optionFontSizeLarge: fontSizeLarge, optionFontSizeHuge: fontSizeHuge, optionHeightSmall: heightSmall, optionHeightMedium: heightMedium, optionHeightLarge: heightLarge, optionHeightHuge: heightHuge, borderRadius, color: popoverColor, groupHeaderTextColor: textColor3, actionDividerColor: dividerColor, optionTextColor: textColor2, optionTextColorPressed: primaryColorPressed, optionTextColorDisabled: textColorDisabled, optionTextColorActive: primaryColor, optionOpacityDisabled: opacityDisabled, optionCheckColor: primaryColor, optionColorPending: hoverColor, optionColorActive: "rgba(0, 0, 0, 0)", optionColorActivePending: hoverColor, actionTextColor: textColor2, loadingColor: primaryColor });
    };
    const internalSelectMenuLight = createTheme({
      name: "InternalSelectMenu",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1,
        Empty: emptyLight$1
      },
      self: self$j
    });
    const internalSelectMenuLight$1 = internalSelectMenuLight;
    function renderCheckMark(show, clsPrefix) {
      return h(Transition, { name: "fade-in-scale-up-transition" }, {
        default: () => show ? h(NBaseIcon, { clsPrefix, class: `${clsPrefix}-base-select-option__check` }, {
          default: () => h(FinishedIcon)
        }) : null
      });
    }
    const NSelectOption = defineComponent({
      name: "NBaseSelectOption",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const {
          valueRef,
          pendingTmNodeRef,
          multipleRef,
          valueSetRef,
          renderLabelRef,
          renderOptionRef,
          labelFieldRef,
          valueFieldRef,
          showCheckmarkRef,
          nodePropsRef,
          handleOptionClick,
          handleOptionMouseEnter
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(internalSelectionMenuInjectionKey);
        const isPendingRef = useMemo(() => {
          const { value: pendingTmNode } = pendingTmNodeRef;
          if (!pendingTmNode)
            return false;
          return props.tmNode.key === pendingTmNode.key;
        });
        function handleClick(e) {
          const { tmNode } = props;
          if (tmNode.disabled)
            return;
          handleOptionClick(e, tmNode);
        }
        function handleMouseEnter(e) {
          const { tmNode } = props;
          if (tmNode.disabled)
            return;
          handleOptionMouseEnter(e, tmNode);
        }
        function handleMouseMove(e) {
          const { tmNode } = props;
          const { value: isPending } = isPendingRef;
          if (tmNode.disabled || isPending)
            return;
          handleOptionMouseEnter(e, tmNode);
        }
        return {
          multiple: multipleRef,
          isGrouped: useMemo(() => {
            const { tmNode } = props;
            const { parent } = tmNode;
            return parent && parent.rawNode.type === "group";
          }),
          showCheckmark: showCheckmarkRef,
          nodeProps: nodePropsRef,
          isPending: isPendingRef,
          isSelected: useMemo(() => {
            const { value } = valueRef;
            const { value: multiple } = multipleRef;
            if (value === null)
              return false;
            const optionValue = props.tmNode.rawNode[valueFieldRef.value];
            if (multiple) {
              const { value: valueSet } = valueSetRef;
              return valueSet.has(optionValue);
            } else {
              return value === optionValue;
            }
          }),
          labelField: labelFieldRef,
          renderLabel: renderLabelRef,
          renderOption: renderOptionRef,
          handleMouseMove,
          handleMouseEnter,
          handleClick
        };
      },
      render() {
        const { clsPrefix, tmNode: { rawNode }, isSelected, isPending, isGrouped, showCheckmark, nodeProps, renderOption, renderLabel, handleClick, handleMouseEnter, handleMouseMove } = this;
        const checkmark = renderCheckMark(isSelected, clsPrefix);
        const children = renderLabel ? [renderLabel(rawNode, isSelected), showCheckmark && checkmark] : [
          render$1(rawNode[this.labelField], rawNode, isSelected),
          showCheckmark && checkmark
        ];
        const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
        const node = h(
          "div",
          Object.assign({}, attrs, { class: [
            `${clsPrefix}-base-select-option`,
            rawNode.class,
            attrs === null || attrs === void 0 ? void 0 : attrs.class,
            {
              [`${clsPrefix}-base-select-option--disabled`]: rawNode.disabled,
              [`${clsPrefix}-base-select-option--selected`]: isSelected,
              [`${clsPrefix}-base-select-option--grouped`]: isGrouped,
              [`${clsPrefix}-base-select-option--pending`]: isPending,
              [`${clsPrefix}-base-select-option--show-checkmark`]: showCheckmark
            }
          ], style: [(attrs === null || attrs === void 0 ? void 0 : attrs.style) || "", rawNode.style || ""], onClick: mergeEventHandlers([handleClick, attrs === null || attrs === void 0 ? void 0 : attrs.onClick]), onMouseenter: mergeEventHandlers([
            handleMouseEnter,
            attrs === null || attrs === void 0 ? void 0 : attrs.onMouseenter
          ]), onMousemove: mergeEventHandlers([handleMouseMove, attrs === null || attrs === void 0 ? void 0 : attrs.onMousemove]) }),
          h("div", { class: `${clsPrefix}-base-select-option__content` }, children)
        );
        return rawNode.render ? rawNode.render({ node, option: rawNode, selected: isSelected }) : renderOption ? renderOption({ node, option: rawNode, selected: isSelected }) : node;
      }
    });
    const NSelectGroupHeader = defineComponent({
      name: "NBaseSelectGroupHeader",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup() {
        const {
          renderLabelRef,
          renderOptionRef,
          labelFieldRef,
          nodePropsRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(internalSelectionMenuInjectionKey);
        return {
          labelField: labelFieldRef,
          nodeProps: nodePropsRef,
          renderLabel: renderLabelRef,
          renderOption: renderOptionRef
        };
      },
      render() {
        const { clsPrefix, renderLabel, renderOption, nodeProps, tmNode: { rawNode } } = this;
        const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
        const children = renderLabel ? renderLabel(rawNode, false) : render$1(rawNode[this.labelField], rawNode, false);
        const node = h("div", Object.assign({}, attrs, { class: [`${clsPrefix}-base-select-group-header`, attrs === null || attrs === void 0 ? void 0 : attrs.class] }), children);
        return rawNode.render ? rawNode.render({ node, option: rawNode }) : renderOption ? renderOption({ node, option: rawNode, selected: false }) : node;
      }
    });
    const {
      cubicBezierEaseIn,
      cubicBezierEaseOut
    } = commonVariables$d;
    function fadeInScaleUpTransition({
      transformOrigin = "inherit",
      duration = ".2s",
      enterScale = ".9",
      originalTransform = "",
      originalTransition = ""
    } = {}) {
      return [c$1("&.fade-in-scale-up-transition-leave-active", {
        transformOrigin,
        transition: `opacity ${duration} ${cubicBezierEaseIn}, transform ${duration} ${cubicBezierEaseIn} ${originalTransition && "," + originalTransition}`
      }), c$1("&.fade-in-scale-up-transition-enter-active", {
        transformOrigin,
        transition: `opacity ${duration} ${cubicBezierEaseOut}, transform ${duration} ${cubicBezierEaseOut} ${originalTransition && "," + originalTransition}`
      }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
        opacity: 0,
        transform: `${originalTransform} scale(${enterScale})`
      }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
        opacity: 1,
        transform: `${originalTransform} scale(1)`
      })];
    }
    const style$n = cB("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [cB("scrollbar", `
 max-height: var(--n-height);
 `), cB("virtual-list", `
 max-height: var(--n-height);
 `), cB("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [cE("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), cB("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), cB("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), cE("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), cE("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cB("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), cB("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [cM("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), c$1("&:active", `
 color: var(--n-option-text-color-pressed);
 `), cM("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), cM("selected", `
 color: var(--n-option-text-color-active);
 `, [c$1("&::before", `
 background-color: var(--n-option-color-active);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cNotM("selected", `
 color: var(--n-option-text-color-disabled);
 `), cM("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), cE("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [fadeInScaleUpTransition({
      enterScale: "0.5"
    })])])]);
    const NInternalSelectMenu = defineComponent({
      name: "InternalSelectMenu",
      props: Object.assign(Object.assign({}, useTheme.props), {
        clsPrefix: {
          type: String,
          required: true
        },
        scrollable: {
          type: Boolean,
          default: true
        },
        treeMate: {
          type: Object,
          required: true
        },
        multiple: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        value: {
          type: [String, Number, Array],
          default: null
        },
        autoPending: Boolean,
        virtualScroll: {
          type: Boolean,
          default: true
        },
        // show is used to toggle pending state initialization
        show: {
          type: Boolean,
          default: true
        },
        labelField: {
          type: String,
          default: "label"
        },
        valueField: {
          type: String,
          default: "value"
        },
        loading: Boolean,
        focusable: Boolean,
        renderLabel: Function,
        renderOption: Function,
        nodeProps: Function,
        showCheckmark: { type: Boolean, default: true },
        onMousedown: Function,
        onScroll: Function,
        onFocus: Function,
        onBlur: Function,
        onKeyup: Function,
        onKeydown: Function,
        onTabOut: Function,
        onMouseenter: Function,
        onMouseleave: Function,
        onResize: Function,
        resetMenuOnOptionsChange: {
          type: Boolean,
          default: true
        },
        inlineThemeDisabled: Boolean,
        // deprecated
        onToggle: Function
      }),
      setup(props) {
        const themeRef = useTheme("InternalSelectMenu", "-internal-select-menu", style$n, internalSelectMenuLight$1, props, toRef(props, "clsPrefix"));
        const selfRef = ref(null);
        const virtualListRef = ref(null);
        const scrollbarRef = ref(null);
        const flattenedNodesRef = computed(() => props.treeMate.getFlattenedNodes());
        const fIndexGetterRef = computed(() => createIndexGetter(flattenedNodesRef.value));
        const pendingNodeRef = ref(null);
        function initPendingNode() {
          const { treeMate } = props;
          let defaultPendingNode = null;
          const { value } = props;
          if (value === null) {
            defaultPendingNode = treeMate.getFirstAvailableNode();
          } else {
            if (props.multiple) {
              defaultPendingNode = treeMate.getNode((value || [])[(value || []).length - 1]);
            } else {
              defaultPendingNode = treeMate.getNode(value);
            }
            if (!defaultPendingNode || defaultPendingNode.disabled) {
              defaultPendingNode = treeMate.getFirstAvailableNode();
            }
          }
          if (defaultPendingNode) {
            setPendingTmNode(defaultPendingNode);
          } else {
            setPendingTmNode(null);
          }
        }
        function clearPendingNodeIfInvalid() {
          const { value: pendingNode } = pendingNodeRef;
          if (pendingNode && !props.treeMate.getNode(pendingNode.key)) {
            pendingNodeRef.value = null;
          }
        }
        let initPendingNodeWatchStopHandle;
        watch(() => props.show, (show) => {
          if (show) {
            initPendingNodeWatchStopHandle = watch(() => props.treeMate, () => {
              if (props.resetMenuOnOptionsChange) {
                if (props.autoPending) {
                  initPendingNode();
                } else {
                  clearPendingNodeIfInvalid();
                }
                void nextTick(scrollToPendingNode);
              } else {
                clearPendingNodeIfInvalid();
              }
            }, {
              immediate: true
            });
          } else {
            initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
          }
        }, {
          immediate: true
        });
        onBeforeUnmount(() => {
          initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
        });
        const itemSizeRef = computed(() => {
          return depx(themeRef.value.self[createKey("optionHeight", props.size)]);
        });
        const paddingRef = computed(() => {
          return getMargin(themeRef.value.self[createKey("padding", props.size)]);
        });
        const valueSetRef = computed(() => {
          if (props.multiple && Array.isArray(props.value)) {
            return new Set(props.value);
          }
          return /* @__PURE__ */ new Set();
        });
        const emptyRef = computed(() => {
          const tmNodes = flattenedNodesRef.value;
          return tmNodes && tmNodes.length === 0;
        });
        function doToggle(tmNode) {
          const { onToggle } = props;
          if (onToggle)
            onToggle(tmNode);
        }
        function doScroll(e) {
          const { onScroll } = props;
          if (onScroll)
            onScroll(e);
        }
        function handleVirtualListScroll(e) {
          var _a;
          (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          doScroll(e);
        }
        function handleVirtualListResize() {
          var _a;
          (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
        }
        function getPendingTmNode() {
          const { value: pendingTmNode } = pendingNodeRef;
          if (pendingTmNode)
            return pendingTmNode;
          return null;
        }
        function handleOptionMouseEnter(e, tmNode) {
          if (tmNode.disabled)
            return;
          setPendingTmNode(tmNode, false);
        }
        function handleOptionClick(e, tmNode) {
          if (tmNode.disabled)
            return;
          doToggle(tmNode);
        }
        function handleKeyUp(e) {
          var _a;
          if (happensIn(e, "action"))
            return;
          (_a = props.onKeyup) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
        function handleKeyDown(e) {
          var _a;
          if (happensIn(e, "action"))
            return;
          (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
        function handleMouseDown(e) {
          var _a;
          (_a = props.onMousedown) === null || _a === void 0 ? void 0 : _a.call(props, e);
          if (props.focusable)
            return;
          e.preventDefault();
        }
        function next() {
          const { value: pendingTmNode } = pendingNodeRef;
          if (pendingTmNode) {
            setPendingTmNode(pendingTmNode.getNext({ loop: true }), true);
          }
        }
        function prev() {
          const { value: pendingTmNode } = pendingNodeRef;
          if (pendingTmNode) {
            setPendingTmNode(pendingTmNode.getPrev({ loop: true }), true);
          }
        }
        function setPendingTmNode(tmNode, doScroll2 = false) {
          pendingNodeRef.value = tmNode;
          if (doScroll2)
            scrollToPendingNode();
        }
        function scrollToPendingNode() {
          var _a, _b;
          const tmNode = pendingNodeRef.value;
          if (!tmNode)
            return;
          const fIndex = fIndexGetterRef.value(tmNode.key);
          if (fIndex === null)
            return;
          if (props.virtualScroll) {
            (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ index: fIndex });
          } else {
            (_b = scrollbarRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
              index: fIndex,
              elSize: itemSizeRef.value
            });
          }
        }
        function handleFocusin(e) {
          var _a, _b;
          if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
            (_b = props.onFocus) === null || _b === void 0 ? void 0 : _b.call(props, e);
          }
        }
        function handleFocusout(e) {
          var _a, _b;
          if (!((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
            (_b = props.onBlur) === null || _b === void 0 ? void 0 : _b.call(props, e);
          }
        }
        provide(internalSelectionMenuInjectionKey, {
          handleOptionMouseEnter,
          handleOptionClick,
          valueSetRef,
          pendingTmNodeRef: pendingNodeRef,
          nodePropsRef: toRef(props, "nodeProps"),
          showCheckmarkRef: toRef(props, "showCheckmark"),
          multipleRef: toRef(props, "multiple"),
          valueRef: toRef(props, "value"),
          renderLabelRef: toRef(props, "renderLabel"),
          renderOptionRef: toRef(props, "renderOption"),
          labelFieldRef: toRef(props, "labelField"),
          valueFieldRef: toRef(props, "valueField")
        });
        provide(internalSelectionMenuBodyInjectionKey, selfRef);
        onMounted(() => {
          const { value } = scrollbarRef;
          if (value)
            value.sync();
        });
        const cssVarsRef = computed(() => {
          const { size: size2 } = props;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { height, borderRadius, color, groupHeaderTextColor, actionDividerColor, optionTextColorPressed, optionTextColor, optionTextColorDisabled, optionTextColorActive, optionOpacityDisabled, optionCheckColor, actionTextColor, optionColorPending, optionColorActive, loadingColor, loadingSize, optionColorActivePending, [createKey("optionFontSize", size2)]: fontSize2, [createKey("optionHeight", size2)]: optionHeight, [createKey("optionPadding", size2)]: optionPadding } } = themeRef.value;
          return {
            "--n-height": height,
            "--n-action-divider-color": actionDividerColor,
            "--n-action-text-color": actionTextColor,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-border-radius": borderRadius,
            "--n-color": color,
            "--n-option-font-size": fontSize2,
            "--n-group-header-text-color": groupHeaderTextColor,
            "--n-option-check-color": optionCheckColor,
            "--n-option-color-pending": optionColorPending,
            "--n-option-color-active": optionColorActive,
            "--n-option-color-active-pending": optionColorActivePending,
            "--n-option-height": optionHeight,
            "--n-option-opacity-disabled": optionOpacityDisabled,
            "--n-option-text-color": optionTextColor,
            "--n-option-text-color-active": optionTextColorActive,
            "--n-option-text-color-disabled": optionTextColorDisabled,
            "--n-option-text-color-pressed": optionTextColorPressed,
            "--n-option-padding": optionPadding,
            "--n-option-padding-left": getMargin(optionPadding, "left"),
            "--n-option-padding-right": getMargin(optionPadding, "right"),
            "--n-loading-color": loadingColor,
            "--n-loading-size": loadingSize
          };
        });
        const { inlineThemeDisabled } = props;
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-select-menu", computed(() => props.size[0]), cssVarsRef, props) : void 0;
        const exposedProps = {
          selfRef,
          next,
          prev,
          getPendingTmNode
        };
        useOnResize(selfRef, props.onResize);
        return Object.assign({
          mergedTheme: themeRef,
          virtualListRef,
          scrollbarRef,
          itemSize: itemSizeRef,
          padding: paddingRef,
          flattenedNodes: flattenedNodesRef,
          empty: emptyRef,
          virtualListContainer() {
            const { value } = virtualListRef;
            return value === null || value === void 0 ? void 0 : value.listElRef;
          },
          virtualListContent() {
            const { value } = virtualListRef;
            return value === null || value === void 0 ? void 0 : value.itemsElRef;
          },
          doScroll,
          handleFocusin,
          handleFocusout,
          handleKeyUp,
          handleKeyDown,
          handleMouseDown,
          handleVirtualListResize,
          handleVirtualListScroll,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        }, exposedProps);
      },
      render() {
        const { $slots, virtualScroll, clsPrefix, mergedTheme, themeClass, onRender } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h(
          "div",
          { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [
            `${clsPrefix}-base-select-menu`,
            themeClass,
            this.multiple && `${clsPrefix}-base-select-menu--multiple`
          ], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave },
          this.loading ? h(
            "div",
            { class: `${clsPrefix}-base-select-menu__loading` },
            h(NBaseLoading, { clsPrefix, strokeWidth: 20 })
          ) : !this.empty ? h(NScrollbar, { ref: "scrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, scrollable: this.scrollable, container: virtualScroll ? this.virtualListContainer : void 0, content: virtualScroll ? this.virtualListContent : void 0, onScroll: virtualScroll ? void 0 : this.doScroll }, {
            default: () => {
              return virtualScroll ? h(VVirtualList, { ref: "virtualListRef", class: `${clsPrefix}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, {
                default: ({ item: tmNode }) => {
                  return tmNode.isGroup ? h(NSelectGroupHeader, { key: tmNode.key, clsPrefix, tmNode }) : tmNode.ignored ? null : h(NSelectOption, { clsPrefix, key: tmNode.key, tmNode });
                }
              }) : h("div", { class: `${clsPrefix}-base-select-menu-option-wrapper`, style: {
                paddingTop: this.padding.top,
                paddingBottom: this.padding.bottom
              } }, this.flattenedNodes.map((tmNode) => tmNode.isGroup ? h(NSelectGroupHeader, { key: tmNode.key, clsPrefix, tmNode }) : h(NSelectOption, { clsPrefix, key: tmNode.key, tmNode })));
            }
          }) : h("div", { class: `${clsPrefix}-base-select-menu__empty`, "data-empty": true }, resolveSlot($slots.empty, () => [
            h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
          ])),
          resolveWrappedSlot($slots.action, (children) => children && [
            h("div", { class: `${clsPrefix}-base-select-menu__action`, "data-action": true, key: "action" }, children),
            h(FocusDetector, { onFocus: this.onTabOut, key: "focus-detector" })
          ])
        );
      }
    });
    const style$m = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
    const NBaseWave = defineComponent({
      name: "BaseWave",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-wave", style$m, toRef(props, "clsPrefix"));
        const selfRef = ref(null);
        const activeRef = ref(false);
        let animationTimerId = null;
        onBeforeUnmount(() => {
          if (animationTimerId !== null) {
            window.clearTimeout(animationTimerId);
          }
        });
        return {
          active: activeRef,
          selfRef,
          play() {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
              activeRef.value = false;
              animationTimerId = null;
            }
            void nextTick(() => {
              var _a;
              void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight);
              activeRef.value = true;
              animationTimerId = window.setTimeout(() => {
                activeRef.value = false;
                animationTimerId = null;
              }, 1e3);
            });
          }
        };
      },
      render() {
        const { clsPrefix } = this;
        return h("div", { ref: "selfRef", "aria-hidden": true, class: [
          `${clsPrefix}-base-wave`,
          this.active && `${clsPrefix}-base-wave--active`
        ] });
      }
    });
    const commonVariables$b = {
      space: "6px",
      spaceArrow: "10px",
      arrowOffset: "10px",
      arrowOffsetVertical: "10px",
      arrowHeight: "6px",
      padding: "8px 14px"
    };
    const self$i = (vars) => {
      const { boxShadow2, popoverColor, textColor2, borderRadius, fontSize: fontSize2, dividerColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$b), {
        fontSize: fontSize2,
        borderRadius,
        color: popoverColor,
        dividerColor,
        textColor: textColor2,
        boxShadow: boxShadow2
      });
    };
    const popoverLight = {
      name: "Popover",
      common: commonLight,
      self: self$i
    };
    const popoverLight$1 = popoverLight;
    const oppositePlacement = {
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    };
    const arrowSize = "var(--n-arrow-height) * 1.414";
    const style$l = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
      cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
      // body transition
      c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
      c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
      c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
      c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
    ]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map({
      top: ["right-start", "left-start"],
      right: ["top-end", "bottom-end"],
      bottom: ["right-end", "left-end"],
      left: ["top-start", "bottom-start"]
    }, (placements, direction) => {
      const isVertical = ["right", "left"].includes(direction);
      const sizeType = isVertical ? "width" : "height";
      return placements.map((placement) => {
        const isReverse = placement.split("-")[1] === "end";
        const targetSize = `var(--v-target-${sizeType}, 0px)`;
        const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
        const offset = getArrowOffset(placement);
        return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
      });
    })]);
    function getArrowOffset(placement) {
      return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
    }
    function placementStyle(placement, arrowStyleLiteral) {
      const position = placement.split("-")[0];
      const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
      return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
    }
    const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
      to: useAdjustedTo.propTo,
      show: Boolean,
      trigger: String,
      showArrow: Boolean,
      delay: Number,
      duration: Number,
      raw: Boolean,
      arrowPointToCenter: Boolean,
      arrowStyle: [String, Object],
      displayDirective: String,
      x: Number,
      y: Number,
      flip: Boolean,
      overlap: Boolean,
      placement: String,
      width: [Number, String],
      keepAliveOnHover: Boolean,
      scrollable: Boolean,
      contentStyle: [Object, String],
      headerStyle: [Object, String],
      footerStyle: [Object, String],
      // private
      internalDeactivateImmediately: Boolean,
      animated: Boolean,
      onClickoutside: Function,
      internalTrapFocus: Boolean,
      internalOnAfterLeave: Function,
      // deprecated
      minWidth: Number,
      maxWidth: Number
    });
    const renderArrow = ({ arrowStyle, clsPrefix }) => {
      return h(
        "div",
        { key: "__popover-arrow__", class: `${clsPrefix}-popover-arrow-wrapper` },
        h("div", { class: `${clsPrefix}-popover-arrow`, style: arrowStyle })
      );
    };
    const NPopoverBody = defineComponent({
      name: "PopoverBody",
      inheritAttrs: false,
      props: popoverBodyProps,
      setup(props, { slots, attrs }) {
        const { namespaceRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Popover", "-popover", style$l, popoverLight$1, props, mergedClsPrefixRef);
        const followerRef = ref(null);
        const NPopover2 = inject("NPopover");
        const bodyRef = ref(null);
        const followerEnabledRef = ref(props.show);
        const displayedRef = ref(false);
        watchEffect(() => {
          const { show } = props;
          if (show && !isJsdom() && !props.internalDeactivateImmediately) {
            displayedRef.value = true;
          }
        });
        const directivesRef = computed(() => {
          const { trigger: trigger2, onClickoutside } = props;
          const directives = [];
          const { positionManuallyRef: { value: positionManually } } = NPopover2;
          if (!positionManually) {
            if (trigger2 === "click" && !onClickoutside) {
              directives.push([
                clickoutside$1,
                handleClickOutside,
                void 0,
                { capture: true }
              ]);
            }
            if (trigger2 === "hover") {
              directives.push([mousemoveoutside$1, handleMouseMoveOutside]);
            }
          }
          if (onClickoutside) {
            directives.push([
              clickoutside$1,
              handleClickOutside,
              void 0,
              { capture: true }
            ]);
          }
          if (props.displayDirective === "show" || props.animated && displayedRef.value) {
            directives.push([vShow, props.show]);
          }
          return directives;
        });
        const styleRef = computed(() => {
          const width = props.width === "trigger" ? void 0 : formatLength(props.width);
          const style2 = [];
          if (width) {
            style2.push({ width });
          }
          const { maxWidth, minWidth } = props;
          if (maxWidth) {
            style2.push({ maxWidth: formatLength(maxWidth) });
          }
          if (minWidth) {
            style2.push({ maxWidth: formatLength(minWidth) });
          }
          if (!inlineThemeDisabled) {
            style2.push(cssVarsRef.value);
          }
          return style2;
        });
        const cssVarsRef = computed(() => {
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseIn: cubicBezierEaseIn2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: { space, spaceArrow, padding, fontSize: fontSize2, textColor, dividerColor, color, boxShadow, borderRadius, arrowHeight, arrowOffset, arrowOffsetVertical } } = themeRef.value;
          return {
            "--n-box-shadow": boxShadow,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-ease-in": cubicBezierEaseIn2,
            "--n-bezier-ease-out": cubicBezierEaseOut2,
            "--n-font-size": fontSize2,
            "--n-text-color": textColor,
            "--n-color": color,
            "--n-divider-color": dividerColor,
            "--n-border-radius": borderRadius,
            "--n-arrow-height": arrowHeight,
            "--n-arrow-offset": arrowOffset,
            "--n-arrow-offset-vertical": arrowOffsetVertical,
            "--n-padding": padding,
            "--n-space": space,
            "--n-space-arrow": spaceArrow
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
        NPopover2.setBodyInstance({
          syncPosition
        });
        onBeforeUnmount(() => {
          NPopover2.setBodyInstance(null);
        });
        watch(toRef(props, "show"), (value) => {
          if (props.animated)
            return;
          if (value) {
            followerEnabledRef.value = true;
          } else {
            followerEnabledRef.value = false;
          }
        });
        function syncPosition() {
          var _a;
          (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
        }
        function handleMouseEnter(e) {
          if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
            NPopover2.handleMouseEnter(e);
          }
        }
        function handleMouseLeave(e) {
          if (props.trigger === "hover" && props.keepAliveOnHover) {
            NPopover2.handleMouseLeave(e);
          }
        }
        function handleMouseMoveOutside(e) {
          if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
            NPopover2.handleMouseMoveOutside(e);
          }
        }
        function handleClickOutside(e) {
          if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
            NPopover2.handleClickOutside(e);
          }
        }
        function getTriggerElement() {
          return NPopover2.getTriggerElement();
        }
        provide(popoverBodyInjectionKey, bodyRef);
        provide(drawerBodyInjectionKey, null);
        provide(modalBodyInjectionKey, null);
        function renderContentNode() {
          themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
          const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
          if (!shouldRenderDom) {
            return null;
          }
          let contentNode;
          const renderBody = NPopover2.internalRenderBodyRef.value;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          if (!renderBody) {
            const { value: extraClass } = NPopover2.extraClassRef;
            const { internalTrapFocus } = props;
            const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
            const renderContentInnerNode = () => {
              var _a;
              const body = hasHeaderOrFooter ? h(
                Fragment,
                null,
                resolveWrappedSlot(slots.header, (children) => {
                  return children ? h("div", { class: `${mergedClsPrefix}-popover__header`, style: props.headerStyle }, children) : null;
                }),
                resolveWrappedSlot(slots.default, (children) => {
                  return children ? h("div", { class: `${mergedClsPrefix}-popover__content`, style: props.contentStyle }, slots) : null;
                }),
                resolveWrappedSlot(slots.footer, (children) => {
                  return children ? h("div", { class: `${mergedClsPrefix}-popover__footer`, style: props.footerStyle }, children) : null;
                })
              ) : props.scrollable ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots) : h("div", { class: `${mergedClsPrefix}-popover__content`, style: props.contentStyle }, slots);
              const maybeScrollableBody = props.scrollable ? h(XScrollbar, { contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content`, contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle }, {
                default: () => body
              }) : body;
              const arrow = props.showArrow ? renderArrow({
                arrowStyle: props.arrowStyle,
                clsPrefix: mergedClsPrefix
              }) : null;
              return [maybeScrollableBody, arrow];
            };
            contentNode = h("div", mergeProps({
              class: [
                `${mergedClsPrefix}-popover`,
                `${mergedClsPrefix}-popover-shared`,
                themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
                extraClass.map((v) => `${mergedClsPrefix}-${v}`),
                {
                  [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
                  [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
                  [`${mergedClsPrefix}-popover--raw`]: props.raw,
                  [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
                  [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
                  [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
                }
              ],
              ref: bodyRef,
              style: styleRef.value,
              onKeydown: NPopover2.handleKeydown,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }, attrs), internalTrapFocus ? h(FocusTrap, { active: props.show, autoFocus: true }, { default: renderContentInnerNode }) : renderContentInnerNode());
          } else {
            contentNode = renderBody(
              // The popover class and overlap class must exists, they will be used
              // to place the body & transition animation.
              // Shadow class exists for reuse box-shadow.
              [
                `${mergedClsPrefix}-popover-shared`,
                themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
                props.overlap && `${mergedClsPrefix}-popover-shared--overlap`,
                props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`,
                props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`
              ],
              bodyRef,
              styleRef.value,
              handleMouseEnter,
              handleMouseLeave
            );
          }
          return withDirectives(contentNode, directivesRef.value);
        }
        return {
          displayed: displayedRef,
          namespace: namespaceRef,
          isMounted: NPopover2.isMountedRef,
          zIndex: NPopover2.zIndexRef,
          followerRef,
          adjustedTo: useAdjustedTo(props),
          followerEnabled: followerEnabledRef,
          renderContentNode
        };
      },
      render() {
        return h(VFollower, { ref: "followerRef", zIndex: this.zIndex, show: this.show, enabled: this.followerEnabled, to: this.adjustedTo, x: this.x, y: this.y, flip: this.flip, placement: this.placement, containerClass: this.namespace, overlap: this.overlap, width: this.width === "trigger" ? "target" : void 0, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
          default: () => {
            return this.animated ? h(Transition, {
              name: "popover-transition",
              appear: this.isMounted,
              // Don't use watch to enable follower, since the transition may
              // make position sync timing very subtle and buggy.
              onEnter: () => {
                this.followerEnabled = true;
              },
              onAfterLeave: () => {
                var _a;
                (_a = this.internalOnAfterLeave) === null || _a === void 0 ? void 0 : _a.call(this);
                this.followerEnabled = false;
                this.displayed = false;
              }
            }, {
              default: this.renderContentNode
            }) : this.renderContentNode();
          }
        });
      }
    });
    const bodyPropKeys = Object.keys(popoverBodyProps);
    const triggerEventMap = {
      focus: ["onFocus", "onBlur"],
      click: ["onClick"],
      hover: ["onMouseenter", "onMouseleave"],
      manual: [],
      nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
    };
    function appendEvents(vNode, trigger2, events2) {
      triggerEventMap[trigger2].forEach((eventName) => {
        if (!vNode.props)
          vNode.props = {};
        else {
          vNode.props = Object.assign({}, vNode.props);
        }
        const originalHandler = vNode.props[eventName];
        const handler = events2[eventName];
        if (!originalHandler)
          vNode.props[eventName] = handler;
        else {
          vNode.props[eventName] = (...args) => {
            originalHandler(...args);
            handler(...args);
          };
        }
      });
    }
    const textVNodeType = createTextVNode("").type;
    const popoverBaseProps = {
      show: {
        type: Boolean,
        default: void 0
      },
      defaultShow: Boolean,
      showArrow: {
        type: Boolean,
        default: true
      },
      trigger: {
        type: String,
        default: "hover"
      },
      delay: {
        type: Number,
        default: 100
      },
      duration: {
        type: Number,
        default: 100
      },
      raw: Boolean,
      placement: {
        type: String,
        default: "top"
      },
      x: Number,
      y: Number,
      arrowPointToCenter: Boolean,
      disabled: Boolean,
      getDisabled: Function,
      displayDirective: {
        type: String,
        default: "if"
      },
      arrowStyle: [String, Object],
      flip: {
        type: Boolean,
        default: true
      },
      animated: {
        type: Boolean,
        default: true
      },
      width: {
        type: [Number, String],
        default: void 0
      },
      overlap: Boolean,
      keepAliveOnHover: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      to: useAdjustedTo.propTo,
      scrollable: Boolean,
      contentStyle: [Object, String],
      headerStyle: [Object, String],
      footerStyle: [Object, String],
      // events
      onClickoutside: Function,
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      // internal
      internalDeactivateImmediately: Boolean,
      internalSyncTargetWithParent: Boolean,
      internalInheritedEventHandlers: {
        type: Array,
        default: () => []
      },
      internalTrapFocus: Boolean,
      internalExtraClass: {
        type: Array,
        default: () => []
      },
      // deprecated
      onShow: [Function, Array],
      onHide: [Function, Array],
      arrow: {
        type: Boolean,
        default: void 0
      },
      minWidth: Number,
      maxWidth: Number
    };
    const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), { internalOnAfterLeave: Function, internalRenderBody: Function });
    const NPopover = defineComponent({
      name: "Popover",
      inheritAttrs: false,
      props: popoverProps,
      __popover__: true,
      setup(props) {
        const isMountedRef = isMounted();
        const binderInstRef = ref(null);
        const controlledShowRef = computed(() => props.show);
        const uncontrolledShowRef = ref(props.defaultShow);
        const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const mergedShowConsideringDisabledPropRef = useMemo(() => {
          if (props.disabled)
            return false;
          return mergedShowWithoutDisabledRef.value;
        });
        const getMergedDisabled = () => {
          if (props.disabled)
            return true;
          const { getDisabled } = props;
          if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
            return true;
          return false;
        };
        const getMergedShow = () => {
          if (getMergedDisabled())
            return false;
          return mergedShowWithoutDisabledRef.value;
        };
        const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
        const mergedShowArrowRef = computed(() => {
          if (props.overlap)
            return false;
          return compatibleShowArrowRef.value;
        });
        let bodyInstance = null;
        const showTimerIdRef = ref(null);
        const hideTimerIdRef = ref(null);
        const positionManuallyRef = useMemo(() => {
          return props.x !== void 0 && props.y !== void 0;
        });
        function doUpdateShow(value) {
          const { "onUpdate:show": _onUpdateShow, onUpdateShow, onShow, onHide } = props;
          uncontrolledShowRef.value = value;
          if (_onUpdateShow) {
            call(_onUpdateShow, value);
          }
          if (onUpdateShow) {
            call(onUpdateShow, value);
          }
          if (value && onShow) {
            call(onShow, true);
          }
          if (value && onHide) {
            call(onHide, false);
          }
        }
        function syncPosition() {
          if (bodyInstance) {
            bodyInstance.syncPosition();
          }
        }
        function clearShowTimer() {
          const { value: showTimerId } = showTimerIdRef;
          if (showTimerId) {
            window.clearTimeout(showTimerId);
            showTimerIdRef.value = null;
          }
        }
        function clearHideTimer() {
          const { value: hideTimerId } = hideTimerIdRef;
          if (hideTimerId) {
            window.clearTimeout(hideTimerId);
            hideTimerIdRef.value = null;
          }
        }
        function handleFocus() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "focus" && !mergedDisabled) {
            if (getMergedShow())
              return;
            doUpdateShow(true);
          }
        }
        function handleBlur() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "focus" && !mergedDisabled) {
            if (!getMergedShow())
              return;
            doUpdateShow(false);
          }
        }
        function handleMouseEnter() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "hover" && !mergedDisabled) {
            clearHideTimer();
            if (showTimerIdRef.value !== null)
              return;
            if (getMergedShow())
              return;
            const delayCallback = () => {
              doUpdateShow(true);
              showTimerIdRef.value = null;
            };
            const { delay } = props;
            if (delay === 0) {
              delayCallback();
            } else {
              showTimerIdRef.value = window.setTimeout(delayCallback, delay);
            }
          }
        }
        function handleMouseLeave() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "hover" && !mergedDisabled) {
            clearShowTimer();
            if (hideTimerIdRef.value !== null)
              return;
            if (!getMergedShow())
              return;
            const delayedCallback = () => {
              doUpdateShow(false);
              hideTimerIdRef.value = null;
            };
            const { duration } = props;
            if (duration === 0) {
              delayedCallback();
            } else {
              hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
            }
          }
        }
        function handleMouseMoveOutside() {
          handleMouseLeave();
        }
        function handleClickOutside(e) {
          var _a;
          if (!getMergedShow())
            return;
          if (props.trigger === "click") {
            clearShowTimer();
            clearHideTimer();
            doUpdateShow(false);
          }
          (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
        function handleClick() {
          if (props.trigger === "click" && !getMergedDisabled()) {
            clearShowTimer();
            clearHideTimer();
            const nextShow = !getMergedShow();
            doUpdateShow(nextShow);
          }
        }
        function handleKeydown(e) {
          if (!props.internalTrapFocus)
            return;
          if (e.key === "Escape") {
            clearShowTimer();
            clearHideTimer();
            doUpdateShow(false);
          }
        }
        function setShow(value) {
          uncontrolledShowRef.value = value;
        }
        function getTriggerElement() {
          var _a;
          return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
        }
        function setBodyInstance(value) {
          bodyInstance = value;
        }
        provide("NPopover", {
          getTriggerElement,
          handleKeydown,
          handleMouseEnter,
          handleMouseLeave,
          handleClickOutside,
          handleMouseMoveOutside,
          setBodyInstance,
          positionManuallyRef,
          isMountedRef,
          zIndexRef: toRef(props, "zIndex"),
          extraClassRef: toRef(props, "internalExtraClass"),
          internalRenderBodyRef: toRef(props, "internalRenderBody")
        });
        watchEffect(() => {
          if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
            doUpdateShow(false);
          }
        });
        return {
          binderInstRef,
          positionManually: positionManuallyRef,
          mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
          // if to show popover body
          uncontrolledShow: uncontrolledShowRef,
          mergedShowArrow: mergedShowArrowRef,
          getMergedShow,
          setShow,
          handleClick,
          handleMouseEnter,
          handleMouseLeave,
          handleFocus,
          handleBlur,
          syncPosition
        };
      },
      render() {
        var _a;
        const { positionManually, $slots: slots } = this;
        let triggerVNode;
        let popoverInside = false;
        if (!positionManually) {
          if (slots.activator) {
            triggerVNode = getFirstSlotVNode(slots, "activator");
          } else {
            triggerVNode = getFirstSlotVNode(slots, "trigger");
          }
          if (triggerVNode) {
            triggerVNode = cloneVNode(triggerVNode);
            triggerVNode = triggerVNode.type === textVNodeType ? h("span", [triggerVNode]) : triggerVNode;
            const handlers = {
              onClick: this.handleClick,
              onMouseenter: this.handleMouseEnter,
              onMouseleave: this.handleMouseLeave,
              onFocus: this.handleFocus,
              onBlur: this.handleBlur
            };
            if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
              popoverInside = true;
              if (!triggerVNode.props) {
                triggerVNode.props = {
                  internalSyncTargetWithParent: true,
                  internalInheritedEventHandlers: []
                };
              }
              triggerVNode.props.internalSyncTargetWithParent = true;
              if (!triggerVNode.props.internalInheritedEventHandlers) {
                triggerVNode.props.internalInheritedEventHandlers = [handlers];
              } else {
                triggerVNode.props.internalInheritedEventHandlers = [
                  handlers,
                  ...triggerVNode.props.internalInheritedEventHandlers
                ];
              }
            } else {
              const { internalInheritedEventHandlers } = this;
              const ascendantAndCurrentHandlers = [
                handlers,
                ...internalInheritedEventHandlers
              ];
              const mergedHandlers = {
                onBlur: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onBlur(e);
                  });
                },
                onFocus: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onFocus(e);
                  });
                },
                onClick: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onClick(e);
                  });
                },
                onMouseenter: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onMouseenter(e);
                  });
                },
                onMouseleave: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onMouseleave(e);
                  });
                }
              };
              appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
            }
          }
        }
        return h(VBinder, { ref: "binderInstRef", syncTarget: !popoverInside, syncTargetWithParent: this.internalSyncTargetWithParent }, {
          default: () => {
            void this.mergedShowConsideringDisabledProp;
            const mergedShow = this.getMergedShow();
            return [
              this.internalTrapFocus && mergedShow ? withDirectives(h("div", { style: { position: "fixed", inset: 0 } }), [
                [
                  zindexable$1,
                  {
                    enabled: mergedShow,
                    zIndex: this.zIndex
                  }
                ]
              ]) : null,
              positionManually ? null : h(VTarget, null, {
                default: () => triggerVNode
              }),
              h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), { showArrow: this.mergedShowArrow, show: mergedShow })), {
                default: () => {
                  var _a2, _b;
                  return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
                },
                header: () => {
                  var _a2, _b;
                  return (_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2);
                },
                footer: () => {
                  var _a2, _b;
                  return (_b = (_a2 = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a2);
                }
              })
            ];
          }
        });
      }
    });
    const commonVariables$a = {
      closeIconSizeTiny: "12px",
      closeIconSizeSmall: "12px",
      closeIconSizeMedium: "14px",
      closeIconSizeLarge: "14px",
      closeSizeTiny: "16px",
      closeSizeSmall: "16px",
      closeSizeMedium: "18px",
      closeSizeLarge: "18px",
      padding: "0 7px",
      closeMargin: "0 0 0 4px",
      closeMarginRtl: "0 4px 0 0"
    };
    const self$h = (vars) => {
      const { textColor2, primaryColorHover, primaryColorPressed, primaryColor, infoColor, successColor, warningColor, errorColor, baseColor, borderColor, opacityDisabled, tagColor, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadiusSmall: borderRadius, fontSizeMini, fontSizeTiny, fontSizeSmall, fontSizeMedium, heightMini, heightTiny, heightSmall, heightMedium, closeColorHover, closeColorPressed, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVariables$a), {
        closeBorderRadius: borderRadius,
        heightTiny: heightMini,
        heightSmall: heightTiny,
        heightMedium: heightSmall,
        heightLarge: heightMedium,
        borderRadius,
        opacityDisabled,
        fontSizeTiny: fontSizeMini,
        fontSizeSmall: fontSizeTiny,
        fontSizeMedium: fontSizeSmall,
        fontSizeLarge: fontSizeMedium,
        fontWeightStrong,
        // checked
        textColorCheckable: textColor2,
        textColorHoverCheckable: textColor2,
        textColorPressedCheckable: textColor2,
        textColorChecked: baseColor,
        colorCheckable: "#0000",
        colorHoverCheckable: buttonColor2Hover,
        colorPressedCheckable: buttonColor2Pressed,
        colorChecked: primaryColor,
        colorCheckedHover: primaryColorHover,
        colorCheckedPressed: primaryColorPressed,
        // default
        border: `1px solid ${borderColor}`,
        textColor: textColor2,
        color: tagColor,
        colorBordered: "rgb(250, 250, 252)",
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        borderPrimary: `1px solid ${changeColor(primaryColor, { alpha: 0.3 })}`,
        textColorPrimary: primaryColor,
        colorPrimary: changeColor(primaryColor, { alpha: 0.12 }),
        colorBorderedPrimary: changeColor(primaryColor, { alpha: 0.1 }),
        closeIconColorPrimary: primaryColor,
        closeIconColorHoverPrimary: primaryColor,
        closeIconColorPressedPrimary: primaryColor,
        closeColorHoverPrimary: changeColor(primaryColor, { alpha: 0.12 }),
        closeColorPressedPrimary: changeColor(primaryColor, { alpha: 0.18 }),
        borderInfo: `1px solid ${changeColor(infoColor, { alpha: 0.3 })}`,
        textColorInfo: infoColor,
        colorInfo: changeColor(infoColor, { alpha: 0.12 }),
        colorBorderedInfo: changeColor(infoColor, { alpha: 0.1 }),
        closeIconColorInfo: infoColor,
        closeIconColorHoverInfo: infoColor,
        closeIconColorPressedInfo: infoColor,
        closeColorHoverInfo: changeColor(infoColor, { alpha: 0.12 }),
        closeColorPressedInfo: changeColor(infoColor, { alpha: 0.18 }),
        borderSuccess: `1px solid ${changeColor(successColor, { alpha: 0.3 })}`,
        textColorSuccess: successColor,
        colorSuccess: changeColor(successColor, { alpha: 0.12 }),
        colorBorderedSuccess: changeColor(successColor, { alpha: 0.1 }),
        closeIconColorSuccess: successColor,
        closeIconColorHoverSuccess: successColor,
        closeIconColorPressedSuccess: successColor,
        closeColorHoverSuccess: changeColor(successColor, { alpha: 0.12 }),
        closeColorPressedSuccess: changeColor(successColor, { alpha: 0.18 }),
        borderWarning: `1px solid ${changeColor(warningColor, { alpha: 0.35 })}`,
        textColorWarning: warningColor,
        colorWarning: changeColor(warningColor, { alpha: 0.15 }),
        colorBorderedWarning: changeColor(warningColor, { alpha: 0.12 }),
        closeIconColorWarning: warningColor,
        closeIconColorHoverWarning: warningColor,
        closeIconColorPressedWarning: warningColor,
        closeColorHoverWarning: changeColor(warningColor, { alpha: 0.12 }),
        closeColorPressedWarning: changeColor(warningColor, { alpha: 0.18 }),
        borderError: `1px solid ${changeColor(errorColor, { alpha: 0.23 })}`,
        textColorError: errorColor,
        colorError: changeColor(errorColor, { alpha: 0.1 }),
        colorBorderedError: changeColor(errorColor, { alpha: 0.08 }),
        closeIconColorError: errorColor,
        closeIconColorHoverError: errorColor,
        closeIconColorPressedError: errorColor,
        closeColorHoverError: changeColor(errorColor, { alpha: 0.12 }),
        closeColorPressedError: changeColor(errorColor, { alpha: 0.18 })
      });
    };
    const tagLight = {
      name: "Tag",
      common: commonLight,
      self: self$h
    };
    const tagLight$1 = tagLight;
    const commonProps = {
      color: Object,
      type: {
        type: String,
        default: "default"
      },
      round: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      closable: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      }
    };
    const style$k = cB("tag", `
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [cM("strong", `
 font-weight: var(--n-font-weight-strong);
 `), cE("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), cE("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), cE("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cM("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [cE("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), cE("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), cM("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), cM("icon, avatar", [cM("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), cM("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), cM("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-hover-checkable);", [cNotM("checked", "color: var(--n-text-color-hover-checkable);")]), c$1("&:active", "background-color: var(--n-color-pressed-checkable);", [cNotM("checked", "color: var(--n-text-color-pressed-checkable);")])]), cM("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-checked-hover);"), c$1("&:active", "background-color: var(--n-color-checked-pressed);")])])])]);
    const tagProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), {
      bordered: {
        type: Boolean,
        default: void 0
      },
      checked: Boolean,
      checkable: Boolean,
      strong: Boolean,
      triggerClickOnClose: Boolean,
      onClose: [Array, Function],
      onMouseenter: Function,
      onMouseleave: Function,
      "onUpdate:checked": Function,
      onUpdateChecked: Function,
      // private
      internalCloseFocusable: {
        type: Boolean,
        default: true
      },
      internalCloseIsButtonTag: {
        type: Boolean,
        default: true
      },
      // deprecated
      onCheckedChange: Function
    });
    const tagInjectionKey = createInjectionKey("n-tag");
    const NTag = defineComponent({
      name: "Tag",
      props: tagProps,
      setup(props) {
        const contentRef = ref(null);
        const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Tag", "-tag", style$k, tagLight$1, props, mergedClsPrefixRef);
        provide(tagInjectionKey, {
          roundRef: toRef(props, "round")
        });
        function handleClick(e) {
          if (!props.disabled) {
            if (props.checkable) {
              const { checked, onCheckedChange, onUpdateChecked, "onUpdate:checked": _onUpdateChecked } = props;
              if (onUpdateChecked)
                onUpdateChecked(!checked);
              if (_onUpdateChecked)
                _onUpdateChecked(!checked);
              if (onCheckedChange)
                onCheckedChange(!checked);
            }
          }
        }
        function handleCloseClick(e) {
          if (!props.triggerClickOnClose) {
            e.stopPropagation();
          }
          if (!props.disabled) {
            const { onClose } = props;
            if (onClose)
              call(onClose, e);
          }
        }
        const tagPublicMethods = {
          setTextContent(textContent) {
            const { value } = contentRef;
            if (value)
              value.textContent = textContent;
          }
        };
        const rtlEnabledRef = useRtl("Tag", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { type: type2, size: size2, color: { color, textColor } = {} } = props;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { padding, closeMargin, closeMarginRtl, borderRadius, opacityDisabled, textColorCheckable, textColorHoverCheckable, textColorPressedCheckable, textColorChecked, colorCheckable, colorHoverCheckable, colorPressedCheckable, colorChecked, colorCheckedHover, colorCheckedPressed, closeBorderRadius, fontWeightStrong, [createKey("colorBordered", type2)]: colorBordered, [createKey("closeSize", size2)]: closeSize, [createKey("closeIconSize", size2)]: closeIconSize, [createKey("fontSize", size2)]: fontSize2, [createKey("height", size2)]: height, [createKey("color", type2)]: typedColor, [createKey("textColor", type2)]: typeTextColor, [createKey("border", type2)]: border, [createKey("closeIconColor", type2)]: closeIconColor, [createKey("closeIconColorHover", type2)]: closeIconColorHover, [createKey("closeIconColorPressed", type2)]: closeIconColorPressed, [createKey("closeColorHover", type2)]: closeColorHover, [createKey("closeColorPressed", type2)]: closeColorPressed } } = themeRef.value;
          return {
            "--n-font-weight-strong": fontWeightStrong,
            "--n-avatar-size-override": `calc(${height} - 8px)`,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-border-radius": borderRadius,
            "--n-border": border,
            "--n-close-icon-size": closeIconSize,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-color-hover": closeColorHover,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-icon-color-disabled": closeIconColor,
            "--n-close-margin": closeMargin,
            "--n-close-margin-rtl": closeMarginRtl,
            "--n-close-size": closeSize,
            "--n-color": color || (mergedBorderedRef.value ? colorBordered : typedColor),
            "--n-color-checkable": colorCheckable,
            "--n-color-checked": colorChecked,
            "--n-color-checked-hover": colorCheckedHover,
            "--n-color-checked-pressed": colorCheckedPressed,
            "--n-color-hover-checkable": colorHoverCheckable,
            "--n-color-pressed-checkable": colorPressedCheckable,
            "--n-font-size": fontSize2,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled,
            "--n-padding": padding,
            "--n-text-color": textColor || typeTextColor,
            "--n-text-color-checkable": textColorCheckable,
            "--n-text-color-checked": textColorChecked,
            "--n-text-color-hover-checkable": textColorHoverCheckable,
            "--n-text-color-pressed-checkable": textColorPressedCheckable
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("tag", computed(() => {
          let hash = "";
          const { type: type2, size: size2, color: { color, textColor } = {} } = props;
          hash += type2[0];
          hash += size2[0];
          if (color) {
            hash += `a${color2Class(color)}`;
          }
          if (textColor) {
            hash += `b${color2Class(textColor)}`;
          }
          if (mergedBorderedRef.value) {
            hash += "c";
          }
          return hash;
        }), cssVarsRef, props) : void 0;
        return Object.assign(Object.assign({}, tagPublicMethods), {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          contentRef,
          mergedBordered: mergedBorderedRef,
          handleClick,
          handleCloseClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a, _b;
        const { mergedClsPrefix, rtlEnabled, closable, color: { borderColor } = {}, round, onRender, $slots } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const avatarNode = resolveWrappedSlot($slots.avatar, (children) => children && h("div", { class: `${mergedClsPrefix}-tag__avatar` }, children));
        const iconNode = resolveWrappedSlot($slots.icon, (children) => children && h("div", { class: `${mergedClsPrefix}-tag__icon` }, children));
        return h(
          "div",
          { class: [
            `${mergedClsPrefix}-tag`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-tag--rtl`]: rtlEnabled,
              [`${mergedClsPrefix}-tag--strong`]: this.strong,
              [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
              [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
              [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
              [`${mergedClsPrefix}-tag--round`]: round,
              [`${mergedClsPrefix}-tag--avatar`]: avatarNode,
              [`${mergedClsPrefix}-tag--icon`]: iconNode,
              [`${mergedClsPrefix}-tag--closable`]: closable
            }
          ], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave },
          iconNode || avatarNode,
          h("span", { class: `${mergedClsPrefix}-tag__content`, ref: "contentRef" }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)),
          !this.checkable && closable ? h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null,
          !this.checkable && this.mergedBordered ? h("div", { class: `${mergedClsPrefix}-tag__border`, style: { borderColor } }) : null
        );
      }
    });
    const style$j = cB("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [c$1(">", [cE("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [c$1("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), c$1("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), cE("placeholder", `
 display: flex;
 `), cE("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
      originalTransform: "translateX(-50%) translateY(-50%)",
      left: "50%",
      top: "50%"
    })])])]);
    const NBaseClear = defineComponent({
      name: "BaseClear",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        show: Boolean,
        onClear: Function
      },
      setup(props) {
        useStyle("-base-clear", style$j, toRef(props, "clsPrefix"));
        return {
          handleMouseDown(e) {
            e.preventDefault();
          }
        };
      },
      render() {
        const { clsPrefix } = this;
        return h(
          "div",
          { class: `${clsPrefix}-base-clear` },
          h(NIconSwitchTransition, null, {
            default: () => {
              var _a, _b;
              return this.show ? h("div", { key: "dismiss", class: `${clsPrefix}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, resolveSlot(this.$slots.icon, () => [
                h(NBaseIcon, { clsPrefix }, {
                  default: () => h(ClearIcon, null)
                })
              ])) : h("div", { key: "icon", class: `${clsPrefix}-base-clear__placeholder` }, (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
          })
        );
      }
    });
    const NBaseSuffix = defineComponent({
      name: "InternalSelectionSuffix",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        showArrow: {
          type: Boolean,
          default: void 0
        },
        showClear: {
          type: Boolean,
          default: void 0
        },
        loading: {
          type: Boolean,
          default: false
        },
        onClear: Function
      },
      setup(props, { slots }) {
        return () => {
          const { clsPrefix } = props;
          return h(NBaseLoading, { clsPrefix, class: `${clsPrefix}-base-suffix`, strokeWidth: 24, scale: 0.85, show: props.loading }, {
            default: () => props.showArrow ? h(NBaseClear, { clsPrefix, show: props.showClear, onClear: props.onClear }, {
              placeholder: () => h(NBaseIcon, { clsPrefix, class: `${clsPrefix}-base-suffix__arrow` }, {
                default: () => resolveSlot(slots.default, () => [
                  h(ChevronDownIcon, null)
                ])
              })
            }) : null
          });
        };
      }
    });
    const commonVars$1 = {
      paddingSingle: "0 26px 0 12px",
      paddingMultiple: "3px 26px 0 12px",
      clearSize: "16px",
      arrowSize: "16px"
    };
    const self$g = (vars) => {
      const { borderRadius, textColor2, textColorDisabled, inputColor, inputColorDisabled, primaryColor, primaryColorHover, warningColor, warningColorHover, errorColor, errorColorHover, borderColor, iconColor, iconColorDisabled, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge } = vars;
      return Object.assign(Object.assign({}, commonVars$1), {
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadius,
        // default
        textColor: textColor2,
        textColorDisabled,
        placeholderColor,
        placeholderColorDisabled,
        color: inputColor,
        colorDisabled: inputColorDisabled,
        colorActive: inputColor,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderActive: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        boxShadowHover: "none",
        boxShadowActive: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
        caretColor: primaryColor,
        arrowColor: iconColor,
        arrowColorDisabled: iconColorDisabled,
        loadingColor: primaryColor,
        // warning
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderActiveWarning: `1px solid ${warningColor}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        boxShadowHoverWarning: "none",
        boxShadowActiveWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
        boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
        colorActiveWarning: inputColor,
        caretColorWarning: warningColor,
        // error
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderActiveError: `1px solid ${errorColor}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        boxShadowHoverError: "none",
        boxShadowActiveError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
        boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
        colorActiveError: inputColor,
        caretColorError: errorColor,
        clearColor,
        clearColorHover,
        clearColorPressed
      });
    };
    const internalSelectionLight = createTheme({
      name: "InternalSelection",
      common: commonLight,
      peers: {
        Popover: popoverLight$1
      },
      self: self$g
    });
    const internalSelectionLight$1 = internalSelectionLight;
    const style$i = c$1([cB("base-selection", `
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cB("base-loading", `
 color: var(--n-loading-color);
 `), cB("base-selection-tags", "min-height: var(--n-height);"), cE("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cE("state-border", `
 z-index: 1;
 border-color: #0000;
 `), cB("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [cE("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), cB("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [cE("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cB("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [cE("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), cB("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [cB("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [cE("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), cE("render-label", `
 color: var(--n-text-color);
 `)]), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), cB("base-selection-label", "background-color: var(--n-color-active);"), cB("base-selection-tags", "background-color: var(--n-color-active);")])]), cM("disabled", "cursor: not-allowed;", [cE("arrow", `
 color: var(--n-arrow-color-disabled);
 `), cB("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cB("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), cE("render-label", `
 color: var(--n-text-color-disabled);
 `)]), cB("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), cB("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), cB("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [cE("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), cE("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((status) => cM(`${status}-status`, [cE("state-border", `border: var(--n-border-${status});`), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover-${status});
 border: var(--n-border-hover-${status});
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active-${status});
 border: var(--n-border-active-${status});
 `), cB("base-selection-label", `background-color: var(--n-color-active-${status});`), cB("base-selection-tags", `background-color: var(--n-color-active-${status});`)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))]), cB("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), cB("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [c$1("&:last-child", "padding-right: 0;"), cB("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [cE("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]);
    const NInternalSelection = defineComponent({
      name: "InternalSelection",
      props: Object.assign(Object.assign({}, useTheme.props), { clsPrefix: {
        type: String,
        required: true
      }, bordered: {
        type: Boolean,
        default: void 0
      }, active: Boolean, pattern: {
        type: String,
        default: ""
      }, placeholder: String, selectedOption: {
        type: Object,
        default: null
      }, selectedOptions: {
        type: Array,
        default: null
      }, labelField: { type: String, default: "label" }, valueField: {
        type: String,
        default: "value"
      }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: {
        type: String,
        default: "medium"
      }, loading: Boolean, autofocus: Boolean, showArrow: {
        type: Boolean,
        default: true
      }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }),
      setup(props) {
        const patternInputMirrorRef = ref(null);
        const patternInputRef = ref(null);
        const selfRef = ref(null);
        const multipleElRef = ref(null);
        const singleElRef = ref(null);
        const patternInputWrapperRef = ref(null);
        const counterRef = ref(null);
        const counterWrapperRef = ref(null);
        const overflowRef = ref(null);
        const inputTagElRef = ref(null);
        const showTagsPopoverRef = ref(false);
        const patternInputFocusedRef = ref(false);
        const hoverRef = ref(false);
        const themeRef = useTheme("InternalSelection", "-internal-selection", style$i, internalSelectionLight$1, props, toRef(props, "clsPrefix"));
        const mergedClearableRef = computed(() => {
          return props.clearable && !props.disabled && (hoverRef.value || props.active);
        });
        const filterablePlaceholderRef = computed(() => {
          return props.selectedOption ? props.renderTag ? props.renderTag({
            option: props.selectedOption,
            handleClose: () => {
            }
          }) : props.renderLabel ? props.renderLabel(props.selectedOption, true) : render$1(props.selectedOption[props.labelField], props.selectedOption, true) : props.placeholder;
        });
        const labelRef = computed(() => {
          const option = props.selectedOption;
          if (!option)
            return void 0;
          return option[props.labelField];
        });
        const selectedRef = computed(() => {
          if (props.multiple) {
            return !!(Array.isArray(props.selectedOptions) && props.selectedOptions.length);
          } else {
            return props.selectedOption !== null;
          }
        });
        function syncMirrorWidth() {
          var _a;
          const { value: patternInputMirrorEl } = patternInputMirrorRef;
          if (patternInputMirrorEl) {
            const { value: patternInputEl } = patternInputRef;
            if (patternInputEl) {
              patternInputEl.style.width = `${patternInputMirrorEl.offsetWidth}px`;
              if (props.maxTagCount !== "responsive") {
                (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync();
              }
            }
          }
        }
        function hideInputTag() {
          const { value: inputTagEl } = inputTagElRef;
          if (inputTagEl)
            inputTagEl.style.display = "none";
        }
        function showInputTag() {
          const { value: inputTagEl } = inputTagElRef;
          if (inputTagEl)
            inputTagEl.style.display = "inline-block";
        }
        watch(toRef(props, "active"), (value) => {
          if (!value)
            hideInputTag();
        });
        watch(toRef(props, "pattern"), () => {
          if (props.multiple) {
            void nextTick(syncMirrorWidth);
          }
        });
        function doFocus(e) {
          const { onFocus } = props;
          if (onFocus)
            onFocus(e);
        }
        function doBlur(e) {
          const { onBlur } = props;
          if (onBlur)
            onBlur(e);
        }
        function doDeleteOption(value) {
          const { onDeleteOption } = props;
          if (onDeleteOption)
            onDeleteOption(value);
        }
        function doClear(e) {
          const { onClear } = props;
          if (onClear)
            onClear(e);
        }
        function doPatternInput(value) {
          const { onPatternInput } = props;
          if (onPatternInput)
            onPatternInput(value);
        }
        function handleFocusin(e) {
          var _a;
          if (!e.relatedTarget || !((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
            doFocus(e);
          }
        }
        function handleFocusout(e) {
          var _a;
          if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
            return;
          doBlur(e);
        }
        function handleClear(e) {
          doClear(e);
        }
        function handleMouseEnter() {
          hoverRef.value = true;
        }
        function handleMouseLeave() {
          hoverRef.value = false;
        }
        function handleMouseDown(e) {
          if (!props.active || !props.filterable)
            return;
          if (e.target === patternInputRef.value)
            return;
          e.preventDefault();
        }
        function handleDeleteOption(option) {
          doDeleteOption(option);
        }
        function handlePatternKeyDown(e) {
          if (e.key === "Backspace" && !isComposingRef.value) {
            if (!props.pattern.length) {
              const { selectedOptions } = props;
              if (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.length) {
                handleDeleteOption(selectedOptions[selectedOptions.length - 1]);
              }
            }
          }
        }
        const isComposingRef = ref(false);
        let cachedInputEvent = null;
        function handlePatternInputInput(e) {
          const { value: patternInputMirrorEl } = patternInputMirrorRef;
          if (patternInputMirrorEl) {
            const inputText = e.target.value;
            patternInputMirrorEl.textContent = inputText;
            syncMirrorWidth();
          }
          if (props.ignoreComposition) {
            if (!isComposingRef.value) {
              doPatternInput(e);
            } else {
              cachedInputEvent = e;
            }
          } else {
            doPatternInput(e);
          }
        }
        function handleCompositionStart() {
          isComposingRef.value = true;
        }
        function handleCompositionEnd() {
          isComposingRef.value = false;
          if (props.ignoreComposition) {
            doPatternInput(cachedInputEvent);
          }
          cachedInputEvent = null;
        }
        function handlePatternInputFocus(e) {
          var _a;
          patternInputFocusedRef.value = true;
          (_a = props.onPatternFocus) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
        function handlePatternInputBlur(e) {
          var _a;
          patternInputFocusedRef.value = false;
          (_a = props.onPatternBlur) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
        function blur() {
          var _a, _b;
          if (props.filterable) {
            patternInputFocusedRef.value = false;
            (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            (_b = patternInputRef.value) === null || _b === void 0 ? void 0 : _b.blur();
          } else if (props.multiple) {
            const { value: multipleEl } = multipleElRef;
            multipleEl === null || multipleEl === void 0 ? void 0 : multipleEl.blur();
          } else {
            const { value: singleEl } = singleElRef;
            singleEl === null || singleEl === void 0 ? void 0 : singleEl.blur();
          }
        }
        function focus() {
          var _a, _b, _c;
          if (props.filterable) {
            patternInputFocusedRef.value = false;
            (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          } else if (props.multiple) {
            (_b = multipleElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
          } else {
            (_c = singleElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
          }
        }
        function focusInput() {
          const { value: patternInputEl } = patternInputRef;
          if (patternInputEl) {
            showInputTag();
            patternInputEl.focus();
          }
        }
        function blurInput() {
          const { value: patternInputEl } = patternInputRef;
          if (patternInputEl) {
            patternInputEl.blur();
          }
        }
        function updateCounter(count) {
          const { value } = counterRef;
          if (value) {
            value.setTextContent(`+${count}`);
          }
        }
        function getCounter() {
          const { value } = counterWrapperRef;
          return value;
        }
        function getTail() {
          return patternInputRef.value;
        }
        let enterTimerId = null;
        function clearEnterTimer() {
          if (enterTimerId !== null)
            window.clearTimeout(enterTimerId);
        }
        function handleMouseEnterCounter() {
          if (props.disabled || props.active)
            return;
          clearEnterTimer();
          enterTimerId = window.setTimeout(() => {
            if (selectedRef.value) {
              showTagsPopoverRef.value = true;
            }
          }, 100);
        }
        function handleMouseLeaveCounter() {
          clearEnterTimer();
        }
        function onPopoverUpdateShow(show) {
          if (!show) {
            clearEnterTimer();
            showTagsPopoverRef.value = false;
          }
        }
        watch(selectedRef, (value) => {
          if (!value) {
            showTagsPopoverRef.value = false;
          }
        });
        onMounted(() => {
          watchEffect(() => {
            const patternInputWrapperEl = patternInputWrapperRef.value;
            if (!patternInputWrapperEl)
              return;
            patternInputWrapperEl.tabIndex = props.disabled || patternInputFocusedRef.value ? -1 : 0;
          });
        });
        useOnResize(selfRef, props.onResize);
        const { inlineThemeDisabled } = props;
        const cssVarsRef = computed(() => {
          const { size: size2 } = props;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: {
            borderRadius,
            color,
            placeholderColor,
            textColor,
            paddingSingle,
            paddingMultiple,
            caretColor,
            colorDisabled,
            textColorDisabled,
            placeholderColorDisabled,
            colorActive,
            boxShadowFocus,
            boxShadowActive,
            boxShadowHover,
            border,
            borderFocus,
            borderHover,
            borderActive,
            arrowColor,
            arrowColorDisabled,
            loadingColor,
            // form warning
            colorActiveWarning,
            boxShadowFocusWarning,
            boxShadowActiveWarning,
            boxShadowHoverWarning,
            borderWarning,
            borderFocusWarning,
            borderHoverWarning,
            borderActiveWarning,
            // form error
            colorActiveError,
            boxShadowFocusError,
            boxShadowActiveError,
            boxShadowHoverError,
            borderError,
            borderFocusError,
            borderHoverError,
            borderActiveError,
            // clear
            clearColor,
            clearColorHover,
            clearColorPressed,
            clearSize,
            // arrow
            arrowSize: arrowSize2,
            [createKey("height", size2)]: height,
            [createKey("fontSize", size2)]: fontSize2
          } } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-border": border,
            "--n-border-active": borderActive,
            "--n-border-focus": borderFocus,
            "--n-border-hover": borderHover,
            "--n-border-radius": borderRadius,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-caret-color": caretColor,
            "--n-color": color,
            "--n-color-active": colorActive,
            "--n-color-disabled": colorDisabled,
            "--n-font-size": fontSize2,
            "--n-height": height,
            "--n-padding-single": paddingSingle,
            "--n-padding-multiple": paddingMultiple,
            "--n-placeholder-color": placeholderColor,
            "--n-placeholder-color-disabled": placeholderColorDisabled,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-arrow-color": arrowColor,
            "--n-arrow-color-disabled": arrowColorDisabled,
            "--n-loading-color": loadingColor,
            // form warning
            "--n-color-active-warning": colorActiveWarning,
            "--n-box-shadow-focus-warning": boxShadowFocusWarning,
            "--n-box-shadow-active-warning": boxShadowActiveWarning,
            "--n-box-shadow-hover-warning": boxShadowHoverWarning,
            "--n-border-warning": borderWarning,
            "--n-border-focus-warning": borderFocusWarning,
            "--n-border-hover-warning": borderHoverWarning,
            "--n-border-active-warning": borderActiveWarning,
            // form error
            "--n-color-active-error": colorActiveError,
            "--n-box-shadow-focus-error": boxShadowFocusError,
            "--n-box-shadow-active-error": boxShadowActiveError,
            "--n-box-shadow-hover-error": boxShadowHoverError,
            "--n-border-error": borderError,
            "--n-border-focus-error": borderFocusError,
            "--n-border-hover-error": borderHoverError,
            "--n-border-active-error": borderActiveError,
            // clear
            "--n-clear-size": clearSize,
            "--n-clear-color": clearColor,
            "--n-clear-color-hover": clearColorHover,
            "--n-clear-color-pressed": clearColorPressed,
            // arrow-size
            "--n-arrow-size": arrowSize2
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-selection", computed(() => {
          return props.size[0];
        }), cssVarsRef, props) : void 0;
        return {
          mergedTheme: themeRef,
          mergedClearable: mergedClearableRef,
          patternInputFocused: patternInputFocusedRef,
          filterablePlaceholder: filterablePlaceholderRef,
          label: labelRef,
          selected: selectedRef,
          showTagsPanel: showTagsPopoverRef,
          isComposing: isComposingRef,
          // dom ref
          counterRef,
          counterWrapperRef,
          patternInputMirrorRef,
          patternInputRef,
          selfRef,
          multipleElRef,
          singleElRef,
          patternInputWrapperRef,
          overflowRef,
          inputTagElRef,
          handleMouseDown,
          handleFocusin,
          handleClear,
          handleMouseEnter,
          handleMouseLeave,
          handleDeleteOption,
          handlePatternKeyDown,
          handlePatternInputInput,
          handlePatternInputBlur,
          handlePatternInputFocus,
          handleMouseEnterCounter,
          handleMouseLeaveCounter,
          handleFocusout,
          handleCompositionEnd,
          handleCompositionStart,
          onPopoverUpdateShow,
          focus,
          focusInput,
          blur,
          blurInput,
          updateCounter,
          getCounter,
          getTail,
          renderLabel: props.renderLabel,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { status, multiple, size: size2, disabled, filterable, maxTagCount, bordered, clsPrefix, onRender, renderTag, renderLabel } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const maxTagCountResponsive = maxTagCount === "responsive";
        const maxTagCountNumeric = typeof maxTagCount === "number";
        const useMaxTagCount = maxTagCountResponsive || maxTagCountNumeric;
        const suffix2 = h(Wrapper, null, {
          default: () => h(NBaseSuffix, { clsPrefix, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, {
            default: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
          })
        });
        let body;
        if (multiple) {
          const { labelField } = this;
          const createTag = (option) => h("div", { class: `${clsPrefix}-base-selection-tag-wrapper`, key: option.value }, renderTag ? renderTag({
            option,
            handleClose: () => this.handleDeleteOption(option)
          }) : h(NTag, { size: size2, closable: !option.disabled, disabled, onClose: () => this.handleDeleteOption(option), internalCloseIsButtonTag: false, internalCloseFocusable: false }, {
            default: () => renderLabel ? renderLabel(option, true) : render$1(option[labelField], option, true)
          }));
          const createOriginalTagNodes = () => (maxTagCountNumeric ? this.selectedOptions.slice(0, maxTagCount) : this.selectedOptions).map(createTag);
          const input = filterable ? h(
            "div",
            { class: `${clsPrefix}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" },
            h("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled, value: this.pattern, autofocus: this.autofocus, class: `${clsPrefix}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })),
            h("span", { ref: "patternInputMirrorRef", class: `${clsPrefix}-base-selection-input-tag__mirror` }, this.pattern)
          ) : null;
          const renderCounter = maxTagCountResponsive ? () => h(
            "div",
            { class: `${clsPrefix}-base-selection-tag-wrapper`, ref: "counterWrapperRef" },
            h(NTag, { size: size2, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled })
          ) : void 0;
          let counter;
          if (maxTagCountNumeric) {
            const rest = this.selectedOptions.length - maxTagCount;
            if (rest > 0) {
              counter = h(
                "div",
                { class: `${clsPrefix}-base-selection-tag-wrapper`, key: "__counter__" },
                h(NTag, { size: size2, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled }, {
                  default: () => `+${rest}`
                })
              );
            }
          }
          const tags = maxTagCountResponsive ? filterable ? h(VOverflow, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: {
            width: "100%",
            display: "flex",
            overflow: "hidden"
          } }, {
            default: createOriginalTagNodes,
            counter: renderCounter,
            tail: () => input
          }) : h(VOverflow, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: {
            width: "100%",
            display: "flex",
            overflow: "hidden"
          } }, {
            default: createOriginalTagNodes,
            counter: renderCounter
          }) : maxTagCountNumeric ? createOriginalTagNodes().concat(counter) : createOriginalTagNodes();
          const renderPopover = useMaxTagCount ? () => h("div", { class: `${clsPrefix}-base-selection-popover` }, maxTagCountResponsive ? createOriginalTagNodes() : this.selectedOptions.map(createTag)) : void 0;
          const popoverProps2 = useMaxTagCount ? {
            show: this.showTagsPanel,
            trigger: "hover",
            overlap: true,
            placement: "top",
            width: "trigger",
            onUpdateShow: this.onPopoverUpdateShow,
            theme: this.mergedTheme.peers.Popover,
            themeOverrides: this.mergedTheme.peerOverrides.Popover
          } : null;
          const showPlaceholder = this.selected ? false : this.active ? !this.pattern && !this.isComposing : true;
          const placeholder = showPlaceholder ? h(
            "div",
            { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay` },
            h("div", { class: `${clsPrefix}-base-selection-placeholder__inner` }, this.placeholder)
          ) : null;
          const popoverTrigger = filterable ? h(
            "div",
            { ref: "patternInputWrapperRef", class: `${clsPrefix}-base-selection-tags` },
            tags,
            maxTagCountResponsive ? null : input,
            suffix2
          ) : h(
            "div",
            { ref: "multipleElRef", class: `${clsPrefix}-base-selection-tags`, tabindex: disabled ? void 0 : 0 },
            tags,
            suffix2
          );
          body = h(
            Fragment,
            null,
            useMaxTagCount ? h(NPopover, Object.assign({}, popoverProps2, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), {
              trigger: () => popoverTrigger,
              default: renderPopover
            }) : popoverTrigger,
            placeholder
          );
        } else {
          if (filterable) {
            const hasInput = this.pattern || this.isComposing;
            const showPlaceholder = this.active ? !hasInput : !this.selected;
            const showSelectedLabel = this.active ? false : this.selected;
            body = h(
              "div",
              { ref: "patternInputWrapperRef", class: `${clsPrefix}-base-selection-label` },
              h("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${clsPrefix}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: disabled, disabled, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })),
              showSelectedLabel ? h(
                "div",
                { class: `${clsPrefix}-base-selection-label__render-label ${clsPrefix}-base-selection-overlay`, key: "input" },
                h("div", { class: `${clsPrefix}-base-selection-overlay__wrapper` }, renderTag ? renderTag({
                  option: this.selectedOption,
                  handleClose: () => {
                  }
                }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))
              ) : null,
              showPlaceholder ? h(
                "div",
                { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`, key: "placeholder" },
                h("div", { class: `${clsPrefix}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)
              ) : null,
              suffix2
            );
          } else {
            body = h(
              "div",
              { ref: "singleElRef", class: `${clsPrefix}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 },
              this.label !== void 0 ? h(
                "div",
                { class: `${clsPrefix}-base-selection-input`, title: getTitleAttribute(this.label), key: "input" },
                h("div", { class: `${clsPrefix}-base-selection-input__content` }, renderTag ? renderTag({
                  option: this.selectedOption,
                  handleClose: () => {
                  }
                }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))
              ) : h(
                "div",
                { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`, key: "placeholder" },
                h("div", { class: `${clsPrefix}-base-selection-placeholder__inner` }, this.placeholder)
              ),
              suffix2
            );
          }
        }
        return h(
          "div",
          { ref: "selfRef", class: [
            `${clsPrefix}-base-selection`,
            this.themeClass,
            status && `${clsPrefix}-base-selection--${status}-status`,
            {
              [`${clsPrefix}-base-selection--active`]: this.active,
              [`${clsPrefix}-base-selection--selected`]: this.selected || this.active && this.pattern,
              [`${clsPrefix}-base-selection--disabled`]: this.disabled,
              [`${clsPrefix}-base-selection--multiple`]: this.multiple,
              // focus is not controlled by selection itself since it always need
              // to be managed together with menu. provide :focus style will cause
              // many redundant codes.
              [`${clsPrefix}-base-selection--focus`]: this.focused
            }
          ], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown },
          body,
          bordered ? h("div", { class: `${clsPrefix}-base-selection__border` }) : null,
          bordered ? h("div", { class: `${clsPrefix}-base-selection__state-border` }) : null
        );
      }
    });
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$1
    } = commonVariables$d;
    function fadeInWidthExpandTransition({
      duration = ".2s",
      delay = ".1s"
    } = {}) {
      return [c$1("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
        opacity: 1
      }), c$1("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c$1("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$1},
 max-width ${duration} ${cubicBezierEaseInOut$1} ${delay},
 margin-left ${duration} ${cubicBezierEaseInOut$1} ${delay},
 margin-right ${duration} ${cubicBezierEaseInOut$1} ${delay};
 `), c$1("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$1} ${delay},
 max-width ${duration} ${cubicBezierEaseInOut$1},
 margin-left ${duration} ${cubicBezierEaseInOut$1},
 margin-right ${duration} ${cubicBezierEaseInOut$1};
 `)];
    }
    function getIsGroup(option) {
      return option.type === "group";
    }
    function getIgnored(option) {
      return option.type === "ignored";
    }
    function patternMatched(pattern2, value) {
      try {
        return !!(1 + value.toString().toLowerCase().indexOf(pattern2.trim().toLowerCase()));
      } catch (err) {
        return false;
      }
    }
    function createTmOptions(valueField, childrenField) {
      const options = {
        getIsGroup,
        getIgnored,
        getKey(option) {
          if (getIsGroup(option)) {
            return option.name || option.key || "key-required";
          }
          return option[valueField];
        },
        getChildren(option) {
          return option[childrenField];
        }
      };
      return options;
    }
    function filterOptions(originalOpts, filter, pattern2, childrenField) {
      if (!filter)
        return originalOpts;
      function traverse2(options) {
        if (!Array.isArray(options))
          return [];
        const filteredOptions = [];
        for (const option of options) {
          if (getIsGroup(option)) {
            const children = traverse2(option[childrenField]);
            if (children.length) {
              filteredOptions.push(Object.assign({}, option, {
                [childrenField]: children
              }));
            }
          } else if (getIgnored(option)) {
            continue;
          } else if (filter(pattern2, option)) {
            filteredOptions.push(option);
          }
        }
        return filteredOptions;
      }
      return traverse2(originalOpts);
    }
    function createValOptMap(options, valueField, childrenField) {
      const valOptMap = /* @__PURE__ */ new Map();
      options.forEach((option) => {
        if (getIsGroup(option)) {
          option[childrenField].forEach((selectGroupOption) => {
            valOptMap.set(selectGroupOption[valueField], selectGroupOption);
          });
        } else {
          valOptMap.set(option[valueField], option);
        }
      });
      return valOptMap;
    }
    const isChrome = isBrowser$2 && "chrome" in window;
    isBrowser$2 && navigator.userAgent.includes("Firefox");
    const isSafari = isBrowser$2 && navigator.userAgent.includes("Safari") && !isChrome;
    const commonVariables$9 = {
      paddingTiny: "0 8px",
      paddingSmall: "0 10px",
      paddingMedium: "0 12px",
      paddingLarge: "0 14px",
      clearSize: "16px"
    };
    const self$f = (vars) => {
      const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, borderColor, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight: lineHeight2, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, actionColor, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$9), {
        countTextColorDisabled: textColorDisabled,
        countTextColor: textColor3,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight: lineHeight2,
        lineHeightTextarea: lineHeight2,
        borderRadius,
        iconSize: "16px",
        groupLabelColor: actionColor,
        groupLabelTextColor: textColor2,
        textColor: textColor2,
        textColorDisabled,
        textDecorationColor: textColor2,
        caretColor: primaryColor,
        placeholderColor,
        placeholderColorDisabled,
        color: inputColor,
        colorDisabled: inputColorDisabled,
        colorFocus: inputColor,
        groupLabelBorder: `1px solid ${borderColor}`,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`,
        loadingColor: primaryColor,
        // warning
        loadingColorWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        colorFocusWarning: inputColor,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
        caretColorWarning: warningColor,
        // error
        loadingColorError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        colorFocusError: inputColor,
        borderFocusError: `1px solid ${errorColorHover}`,
        boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
        caretColorError: errorColor,
        clearColor,
        clearColorHover,
        clearColorPressed,
        iconColor,
        iconColorDisabled,
        iconColorHover,
        iconColorPressed,
        suffixTextColor: textColor2
      });
    };
    const inputLight = {
      name: "Input",
      common: commonLight,
      self: self$f
    };
    const inputLight$1 = inputLight;
    const inputInjectionKey = createInjectionKey("n-input");
    function len(s) {
      let count = 0;
      for (const _ of s) {
        count++;
      }
      return count;
    }
    function isEmptyInputValue(value) {
      return value === "" || value == null;
    }
    function useCursor(inputElRef) {
      const selectionRef = ref(null);
      function recordCursor() {
        const { value: input } = inputElRef;
        if (!(input === null || input === void 0 ? void 0 : input.focus)) {
          reset();
          return;
        }
        const { selectionStart, selectionEnd, value } = input;
        if (selectionStart == null || selectionEnd == null) {
          reset();
          return;
        }
        selectionRef.value = {
          start: selectionStart,
          end: selectionEnd,
          beforeText: value.slice(0, selectionStart),
          afterText: value.slice(selectionEnd)
        };
      }
      function restoreCursor() {
        var _a;
        const { value: selection } = selectionRef;
        const { value: inputEl } = inputElRef;
        if (!selection || !inputEl) {
          return;
        }
        const { value } = inputEl;
        const { start, beforeText, afterText } = selection;
        let startPos = value.length;
        if (value.endsWith(afterText)) {
          startPos = value.length - afterText.length;
        } else if (value.startsWith(beforeText)) {
          startPos = beforeText.length;
        } else {
          const beforeLastChar = beforeText[start - 1];
          const newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        (_a = inputEl.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(inputEl, startPos, startPos);
      }
      function reset() {
        selectionRef.value = null;
      }
      watch(inputElRef, reset);
      return {
        recordCursor,
        restoreCursor
      };
    }
    const WordCount = defineComponent({
      name: "InputWordCount",
      setup(_, { slots }) {
        const { mergedValueRef, maxlengthRef, mergedClsPrefixRef, countGraphemesRef } = (
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          inject(inputInjectionKey)
        );
        const wordCountRef = computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (mergedValue === null || Array.isArray(mergedValue))
            return 0;
          return (countGraphemesRef.value || len)(mergedValue);
        });
        return () => {
          const { value: maxlength } = maxlengthRef;
          const { value: mergedValue } = mergedValueRef;
          return h("span", { class: `${mergedClsPrefixRef.value}-input-word-count` }, resolveSlotWithProps(slots.default, {
            value: mergedValue === null || Array.isArray(mergedValue) ? "" : mergedValue
          }, () => [
            maxlength === void 0 ? wordCountRef.value : `${wordCountRef.value} / ${maxlength}`
          ]));
        };
      }
    });
    const style$h = cB("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [
      // common
      cE("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `),
      cE("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `),
      cE("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), c$1("&:-webkit-autofill ~", [cE("placeholder", "display: none;")])]),
      cM("round", [cNotM("textarea", "border-radius: calc(var(--n-height) / 2);")]),
      cE("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [c$1("span", `
 width: 100%;
 display: inline-block;
 `)]),
      cM("textarea", [cE("placeholder", "overflow: visible;")]),
      cNotM("autosize", "width: 100%;"),
      cM("autosize", [cE("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]),
      // input
      cB("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `),
      cE("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `),
      cE("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [c$1("+", [cE("placeholder", `
 display: flex;
 align-items: center; 
 `)])]),
      cNotM("textarea", [cE("placeholder", "white-space: nowrap;")]),
      cE("eye", `
 transition: color .3s var(--n-bezier);
 `),
      // textarea
      cM("textarea", "width: 100%;", [cB("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), cM("resizable", [cB("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), cE("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 `), cE("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]),
      // pair
      cM("pair", [cE("input-el, placeholder", "text-align: center;"), cE("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [cB("icon", `
 color: var(--n-icon-color);
 `), cB("base-icon", `
 color: var(--n-icon-color);
 `)])]),
      cM("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cE("border", "border: var(--n-border-disabled);"), cE("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), cE("placeholder", "color: var(--n-placeholder-color-disabled);"), cE("separator", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), cB("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), cE("suffix, prefix", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]),
      cNotM("disabled", [cE("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 color: var(--n-icon-color);
 cursor: pointer;
 `, [c$1("&:hover", `
 color: var(--n-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), c$1("&:hover", [cE("state-border", "border: var(--n-border-hover);")]), cM("focus", "background-color: var(--n-color-focus);", [cE("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]),
      cE("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `),
      cE("state-border", `
 border-color: #0000;
 z-index: 1;
 `),
      cE("prefix", "margin-right: 4px;"),
      cE("suffix", `
 margin-left: 4px;
 `),
      cE("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [cB("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), cB("base-clear", `
 font-size: var(--n-icon-size);
 `, [cE("placeholder", [cB("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), c$1(">", [cB("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("base-icon", `
 font-size: var(--n-icon-size);
 `)]),
      cB("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `),
      ["warning", "error"].map((status) => cM(`${status}-status`, [cNotM("disabled", [cB("base-loading", `
 color: var(--n-loading-color-${status})
 `), cE("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${status});
 `), cE("state-border", `
 border: var(--n-border-${status});
 `), c$1("&:hover", [cE("state-border", `
 border: var(--n-border-hover-${status});
 `)]), c$1("&:focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)]), cM("focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))
    ]);
    const safariStyle = cB("input", [cM("disabled", [cE("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
    const inputProps = Object.assign(Object.assign({}, useTheme.props), {
      bordered: {
        type: Boolean,
        default: void 0
      },
      type: {
        type: String,
        default: "text"
      },
      placeholder: [Array, String],
      defaultValue: {
        type: [String, Array],
        default: null
      },
      value: [String, Array],
      disabled: {
        type: Boolean,
        default: void 0
      },
      size: String,
      rows: {
        type: [Number, String],
        default: 3
      },
      round: Boolean,
      minlength: [String, Number],
      maxlength: [String, Number],
      clearable: Boolean,
      autosize: {
        type: [Boolean, Object],
        default: false
      },
      pair: Boolean,
      separator: String,
      readonly: {
        type: [String, Boolean],
        default: false
      },
      passivelyActivated: Boolean,
      showPasswordOn: String,
      stateful: {
        type: Boolean,
        default: true
      },
      autofocus: Boolean,
      inputProps: Object,
      resizable: {
        type: Boolean,
        default: true
      },
      showCount: Boolean,
      loading: {
        type: Boolean,
        default: void 0
      },
      allowInput: Function,
      renderCount: Function,
      onMousedown: Function,
      onKeydown: Function,
      onKeyup: Function,
      onInput: [Function, Array],
      onFocus: [Function, Array],
      onBlur: [Function, Array],
      onClick: [Function, Array],
      onChange: [Function, Array],
      onClear: [Function, Array],
      countGraphemes: Function,
      status: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      /** private */
      textDecoration: [String, Array],
      attrSize: {
        type: Number,
        default: 20
      },
      onInputBlur: [Function, Array],
      onInputFocus: [Function, Array],
      onDeactivate: [Function, Array],
      onActivate: [Function, Array],
      onWrapperFocus: [Function, Array],
      onWrapperBlur: [Function, Array],
      internalDeactivateOnEnter: Boolean,
      internalForceFocus: Boolean,
      internalLoadingBeforeSuffix: Boolean,
      /** deprecated */
      showPasswordToggle: Boolean
    });
    const NInput = defineComponent({
      name: "Input",
      props: inputProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedBorderedRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Input", "-input", style$h, inputLight$1, props, mergedClsPrefixRef);
        if (isSafari) {
          useStyle("-input-safari", safariStyle, mergedClsPrefixRef);
        }
        const wrapperElRef = ref(null);
        const textareaElRef = ref(null);
        const textareaMirrorElRef = ref(null);
        const inputMirrorElRef = ref(null);
        const inputElRef = ref(null);
        const inputEl2Ref = ref(null);
        const currentFocusedInputRef = ref(null);
        const focusedInputCursorControl = useCursor(currentFocusedInputRef);
        const textareaScrollbarInstRef = ref(null);
        const { localeRef } = useLocale("Input");
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        const focusedRef = ref(false);
        const hoverRef = ref(false);
        const isComposingRef = ref(false);
        const activatedRef = ref(false);
        let syncSource = null;
        const mergedPlaceholderRef = computed(() => {
          const { placeholder, pair } = props;
          if (pair) {
            if (Array.isArray(placeholder)) {
              return placeholder;
            } else if (placeholder === void 0) {
              return ["", ""];
            }
            return [placeholder, placeholder];
          } else if (placeholder === void 0) {
            return [localeRef.value.placeholder];
          } else {
            return [placeholder];
          }
        });
        const showPlaceholder1Ref = computed(() => {
          const { value: isComposing } = isComposingRef;
          const { value: mergedValue } = mergedValueRef;
          const { value: mergedPlaceholder } = mergedPlaceholderRef;
          return !isComposing && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[0])) && mergedPlaceholder[0];
        });
        const showPlaceholder2Ref = computed(() => {
          const { value: isComposing } = isComposingRef;
          const { value: mergedValue } = mergedValueRef;
          const { value: mergedPlaceholder } = mergedPlaceholderRef;
          return !isComposing && mergedPlaceholder[1] && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[1]));
        });
        const mergedFocusRef = useMemo(() => {
          return props.internalForceFocus || focusedRef.value;
        });
        const showClearButton = useMemo(() => {
          if (mergedDisabledRef.value || props.readonly || !props.clearable || !mergedFocusRef.value && !hoverRef.value) {
            return false;
          }
          const { value: mergedValue } = mergedValueRef;
          const { value: mergedFocus } = mergedFocusRef;
          if (props.pair) {
            return !!(Array.isArray(mergedValue) && (mergedValue[0] || mergedValue[1])) && (hoverRef.value || mergedFocus);
          } else {
            return !!mergedValue && (hoverRef.value || mergedFocus);
          }
        });
        const mergedShowPasswordOnRef = computed(() => {
          const { showPasswordOn } = props;
          if (showPasswordOn) {
            return showPasswordOn;
          }
          if (props.showPasswordToggle)
            return "click";
          return void 0;
        });
        const passwordVisibleRef = ref(false);
        const textDecorationStyleRef = computed(() => {
          const { textDecoration } = props;
          if (!textDecoration)
            return ["", ""];
          if (Array.isArray(textDecoration)) {
            return textDecoration.map((v) => ({
              textDecoration: v
            }));
          }
          return [
            {
              textDecoration
            }
          ];
        });
        const textAreaScrollContainerWidthRef = ref(void 0);
        const updateTextAreaStyle = () => {
          var _a, _b;
          if (props.type === "textarea") {
            const { autosize } = props;
            if (autosize) {
              textAreaScrollContainerWidthRef.value = (_b = (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) === null || _b === void 0 ? void 0 : _b.offsetWidth;
            }
            if (!textareaElRef.value)
              return;
            if (typeof autosize === "boolean")
              return;
            const { paddingTop: stylePaddingTop, paddingBottom: stylePaddingBottom, lineHeight: styleLineHeight } = window.getComputedStyle(textareaElRef.value);
            const paddingTop = Number(stylePaddingTop.slice(0, -2));
            const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
            const lineHeight2 = Number(styleLineHeight.slice(0, -2));
            const { value: textareaMirrorEl } = textareaMirrorElRef;
            if (!textareaMirrorEl)
              return;
            if (autosize.minRows) {
              const minRows = Math.max(autosize.minRows, 1);
              const styleMinHeight = `${paddingTop + paddingBottom + lineHeight2 * minRows}px`;
              textareaMirrorEl.style.minHeight = styleMinHeight;
            }
            if (autosize.maxRows) {
              const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight2 * autosize.maxRows}px`;
              textareaMirrorEl.style.maxHeight = styleMaxHeight;
            }
          }
        };
        const maxlengthRef = computed(() => {
          const { maxlength } = props;
          return maxlength === void 0 ? void 0 : Number(maxlength);
        });
        onMounted(() => {
          const { value } = mergedValueRef;
          if (!Array.isArray(value)) {
            syncMirror(value);
          }
        });
        const vm = getCurrentInstance().proxy;
        function doUpdateValue(value) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue, onInput } = props;
          const { nTriggerFormInput } = formItem;
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onInput)
            call(onInput, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
        }
        function doChange(value) {
          const { onChange } = props;
          const { nTriggerFormChange } = formItem;
          if (onChange)
            call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
        }
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function doClear(e) {
          const { onClear } = props;
          if (onClear)
            call(onClear, e);
        }
        function doUpdateValueBlur(e) {
          const { onInputBlur } = props;
          if (onInputBlur)
            call(onInputBlur, e);
        }
        function doUpdateValueFocus(e) {
          const { onInputFocus } = props;
          if (onInputFocus)
            call(onInputFocus, e);
        }
        function doDeactivate() {
          const { onDeactivate } = props;
          if (onDeactivate)
            call(onDeactivate);
        }
        function doActivate() {
          const { onActivate } = props;
          if (onActivate)
            call(onActivate);
        }
        function doClick(e) {
          const { onClick } = props;
          if (onClick)
            call(onClick, e);
        }
        function doWrapperFocus(e) {
          const { onWrapperFocus } = props;
          if (onWrapperFocus)
            call(onWrapperFocus, e);
        }
        function doWrapperBlur(e) {
          const { onWrapperBlur } = props;
          if (onWrapperBlur)
            call(onWrapperBlur, e);
        }
        function handleCompositionStart() {
          isComposingRef.value = true;
        }
        function handleCompositionEnd(e) {
          isComposingRef.value = false;
          if (e.target === inputEl2Ref.value) {
            handleInput(e, 1);
          } else {
            handleInput(e, 0);
          }
        }
        function handleInput(e, index = 0, event = "input") {
          const targetValue = e.target.value;
          syncMirror(targetValue);
          if (e instanceof InputEvent && !e.isComposing) {
            isComposingRef.value = false;
          }
          if (props.type === "textarea") {
            const { value: textareaScrollbarInst } = textareaScrollbarInstRef;
            if (textareaScrollbarInst) {
              textareaScrollbarInst.syncUnifiedContainer();
            }
          }
          syncSource = targetValue;
          if (isComposingRef.value)
            return;
          focusedInputCursorControl.recordCursor();
          const isIncomingValueValid = allowInput(targetValue);
          if (isIncomingValueValid) {
            if (!props.pair) {
              event === "input" ? doUpdateValue(targetValue) : doChange(targetValue);
            } else {
              let { value } = mergedValueRef;
              if (!Array.isArray(value)) {
                value = ["", ""];
              } else {
                value = [value[0], value[1]];
              }
              value[index] = targetValue;
              event === "input" ? doUpdateValue(value) : doChange(value);
            }
          }
          vm.$forceUpdate();
          if (!isIncomingValueValid) {
            void nextTick(focusedInputCursorControl.restoreCursor);
          }
        }
        function allowInput(value) {
          const { countGraphemes, maxlength, minlength } = props;
          if (countGraphemes) {
            let graphemesCount;
            if (maxlength !== void 0) {
              if (graphemesCount === void 0) {
                graphemesCount = countGraphemes(value);
              }
              if (graphemesCount > Number(maxlength))
                return false;
            }
            if (minlength !== void 0) {
              if (graphemesCount === void 0) {
                graphemesCount = countGraphemes(value);
              }
              if (graphemesCount < Number(maxlength))
                return false;
            }
          }
          const { allowInput: allowInput2 } = props;
          if (typeof allowInput2 === "function") {
            return allowInput2(value);
          }
          return true;
        }
        function handleInputBlur(e) {
          doUpdateValueBlur(e);
          if (e.relatedTarget === wrapperElRef.value) {
            doDeactivate();
          }
          if (!(e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value))) {
            activatedRef.value = false;
          }
          dealWithEvent(e, "blur");
          currentFocusedInputRef.value = null;
        }
        function handleInputFocus(e, index) {
          doUpdateValueFocus(e);
          focusedRef.value = true;
          activatedRef.value = true;
          doActivate();
          dealWithEvent(e, "focus");
          if (index === 0) {
            currentFocusedInputRef.value = inputElRef.value;
          } else if (index === 1) {
            currentFocusedInputRef.value = inputEl2Ref.value;
          } else if (index === 2) {
            currentFocusedInputRef.value = textareaElRef.value;
          }
        }
        function handleWrapperBlur(e) {
          if (props.passivelyActivated) {
            doWrapperBlur(e);
            dealWithEvent(e, "blur");
          }
        }
        function handleWrapperFocus(e) {
          if (props.passivelyActivated) {
            focusedRef.value = true;
            doWrapperFocus(e);
            dealWithEvent(e, "focus");
          }
        }
        function dealWithEvent(e, type2) {
          if (e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value || e.relatedTarget === wrapperElRef.value))
            ;
          else {
            if (type2 === "focus") {
              doFocus(e);
              focusedRef.value = true;
            } else if (type2 === "blur") {
              doBlur(e);
              focusedRef.value = false;
            }
          }
        }
        function handleChange(e, index) {
          handleInput(e, index, "change");
        }
        function handleClick(e) {
          doClick(e);
        }
        function handleClear(e) {
          doClear(e);
          if (props.pair) {
            doUpdateValue(["", ""]);
            doChange(["", ""]);
          } else {
            doUpdateValue("");
            doChange("");
          }
        }
        function handleMouseDown(e) {
          const { onMousedown } = props;
          if (onMousedown)
            onMousedown(e);
          const { tagName } = e.target;
          if (tagName !== "INPUT" && tagName !== "TEXTAREA") {
            if (props.resizable) {
              const { value: wrapperEl } = wrapperElRef;
              if (wrapperEl) {
                const { left, top, width, height } = wrapperEl.getBoundingClientRect();
                const resizeHandleSize = 14;
                if (left + width - resizeHandleSize < e.clientX && e.clientX < left + width && top + height - resizeHandleSize < e.clientY && e.clientY < top + height) {
                  return;
                }
              }
            }
            e.preventDefault();
            if (!focusedRef.value) {
              focus();
            }
          }
        }
        function handleMouseEnter() {
          var _a;
          hoverRef.value = true;
          if (props.type === "textarea") {
            (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseEnterWrapper();
          }
        }
        function handleMouseLeave() {
          var _a;
          hoverRef.value = false;
          if (props.type === "textarea") {
            (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseLeaveWrapper();
          }
        }
        function handlePasswordToggleClick() {
          if (mergedDisabledRef.value)
            return;
          if (mergedShowPasswordOnRef.value !== "click")
            return;
          passwordVisibleRef.value = !passwordVisibleRef.value;
        }
        function handlePasswordToggleMousedown(e) {
          if (mergedDisabledRef.value)
            return;
          e.preventDefault();
          const preventDefaultOnce = (e2) => {
            e2.preventDefault();
            off("mouseup", document, preventDefaultOnce);
          };
          on("mouseup", document, preventDefaultOnce);
          if (mergedShowPasswordOnRef.value !== "mousedown")
            return;
          passwordVisibleRef.value = true;
          const hidePassword = () => {
            passwordVisibleRef.value = false;
            off("mouseup", document, hidePassword);
          };
          on("mouseup", document, hidePassword);
        }
        function handleWrapperKeydown(e) {
          var _a;
          (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
          switch (e.key) {
            case "Escape":
              handleWrapperKeydownEsc();
              break;
            case "Enter":
              handleWrapperKeydownEnter(e);
              break;
          }
        }
        function handleWrapperKeydownEnter(e) {
          var _a, _b;
          if (props.passivelyActivated) {
            const { value: focused } = activatedRef;
            if (focused) {
              if (props.internalDeactivateOnEnter) {
                handleWrapperKeydownEsc();
              }
              return;
            }
            e.preventDefault();
            if (props.type === "textarea") {
              (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            } else {
              (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
            }
          }
        }
        function handleWrapperKeydownEsc() {
          if (props.passivelyActivated) {
            activatedRef.value = false;
            void nextTick(() => {
              var _a;
              (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            });
          }
        }
        function focus() {
          var _a, _b, _c;
          if (mergedDisabledRef.value)
            return;
          if (props.passivelyActivated) {
            (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          } else {
            (_b = textareaElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
            (_c = inputElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
          }
        }
        function blur() {
          var _a;
          if ((_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
            document.activeElement.blur();
          }
        }
        function select() {
          var _a, _b;
          (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.select();
          (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.select();
        }
        function activate() {
          if (mergedDisabledRef.value)
            return;
          if (textareaElRef.value)
            textareaElRef.value.focus();
          else if (inputElRef.value)
            inputElRef.value.focus();
        }
        function deactivate() {
          const { value: wrapperEl } = wrapperElRef;
          if ((wrapperEl === null || wrapperEl === void 0 ? void 0 : wrapperEl.contains(document.activeElement)) && wrapperEl !== document.activeElement) {
            handleWrapperKeydownEsc();
          }
        }
        function scrollTo(options) {
          if (props.type === "textarea") {
            const { value: textareaEl } = textareaElRef;
            textareaEl === null || textareaEl === void 0 ? void 0 : textareaEl.scrollTo(options);
          } else {
            const { value: inputEl } = inputElRef;
            inputEl === null || inputEl === void 0 ? void 0 : inputEl.scrollTo(options);
          }
        }
        function syncMirror(value) {
          const { type: type2, pair, autosize } = props;
          if (!pair && autosize) {
            if (type2 === "textarea") {
              const { value: textareaMirrorEl } = textareaMirrorElRef;
              if (textareaMirrorEl) {
                textareaMirrorEl.textContent = (value !== null && value !== void 0 ? value : "") + "\r\n";
              }
            } else {
              const { value: inputMirrorEl } = inputMirrorElRef;
              if (inputMirrorEl) {
                if (value) {
                  inputMirrorEl.textContent = value;
                } else {
                  inputMirrorEl.innerHTML = "&nbsp;";
                }
              }
            }
          }
        }
        function handleTextAreaMirrorResize() {
          updateTextAreaStyle();
        }
        const placeholderStyleRef = ref({
          top: "0"
        });
        function handleTextAreaScroll(e) {
          var _a;
          const { scrollTop } = e.target;
          placeholderStyleRef.value.top = `${-scrollTop}px`;
          (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
        }
        let stopWatchMergedValue1 = null;
        watchEffect(() => {
          const { autosize, type: type2 } = props;
          if (autosize && type2 === "textarea") {
            stopWatchMergedValue1 = watch(mergedValueRef, (value) => {
              if (!Array.isArray(value) && value !== syncSource) {
                syncMirror(value);
              }
            });
          } else {
            stopWatchMergedValue1 === null || stopWatchMergedValue1 === void 0 ? void 0 : stopWatchMergedValue1();
          }
        });
        let stopWatchMergedValue2 = null;
        watchEffect(() => {
          if (props.type === "textarea") {
            stopWatchMergedValue2 = watch(mergedValueRef, (value) => {
              var _a;
              if (!Array.isArray(value) && value !== syncSource) {
                (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
              }
            });
          } else {
            stopWatchMergedValue2 === null || stopWatchMergedValue2 === void 0 ? void 0 : stopWatchMergedValue2();
          }
        });
        provide(inputInjectionKey, {
          mergedValueRef,
          maxlengthRef,
          mergedClsPrefixRef,
          countGraphemesRef: toRef(props, "countGraphemes")
        });
        const exposedProps = {
          wrapperElRef,
          inputElRef,
          textareaElRef,
          isCompositing: isComposingRef,
          focus,
          blur,
          select,
          deactivate,
          activate,
          scrollTo
        };
        const rtlEnabledRef = useRtl("Input", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { value: size2 } = mergedSizeRef;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { color, borderRadius, textColor, caretColor, caretColorError, caretColorWarning, textDecorationColor, border, borderDisabled, borderHover, borderFocus, placeholderColor, placeholderColorDisabled, lineHeightTextarea, colorDisabled, colorFocus, textColorDisabled, boxShadowFocus, iconSize, colorFocusWarning, boxShadowFocusWarning, borderWarning, borderFocusWarning, borderHoverWarning, colorFocusError, boxShadowFocusError, borderError, borderFocusError, borderHoverError, clearSize, clearColor, clearColorHover, clearColorPressed, iconColor, iconColorDisabled, suffixTextColor, countTextColor, countTextColorDisabled, iconColorHover, iconColorPressed, loadingColor, loadingColorError, loadingColorWarning, [createKey("padding", size2)]: padding, [createKey("fontSize", size2)]: fontSize2, [createKey("height", size2)]: height } } = themeRef.value;
          const { left: paddingLeft, right: paddingRight } = getMargin(padding);
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-count-text-color": countTextColor,
            "--n-count-text-color-disabled": countTextColorDisabled,
            "--n-color": color,
            "--n-font-size": fontSize2,
            "--n-border-radius": borderRadius,
            "--n-height": height,
            "--n-padding-left": paddingLeft,
            "--n-padding-right": paddingRight,
            "--n-text-color": textColor,
            "--n-caret-color": caretColor,
            "--n-text-decoration-color": textDecorationColor,
            "--n-border": border,
            "--n-border-disabled": borderDisabled,
            "--n-border-hover": borderHover,
            "--n-border-focus": borderFocus,
            "--n-placeholder-color": placeholderColor,
            "--n-placeholder-color-disabled": placeholderColorDisabled,
            "--n-icon-size": iconSize,
            "--n-line-height-textarea": lineHeightTextarea,
            "--n-color-disabled": colorDisabled,
            "--n-color-focus": colorFocus,
            "--n-text-color-disabled": textColorDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-loading-color": loadingColor,
            // form warning
            "--n-caret-color-warning": caretColorWarning,
            "--n-color-focus-warning": colorFocusWarning,
            "--n-box-shadow-focus-warning": boxShadowFocusWarning,
            "--n-border-warning": borderWarning,
            "--n-border-focus-warning": borderFocusWarning,
            "--n-border-hover-warning": borderHoverWarning,
            "--n-loading-color-warning": loadingColorWarning,
            // form error
            "--n-caret-color-error": caretColorError,
            "--n-color-focus-error": colorFocusError,
            "--n-box-shadow-focus-error": boxShadowFocusError,
            "--n-border-error": borderError,
            "--n-border-focus-error": borderFocusError,
            "--n-border-hover-error": borderHoverError,
            "--n-loading-color-error": loadingColorError,
            // clear-button
            "--n-clear-color": clearColor,
            "--n-clear-size": clearSize,
            "--n-clear-color-hover": clearColorHover,
            "--n-clear-color-pressed": clearColorPressed,
            "--n-icon-color": iconColor,
            "--n-icon-color-hover": iconColorHover,
            "--n-icon-color-pressed": iconColorPressed,
            "--n-icon-color-disabled": iconColorDisabled,
            "--n-suffix-text-color": suffixTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("input", computed(() => {
          const { value: size2 } = mergedSizeRef;
          return size2[0];
        }), cssVarsRef, props) : void 0;
        return Object.assign(Object.assign({}, exposedProps), {
          // DOM ref
          wrapperElRef,
          inputElRef,
          inputMirrorElRef,
          inputEl2Ref,
          textareaElRef,
          textareaMirrorElRef,
          textareaScrollbarInstRef,
          // value
          rtlEnabled: rtlEnabledRef,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          passwordVisible: passwordVisibleRef,
          mergedPlaceholder: mergedPlaceholderRef,
          showPlaceholder1: showPlaceholder1Ref,
          showPlaceholder2: showPlaceholder2Ref,
          mergedFocus: mergedFocusRef,
          isComposing: isComposingRef,
          activated: activatedRef,
          showClearButton,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          textDecorationStyle: textDecorationStyleRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedShowPasswordOn: mergedShowPasswordOnRef,
          placeholderStyle: placeholderStyleRef,
          mergedStatus: mergedStatusRef,
          textAreaScrollContainerWidth: textAreaScrollContainerWidthRef,
          // methods
          handleTextAreaScroll,
          handleCompositionStart,
          handleCompositionEnd,
          handleInput,
          handleInputBlur,
          handleInputFocus,
          handleWrapperBlur,
          handleWrapperFocus,
          handleMouseEnter,
          handleMouseLeave,
          handleMouseDown,
          handleChange,
          handleClick,
          handleClear,
          handlePasswordToggleClick,
          handlePasswordToggleMousedown,
          handleWrapperKeydown,
          handleTextAreaMirrorResize,
          getTextareaScrollContainer: () => {
            return textareaElRef.value;
          },
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a, _b;
        const { mergedClsPrefix, mergedStatus, themeClass, type: type2, countGraphemes, onRender } = this;
        const $slots = this.$slots;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h(
          "div",
          { ref: "wrapperElRef", class: [
            `${mergedClsPrefix}-input`,
            themeClass,
            mergedStatus && `${mergedClsPrefix}-input--${mergedStatus}-status`,
            {
              [`${mergedClsPrefix}-input--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-input--textarea`]: type2 === "textarea",
              [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
              [`${mergedClsPrefix}-input--autosize`]: this.autosize,
              [`${mergedClsPrefix}-input--round`]: this.round && !(type2 === "textarea"),
              [`${mergedClsPrefix}-input--pair`]: this.pair,
              [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
              [`${mergedClsPrefix}-input--stateful`]: this.stateful
            }
          ], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.onKeyup, onKeydown: this.handleWrapperKeydown },
          h(
            "div",
            { class: `${mergedClsPrefix}-input-wrapper` },
            resolveWrappedSlot($slots.prefix, (children) => children && h("div", { class: `${mergedClsPrefix}-input__prefix` }, children)),
            type2 === "textarea" ? h(NScrollbar, { ref: "textareaScrollbarInstRef", class: `${mergedClsPrefix}-input__textarea`, container: this.getTextareaScrollContainer, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, {
              default: () => {
                var _a2, _b2;
                const { textAreaScrollContainerWidth } = this;
                const scrollContainerWidthStyle = {
                  width: this.autosize && textAreaScrollContainerWidth && `${textAreaScrollContainerWidth}px`
                };
                return h(
                  Fragment,
                  null,
                  h("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [
                    `${mergedClsPrefix}-input__textarea-el`,
                    (_a2 = this.inputProps) === null || _a2 === void 0 ? void 0 : _a2.class
                  ], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: countGraphemes ? void 0 : this.maxlength, minlength: countGraphemes ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [
                    this.textDecorationStyle[0],
                    (_b2 = this.inputProps) === null || _b2 === void 0 ? void 0 : _b2.style,
                    scrollContainerWidthStyle
                  ], onBlur: this.handleInputBlur, onFocus: (e) => this.handleInputFocus(e, 2), onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })),
                  this.showPlaceholder1 ? h("div", { class: `${mergedClsPrefix}-input__placeholder`, style: [
                    this.placeholderStyle,
                    scrollContainerWidthStyle
                  ], key: "placeholder" }, this.mergedPlaceholder[0]) : null,
                  this.autosize ? h(VResizeObserver, { onResize: this.handleTextAreaMirrorResize }, {
                    default: () => h("div", { ref: "textareaMirrorElRef", class: `${mergedClsPrefix}-input__textarea-mirror`, key: "mirror" })
                  }) : null
                );
              }
            }) : h(
              "div",
              { class: `${mergedClsPrefix}-input__input` },
              h("input", Object.assign({ type: type2 === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : type2 }, this.inputProps, { ref: "inputElRef", class: [
                `${mergedClsPrefix}-input__input-el`,
                (_a = this.inputProps) === null || _a === void 0 ? void 0 : _a.class
              ], style: [
                this.textDecorationStyle[0],
                (_b = this.inputProps) === null || _b === void 0 ? void 0 : _b.style
              ], tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: countGraphemes ? void 0 : this.maxlength, minlength: countGraphemes ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (e) => this.handleInputFocus(e, 0), onInput: (e) => this.handleInput(e, 0), onChange: (e) => this.handleChange(e, 0) })),
              this.showPlaceholder1 ? h(
                "div",
                { class: `${mergedClsPrefix}-input__placeholder` },
                h("span", null, this.mergedPlaceholder[0])
              ) : null,
              this.autosize ? h("div", { class: `${mergedClsPrefix}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, " ") : null
            ),
            !this.pair && resolveWrappedSlot($slots.suffix, (children) => {
              return children || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? h("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                resolveWrappedSlot($slots["clear-icon-placeholder"], (children2) => {
                  return (this.clearable || children2) && h(NBaseClear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, {
                    placeholder: () => children2,
                    icon: () => {
                      var _a2, _b2;
                      return (_b2 = (_a2 = this.$slots)["clear-icon"]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
                    }
                  });
                }),
                !this.internalLoadingBeforeSuffix ? children : null,
                this.loading !== void 0 ? h(NBaseSuffix, { clsPrefix: mergedClsPrefix, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null,
                this.internalLoadingBeforeSuffix ? children : null,
                this.showCount && this.type !== "textarea" ? h(WordCount, null, {
                  default: (props) => {
                    var _a2;
                    return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
                  }
                }) : null,
                this.mergedShowPasswordOn && this.type === "password" ? h("div", { class: `${mergedClsPrefix}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? resolveSlot($slots["password-visible-icon"], () => [
                  h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(EyeIcon, null) })
                ]) : resolveSlot($slots["password-invisible-icon"], () => [
                  h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(EyeOffIcon, null) })
                ])) : null
              ]) : null;
            })
          ),
          this.pair ? h("span", { class: `${mergedClsPrefix}-input__separator` }, resolveSlot($slots.separator, () => [this.separator])) : null,
          this.pair ? h(
            "div",
            { class: `${mergedClsPrefix}-input-wrapper` },
            h(
              "div",
              { class: `${mergedClsPrefix}-input__input` },
              h("input", { ref: "inputEl2Ref", type: this.type, class: `${mergedClsPrefix}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: countGraphemes ? void 0 : this.maxlength, minlength: countGraphemes ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (e) => this.handleInputFocus(e, 1), onInput: (e) => this.handleInput(e, 1), onChange: (e) => this.handleChange(e, 1) }),
              this.showPlaceholder2 ? h(
                "div",
                { class: `${mergedClsPrefix}-input__placeholder` },
                h("span", null, this.mergedPlaceholder[1])
              ) : null
            ),
            resolveWrappedSlot($slots.suffix, (children) => {
              return (this.clearable || children) && h("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                this.clearable && h(NBaseClear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, {
                  icon: () => {
                    var _a2;
                    return (_a2 = $slots["clear-icon"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
                  },
                  placeholder: () => {
                    var _a2;
                    return (_a2 = $slots["clear-icon-placeholder"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
                  }
                }),
                children
              ]);
            })
          ) : null,
          this.mergedBordered ? h("div", { class: `${mergedClsPrefix}-input__border` }) : null,
          this.mergedBordered ? h("div", { class: `${mergedClsPrefix}-input__state-border` }) : null,
          this.showCount && type2 === "textarea" ? h(WordCount, null, {
            default: (props) => {
              var _a2;
              const { renderCount } = this;
              if (renderCount) {
                return renderCount(props);
              }
              return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
            }
          }) : null
        );
      }
    });
    function createHoverColor(rgb) {
      return composite(rgb, [255, 255, 255, 0.16]);
    }
    function createPressedColor(rgb) {
      return composite(rgb, [0, 0, 0, 0.12]);
    }
    const buttonGroupInjectionKey = createInjectionKey("n-button-group");
    const commonVariables$8 = {
      paddingTiny: "0 6px",
      paddingSmall: "0 10px",
      paddingMedium: "0 14px",
      paddingLarge: "0 18px",
      paddingRoundTiny: "0 10px",
      paddingRoundSmall: "0 14px",
      paddingRoundMedium: "0 18px",
      paddingRoundLarge: "0 22px",
      iconMarginTiny: "6px",
      iconMarginSmall: "6px",
      iconMarginMedium: "6px",
      iconMarginLarge: "6px",
      iconSizeTiny: "14px",
      iconSizeSmall: "18px",
      iconSizeMedium: "18px",
      iconSizeLarge: "20px",
      rippleDuration: ".6s"
    };
    const self$e = (vars) => {
      const { heightTiny, heightSmall, heightMedium, heightLarge, borderRadius, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, opacityDisabled, textColor2, textColor3, primaryColorHover, primaryColorPressed, borderColor, primaryColor, baseColor, infoColor, infoColorHover, infoColorPressed, successColor, successColorHover, successColorPressed, warningColor, warningColorHover, warningColorPressed, errorColor, errorColorHover, errorColorPressed, fontWeight, buttonColor2, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVariables$8), {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadiusTiny: borderRadius,
        borderRadiusSmall: borderRadius,
        borderRadiusMedium: borderRadius,
        borderRadiusLarge: borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        // secondary
        colorOpacitySecondary: "0.16",
        colorOpacitySecondaryHover: "0.22",
        colorOpacitySecondaryPressed: "0.28",
        colorSecondary: buttonColor2,
        colorSecondaryHover: buttonColor2Hover,
        colorSecondaryPressed: buttonColor2Pressed,
        // tertiary
        colorTertiary: buttonColor2,
        colorTertiaryHover: buttonColor2Hover,
        colorTertiaryPressed: buttonColor2Pressed,
        // quaternary
        colorQuaternary: "#0000",
        colorQuaternaryHover: buttonColor2Hover,
        colorQuaternaryPressed: buttonColor2Pressed,
        // default type
        color: "#0000",
        colorHover: "#0000",
        colorPressed: "#0000",
        colorFocus: "#0000",
        colorDisabled: "#0000",
        textColor: textColor2,
        textColorTertiary: textColor3,
        textColorHover: primaryColorHover,
        textColorPressed: primaryColorPressed,
        textColorFocus: primaryColorHover,
        textColorDisabled: textColor2,
        textColorText: textColor2,
        textColorTextHover: primaryColorHover,
        textColorTextPressed: primaryColorPressed,
        textColorTextFocus: primaryColorHover,
        textColorTextDisabled: textColor2,
        textColorGhost: textColor2,
        textColorGhostHover: primaryColorHover,
        textColorGhostPressed: primaryColorPressed,
        textColorGhostFocus: primaryColorHover,
        textColorGhostDisabled: textColor2,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderPressed: `1px solid ${primaryColorPressed}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        rippleColor: primaryColor,
        // primary
        colorPrimary: primaryColor,
        colorHoverPrimary: primaryColorHover,
        colorPressedPrimary: primaryColorPressed,
        colorFocusPrimary: primaryColorHover,
        colorDisabledPrimary: primaryColor,
        textColorPrimary: baseColor,
        textColorHoverPrimary: baseColor,
        textColorPressedPrimary: baseColor,
        textColorFocusPrimary: baseColor,
        textColorDisabledPrimary: baseColor,
        textColorTextPrimary: primaryColor,
        textColorTextHoverPrimary: primaryColorHover,
        textColorTextPressedPrimary: primaryColorPressed,
        textColorTextFocusPrimary: primaryColorHover,
        textColorTextDisabledPrimary: textColor2,
        textColorGhostPrimary: primaryColor,
        textColorGhostHoverPrimary: primaryColorHover,
        textColorGhostPressedPrimary: primaryColorPressed,
        textColorGhostFocusPrimary: primaryColorHover,
        textColorGhostDisabledPrimary: primaryColor,
        borderPrimary: `1px solid ${primaryColor}`,
        borderHoverPrimary: `1px solid ${primaryColorHover}`,
        borderPressedPrimary: `1px solid ${primaryColorPressed}`,
        borderFocusPrimary: `1px solid ${primaryColorHover}`,
        borderDisabledPrimary: `1px solid ${primaryColor}`,
        rippleColorPrimary: primaryColor,
        // info
        colorInfo: infoColor,
        colorHoverInfo: infoColorHover,
        colorPressedInfo: infoColorPressed,
        colorFocusInfo: infoColorHover,
        colorDisabledInfo: infoColor,
        textColorInfo: baseColor,
        textColorHoverInfo: baseColor,
        textColorPressedInfo: baseColor,
        textColorFocusInfo: baseColor,
        textColorDisabledInfo: baseColor,
        textColorTextInfo: infoColor,
        textColorTextHoverInfo: infoColorHover,
        textColorTextPressedInfo: infoColorPressed,
        textColorTextFocusInfo: infoColorHover,
        textColorTextDisabledInfo: textColor2,
        textColorGhostInfo: infoColor,
        textColorGhostHoverInfo: infoColorHover,
        textColorGhostPressedInfo: infoColorPressed,
        textColorGhostFocusInfo: infoColorHover,
        textColorGhostDisabledInfo: infoColor,
        borderInfo: `1px solid ${infoColor}`,
        borderHoverInfo: `1px solid ${infoColorHover}`,
        borderPressedInfo: `1px solid ${infoColorPressed}`,
        borderFocusInfo: `1px solid ${infoColorHover}`,
        borderDisabledInfo: `1px solid ${infoColor}`,
        rippleColorInfo: infoColor,
        // success
        colorSuccess: successColor,
        colorHoverSuccess: successColorHover,
        colorPressedSuccess: successColorPressed,
        colorFocusSuccess: successColorHover,
        colorDisabledSuccess: successColor,
        textColorSuccess: baseColor,
        textColorHoverSuccess: baseColor,
        textColorPressedSuccess: baseColor,
        textColorFocusSuccess: baseColor,
        textColorDisabledSuccess: baseColor,
        textColorTextSuccess: successColor,
        textColorTextHoverSuccess: successColorHover,
        textColorTextPressedSuccess: successColorPressed,
        textColorTextFocusSuccess: successColorHover,
        textColorTextDisabledSuccess: textColor2,
        textColorGhostSuccess: successColor,
        textColorGhostHoverSuccess: successColorHover,
        textColorGhostPressedSuccess: successColorPressed,
        textColorGhostFocusSuccess: successColorHover,
        textColorGhostDisabledSuccess: successColor,
        borderSuccess: `1px solid ${successColor}`,
        borderHoverSuccess: `1px solid ${successColorHover}`,
        borderPressedSuccess: `1px solid ${successColorPressed}`,
        borderFocusSuccess: `1px solid ${successColorHover}`,
        borderDisabledSuccess: `1px solid ${successColor}`,
        rippleColorSuccess: successColor,
        // warning
        colorWarning: warningColor,
        colorHoverWarning: warningColorHover,
        colorPressedWarning: warningColorPressed,
        colorFocusWarning: warningColorHover,
        colorDisabledWarning: warningColor,
        textColorWarning: baseColor,
        textColorHoverWarning: baseColor,
        textColorPressedWarning: baseColor,
        textColorFocusWarning: baseColor,
        textColorDisabledWarning: baseColor,
        textColorTextWarning: warningColor,
        textColorTextHoverWarning: warningColorHover,
        textColorTextPressedWarning: warningColorPressed,
        textColorTextFocusWarning: warningColorHover,
        textColorTextDisabledWarning: textColor2,
        textColorGhostWarning: warningColor,
        textColorGhostHoverWarning: warningColorHover,
        textColorGhostPressedWarning: warningColorPressed,
        textColorGhostFocusWarning: warningColorHover,
        textColorGhostDisabledWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderPressedWarning: `1px solid ${warningColorPressed}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        borderDisabledWarning: `1px solid ${warningColor}`,
        rippleColorWarning: warningColor,
        // error
        colorError: errorColor,
        colorHoverError: errorColorHover,
        colorPressedError: errorColorPressed,
        colorFocusError: errorColorHover,
        colorDisabledError: errorColor,
        textColorError: baseColor,
        textColorHoverError: baseColor,
        textColorPressedError: baseColor,
        textColorFocusError: baseColor,
        textColorDisabledError: baseColor,
        textColorTextError: errorColor,
        textColorTextHoverError: errorColorHover,
        textColorTextPressedError: errorColorPressed,
        textColorTextFocusError: errorColorHover,
        textColorTextDisabledError: textColor2,
        textColorGhostError: errorColor,
        textColorGhostHoverError: errorColorHover,
        textColorGhostPressedError: errorColorPressed,
        textColorGhostFocusError: errorColorHover,
        textColorGhostDisabledError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderPressedError: `1px solid ${errorColorPressed}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        borderDisabledError: `1px solid ${errorColor}`,
        rippleColorError: errorColor,
        waveOpacity: "0.6",
        fontWeight,
        fontWeightStrong
      });
    };
    const buttonLight = {
      name: "Button",
      common: commonLight,
      self: self$e
    };
    const buttonLight$1 = buttonLight;
    const style$g = c$1([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("color", [cE("border", {
      borderColor: "var(--n-border-color)"
    }), cM("disabled", [cE("border", {
      borderColor: "var(--n-border-color-disabled)"
    })]), cNotM("disabled", [c$1("&:focus", [cE("state-border", {
      borderColor: "var(--n-border-color-focus)"
    })]), c$1("&:hover", [cE("state-border", {
      borderColor: "var(--n-border-color-hover)"
    })]), c$1("&:active", [cE("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })]), cM("pressed", [cE("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })])])]), cM("disabled", {
      backgroundColor: "var(--n-color-disabled)",
      color: "var(--n-text-color-disabled)"
    }, [cE("border", {
      border: "var(--n-border-disabled)"
    })]), cNotM("disabled", [c$1("&:focus", {
      backgroundColor: "var(--n-color-focus)",
      color: "var(--n-text-color-focus)"
    }, [cE("state-border", {
      border: "var(--n-border-focus)"
    })]), c$1("&:hover", {
      backgroundColor: "var(--n-color-hover)",
      color: "var(--n-text-color-hover)"
    }, [cE("state-border", {
      border: "var(--n-border-hover)"
    })]), c$1("&:active", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE("state-border", {
      border: "var(--n-border-pressed)"
    })]), cM("pressed", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE("state-border", {
      border: "var(--n-border-pressed)"
    })])]), cM("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM("active", {
      zIndex: 1,
      animationName: "button-wave-spread, button-wave-opacity"
    })]), isBrowser$2 && "MozBoxSizing" in document.createElement("div").style ? c$1("&::moz-focus-inner", {
      border: 0
    }) : null, cE("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE("border", {
      border: "var(--n-border)"
    }), cE("state-border", {
      border: "var(--n-border)",
      borderColor: "#0000",
      zIndex: 1
    }), cE("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
      top: "50%",
      originalTransform: "translateY(-50%)"
    })]), fadeInWidthExpandTransition()]), cE("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c$1("~", [cE("icon", {
      margin: "var(--n-icon-margin)",
      marginRight: 0
    })])]), cM("block", `
 display: flex;
 width: 100%;
 `), cM("dashed", [cE("border, state-border", {
      borderStyle: "dashed !important"
    })]), cM("disabled", {
      cursor: "not-allowed",
      opacity: "var(--n-opacity-disabled)"
    })]), c$1("@keyframes button-wave-spread", {
      from: {
        boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
      },
      to: {
        // don't use exact 5px since chrome will display the animation with glitches
        boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
      }
    }), c$1("@keyframes button-wave-opacity", {
      from: {
        opacity: "var(--n-wave-opacity)"
      },
      to: {
        opacity: 0
      }
    })]);
    const buttonProps = Object.assign(Object.assign({}, useTheme.props), { color: String, textColor: String, text: Boolean, block: Boolean, loading: Boolean, disabled: Boolean, circle: Boolean, size: String, ghost: Boolean, round: Boolean, secondary: Boolean, tertiary: Boolean, quaternary: Boolean, strong: Boolean, focusable: {
      type: Boolean,
      default: true
    }, keyboard: {
      type: Boolean,
      default: true
    }, tag: {
      type: String,
      default: "button"
    }, type: {
      type: String,
      default: "default"
    }, dashed: Boolean, renderIcon: Function, iconPlacement: {
      type: String,
      default: "left"
    }, attrType: {
      type: String,
      default: "button"
    }, bordered: {
      type: Boolean,
      default: true
    }, onClick: [Function, Array], nativeFocusBehavior: {
      type: Boolean,
      default: !isSafari
    } });
    const Button = defineComponent({
      name: "Button",
      props: buttonProps,
      setup(props) {
        const selfElRef = ref(null);
        const waveElRef = ref(null);
        const enterPressedRef = ref(false);
        const showBorderRef = useMemo(() => {
          return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
        });
        const NButtonGroup2 = inject(buttonGroupInjectionKey, {});
        const { mergedSizeRef } = useFormItem({}, {
          defaultSize: "medium",
          mergedSize: (NFormItem2) => {
            const { size: size2 } = props;
            if (size2)
              return size2;
            const { size: buttonGroupSize } = NButtonGroup2;
            if (buttonGroupSize)
              return buttonGroupSize;
            const { mergedSize: formItemSize2 } = NFormItem2 || {};
            if (formItemSize2) {
              return formItemSize2.value;
            }
            return "medium";
          }
        });
        const mergedFocusableRef = computed(() => {
          return props.focusable && !props.disabled;
        });
        const handleMousedown = (e) => {
          var _a;
          if (!mergedFocusableRef.value) {
            e.preventDefault();
          }
          if (props.nativeFocusBehavior) {
            return;
          }
          e.preventDefault();
          if (props.disabled) {
            return;
          }
          if (mergedFocusableRef.value) {
            (_a = selfElRef.value) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
          }
        };
        const handleClick = (e) => {
          var _a;
          if (!props.disabled && !props.loading) {
            const { onClick } = props;
            if (onClick)
              call(onClick, e);
            if (!props.text) {
              (_a = waveElRef.value) === null || _a === void 0 ? void 0 : _a.play();
            }
          }
        };
        const handleKeyup = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard) {
                return;
              }
              enterPressedRef.value = false;
          }
        };
        const handleKeydown = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard || props.loading) {
                e.preventDefault();
                return;
              }
              enterPressedRef.value = true;
          }
        };
        const handleBlur = () => {
          enterPressedRef.value = false;
        };
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Button", "-button", style$g, buttonLight$1, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const theme = themeRef.value;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: self2 } = theme;
          const { rippleDuration, opacityDisabled, fontWeight, fontWeightStrong } = self2;
          const size2 = mergedSizeRef.value;
          const { dashed, type: type2, ghost, text, color, round, circle, textColor, secondary, tertiary, quaternary, strong } = props;
          const fontProps = {
            "font-weight": strong ? fontWeightStrong : fontWeight
          };
          let colorProps = {
            "--n-color": "initial",
            "--n-color-hover": "initial",
            "--n-color-pressed": "initial",
            "--n-color-focus": "initial",
            "--n-color-disabled": "initial",
            "--n-ripple-color": "initial",
            "--n-text-color": "initial",
            "--n-text-color-hover": "initial",
            "--n-text-color-pressed": "initial",
            "--n-text-color-focus": "initial",
            "--n-text-color-disabled": "initial"
          };
          const typeIsTertiary = type2 === "tertiary";
          const typeIsDefault = type2 === "default";
          const mergedType = typeIsTertiary ? "default" : type2;
          if (text) {
            const propTextColor = textColor || color;
            const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
              "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
            };
          } else if (ghost || dashed) {
            const mergedTextColor = textColor || color;
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
              "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
              "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
            };
          } else if (secondary) {
            const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedTextColor = color || typeTextColor;
            const isColoredType = type2 !== "default" && type2 !== "tertiary";
            colorProps = {
              "--n-color": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondary)
              }) : self2.colorSecondary,
              "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryPressed)
              }) : self2.colorSecondaryPressed,
              "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-disabled": self2.colorSecondary,
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": mergedTextColor,
              "--n-text-color-pressed": mergedTextColor,
              "--n-text-color-focus": mergedTextColor,
              "--n-text-color-disabled": mergedTextColor
            };
          } else if (tertiary || quaternary) {
            const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedColor = color || typeColor;
            if (tertiary) {
              colorProps["--n-color"] = self2.colorTertiary;
              colorProps["--n-color-hover"] = self2.colorTertiaryHover;
              colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
              colorProps["--n-color-focus"] = self2.colorSecondaryHover;
              colorProps["--n-color-disabled"] = self2.colorTertiary;
            } else {
              colorProps["--n-color"] = self2.colorQuaternary;
              colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
              colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
              colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
              colorProps["--n-color-disabled"] = self2.colorQuaternary;
            }
            colorProps["--n-ripple-color"] = "#0000";
            colorProps["--n-text-color"] = mergedColor;
            colorProps["--n-text-color-hover"] = mergedColor;
            colorProps["--n-text-color-pressed"] = mergedColor;
            colorProps["--n-text-color-focus"] = mergedColor;
            colorProps["--n-text-color-disabled"] = mergedColor;
          } else {
            colorProps = {
              "--n-color": color || self2[createKey("color", mergedType)],
              "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
              "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
              "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
              "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
              "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
              "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
              "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
              "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
            };
          }
          let borderProps = {
            "--n-border": "initial",
            "--n-border-hover": "initial",
            "--n-border-pressed": "initial",
            "--n-border-focus": "initial",
            "--n-border-disabled": "initial"
          };
          if (text) {
            borderProps = {
              "--n-border": "none",
              "--n-border-hover": "none",
              "--n-border-pressed": "none",
              "--n-border-focus": "none",
              "--n-border-disabled": "none"
            };
          } else {
            borderProps = {
              "--n-border": self2[createKey("border", mergedType)],
              "--n-border-hover": self2[createKey("borderHover", mergedType)],
              "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
              "--n-border-focus": self2[createKey("borderFocus", mergedType)],
              "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
            };
          }
          const { [createKey("height", size2)]: height, [createKey("fontSize", size2)]: fontSize2, [createKey("padding", size2)]: padding, [createKey("paddingRound", size2)]: paddingRound, [createKey("iconSize", size2)]: iconSize, [createKey("borderRadius", size2)]: borderRadius, [createKey("iconMargin", size2)]: iconMargin, waveOpacity } = self2;
          const sizeProps = {
            "--n-width": circle && !text ? height : "initial",
            "--n-height": text ? "initial" : height,
            "--n-font-size": fontSize2,
            "--n-padding": circle ? "initial" : text ? "initial" : round ? paddingRound : padding,
            "--n-icon-size": iconSize,
            "--n-icon-margin": iconMargin,
            "--n-border-radius": text ? "initial" : circle || round ? height : borderRadius
          };
          return Object.assign(Object.assign(Object.assign(Object.assign({ "--n-bezier": cubicBezierEaseInOut2, "--n-bezier-ease-out": cubicBezierEaseOut2, "--n-ripple-duration": rippleDuration, "--n-opacity-disabled": opacityDisabled, "--n-wave-opacity": waveOpacity }, fontProps), colorProps), borderProps), sizeProps);
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", computed(() => {
          let hash = "";
          const { dashed, type: type2, ghost, text, color, round, circle, textColor, secondary, tertiary, quaternary, strong } = props;
          if (dashed)
            hash += "a";
          if (ghost)
            hash += "b";
          if (text)
            hash += "c";
          if (round)
            hash += "d";
          if (circle)
            hash += "e";
          if (secondary)
            hash += "f";
          if (tertiary)
            hash += "g";
          if (quaternary)
            hash += "h";
          if (strong)
            hash += "i";
          if (color)
            hash += "j" + color2Class(color);
          if (textColor)
            hash += "k" + color2Class(textColor);
          const { value: size2 } = mergedSizeRef;
          hash += "l" + size2[0];
          hash += "m" + type2[0];
          return hash;
        }), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          waveElRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedFocusable: mergedFocusableRef,
          mergedSize: mergedSizeRef,
          showBorder: showBorderRef,
          enterPressed: enterPressedRef,
          rtlEnabled: rtlEnabledRef,
          handleMousedown,
          handleKeydown,
          handleBlur,
          handleKeyup,
          handleClick,
          customColorCssVars: computed(() => {
            const { color } = props;
            if (!color)
              return null;
            const hoverColor = createHoverColor(color);
            return {
              "--n-border-color": color,
              "--n-border-color-hover": hoverColor,
              "--n-border-color-pressed": createPressedColor(color),
              "--n-border-color-focus": hoverColor,
              "--n-border-color-disabled": color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { mergedClsPrefix, tag: Component, onRender } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && h("span", { class: `${mergedClsPrefix}-button__content` }, children2));
        return h(
          Component,
          { ref: "selfElRef", class: [
            this.themeClass,
            `${mergedClsPrefix}-button`,
            `${mergedClsPrefix}-button--${this.type}-type`,
            `${mergedClsPrefix}-button--${this.mergedSize}-type`,
            this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
            this.disabled && `${mergedClsPrefix}-button--disabled`,
            this.block && `${mergedClsPrefix}-button--block`,
            this.enterPressed && `${mergedClsPrefix}-button--pressed`,
            !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
            this.color && `${mergedClsPrefix}-button--color`,
            this.secondary && `${mergedClsPrefix}-button--secondary`,
            this.loading && `${mergedClsPrefix}-button--loading`,
            this.ghost && `${mergedClsPrefix}-button--ghost`
            // required for button group border collapse
          ], tabindex: this.mergedFocusable ? 0 : -1, type: this.attrType, style: this.cssVars, disabled: this.disabled, onClick: this.handleClick, onBlur: this.handleBlur, onMousedown: this.handleMousedown, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
          this.iconPlacement === "right" && children,
          h(NFadeInExpandTransition, { width: true }, {
            default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && h(
              "span",
              { class: `${mergedClsPrefix}-button__icon`, style: {
                margin: isSlotEmpty(this.$slots.default) ? "0" : ""
              } },
              h(NIconSwitchTransition, null, {
                default: () => this.loading ? h(NBaseLoading, { clsPrefix: mergedClsPrefix, key: "loading", class: `${mergedClsPrefix}-icon-slot`, strokeWidth: 20 }) : h("div", { key: "icon", class: `${mergedClsPrefix}-icon-slot`, role: "none" }, this.renderIcon ? this.renderIcon() : children2)
              })
            ))
          }),
          this.iconPlacement === "left" && children,
          !this.text ? h(NBaseWave, { ref: "waveElRef", clsPrefix: mergedClsPrefix }) : null,
          this.showBorder ? h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__border`, style: this.customColorCssVars }) : null,
          this.showBorder ? h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__state-border`, style: this.customColorCssVars }) : null
        );
      }
    });
    const NButton = Button;
    const zero = "0!important";
    const n1 = "-1px!important";
    function createLeftBorderStyle(type2) {
      return cM(type2 + "-type", [c$1("& +", [cB("button", {}, [cM(type2 + "-type", [cE("border", {
        borderLeftWidth: zero
      }), cE("state-border", {
        left: n1
      })])])])]);
    }
    function createTopBorderStyle(type2) {
      return cM(type2 + "-type", [c$1("& +", [cB("button", [cM(type2 + "-type", [cE("border", {
        borderTopWidth: zero
      }), cE("state-border", {
        top: n1
      })])])])]);
    }
    const style$f = cB("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM("vertical", {
      flexDirection: "row"
    }, [cNotM("rtl", [cB("button", [c$1("&:first-child:not(:last-child)", `
 margin-right: ${zero};
 border-top-right-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1("&:last-child:not(:first-child)", `
 margin-left: ${zero};
 border-top-left-radius: ${zero};
 border-bottom-left-radius: ${zero};
 `), c$1("&:not(:first-child):not(:last-child)", `
 margin-left: ${zero};
 margin-right: ${zero};
 border-radius: ${zero};
 `), createLeftBorderStyle("default"), cM("ghost", [createLeftBorderStyle("primary"), createLeftBorderStyle("info"), createLeftBorderStyle("success"), createLeftBorderStyle("warning"), createLeftBorderStyle("error")])])])]), cM("vertical", {
      flexDirection: "column"
    }, [cB("button", [c$1("&:first-child:not(:last-child)", `
 margin-bottom: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-bottom-left-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1("&:last-child:not(:first-child)", `
 margin-top: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-top-left-radius: ${zero};
 border-top-right-radius: ${zero};
 `), c$1("&:not(:first-child):not(:last-child)", `
 margin: ${zero};
 border-radius: ${zero};
 `), createTopBorderStyle("default"), cM("ghost", [createTopBorderStyle("primary"), createTopBorderStyle("info"), createTopBorderStyle("success"), createTopBorderStyle("warning"), createTopBorderStyle("error")])])])]);
    const buttonGroupProps = {
      size: {
        type: String,
        default: void 0
      },
      vertical: Boolean
    };
    const NButtonGroup = defineComponent({
      name: "ButtonGroup",
      props: buttonGroupProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        useStyle("-button-group", style$f, mergedClsPrefixRef);
        provide(buttonGroupInjectionKey, props);
        const rtlEnabledRef = useRtl("ButtonGroup", mergedRtlRef, mergedClsPrefixRef);
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return h("div", { class: [
          `${mergedClsPrefix}-button-group`,
          this.rtlEnabled && `${mergedClsPrefix}-button-group--rtl`,
          this.vertical && `${mergedClsPrefix}-button-group--vertical`
        ], role: "group" }, this.$slots);
      }
    });
    const commonVariables$7 = {
      paddingSmall: "12px 16px 12px",
      paddingMedium: "19px 24px 20px",
      paddingLarge: "23px 32px 24px",
      paddingHuge: "27px 40px 28px",
      titleFontSizeSmall: "16px",
      titleFontSizeMedium: "18px",
      titleFontSizeLarge: "18px",
      titleFontSizeHuge: "18px",
      closeIconSize: "18px",
      closeSize: "22px"
    };
    const self$d = (vars) => {
      const { primaryColor, borderRadius, lineHeight: lineHeight2, fontSize: fontSize2, cardColor, textColor2, textColor1, dividerColor, fontWeightStrong, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, modalColor, boxShadow1, popoverColor, actionColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$7), {
        lineHeight: lineHeight2,
        color: cardColor,
        colorModal: modalColor,
        colorPopover: popoverColor,
        colorTarget: primaryColor,
        colorEmbedded: actionColor,
        colorEmbeddedModal: actionColor,
        colorEmbeddedPopover: actionColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        borderColor: dividerColor,
        actionColor,
        titleFontWeight: fontWeightStrong,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        fontSizeSmall: fontSize2,
        fontSizeMedium: fontSize2,
        fontSizeLarge: fontSize2,
        fontSizeHuge: fontSize2,
        boxShadow: boxShadow1,
        borderRadius
      });
    };
    const cardLight = {
      name: "Card",
      common: commonLight,
      self: self$d
    };
    const cardLight$1 = cardLight;
    const style$e = c$1([cB("card", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 color: var(--n-text-color);
 word-break: break-word;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [asModal({
      background: "var(--n-color-modal)"
    }), cM("hoverable", [c$1("&:hover", "box-shadow: var(--n-box-shadow);")]), cM("content-segmented", [c$1(">", [cE("content", {
      paddingTop: "var(--n-padding-bottom)"
    })])]), cM("content-soft-segmented", [c$1(">", [cE("content", `
 margin: 0 var(--n-padding-left);
 padding: var(--n-padding-bottom) 0;
 `)])]), cM("footer-segmented", [c$1(">", [cE("footer", {
      paddingTop: "var(--n-padding-bottom)"
    })])]), cM("footer-soft-segmented", [c$1(">", [cE("footer", `
 padding: var(--n-padding-bottom) 0;
 margin: 0 var(--n-padding-left);
 `)])]), c$1(">", [cB("card-header", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 padding:
 var(--n-padding-top)
 var(--n-padding-left)
 var(--n-padding-bottom)
 var(--n-padding-left);
 `, [cE("main", `
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 min-width: 0;
 color: var(--n-title-text-color);
 `), cE("extra", `
 display: flex;
 align-items: center;
 font-size: var(--n-font-size);
 font-weight: 400;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("close", `
 margin: 0 0 0 8px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("action", `
 box-sizing: border-box;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 background-clip: padding-box;
 background-color: var(--n-action-color);
 `), cE("content", "flex: 1; min-width: 0;"), cE("content, footer", `
 box-sizing: border-box;
 padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
 font-size: var(--n-font-size);
 `, [c$1("&:first-child", {
      paddingTop: "var(--n-padding-bottom)"
    })]), cE("action", `
 background-color: var(--n-action-color);
 padding: var(--n-padding-bottom) var(--n-padding-left);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `)]), cB("card-cover", `
 overflow: hidden;
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 `, [c$1("img", `
 display: block;
 width: 100%;
 `)]), cM("bordered", `
 border: 1px solid var(--n-border-color);
 `, [c$1("&:target", "border-color: var(--n-color-target);")]), cM("action-segmented", [c$1(">", [cE("action", [c$1("&:not(:first-child)", {
      borderTop: "1px solid var(--n-border-color)"
    })])])]), cM("content-segmented, content-soft-segmented", [c$1(">", [cE("content", {
      transition: "border-color 0.3s var(--n-bezier)"
    }, [c$1("&:not(:first-child)", {
      borderTop: "1px solid var(--n-border-color)"
    })])])]), cM("footer-segmented, footer-soft-segmented", [c$1(">", [cE("footer", {
      transition: "border-color 0.3s var(--n-bezier)"
    }, [c$1("&:not(:first-child)", {
      borderTop: "1px solid var(--n-border-color)"
    })])])]), cM("embedded", `
 background-color: var(--n-color-embedded);
 `)]), insideModal(cB("card", `
 background: var(--n-color-modal);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-modal);
 `)])), insidePopover(cB("card", `
 background: var(--n-color-popover);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-popover);
 `)]))]);
    const cardBaseProps = {
      title: String,
      contentStyle: [Object, String],
      headerStyle: [Object, String],
      headerExtraStyle: [Object, String],
      footerStyle: [Object, String],
      embedded: Boolean,
      segmented: {
        type: [Boolean, Object],
        default: false
      },
      size: {
        type: String,
        default: "medium"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      closable: Boolean,
      hoverable: Boolean,
      role: String,
      onClose: [Function, Array],
      tag: {
        type: String,
        default: "div"
      }
    };
    const cardProps = Object.assign(Object.assign({}, useTheme.props), cardBaseProps);
    const NCard = defineComponent({
      name: "Card",
      props: cardProps,
      setup(props) {
        const handleCloseClick = () => {
          const { onClose } = props;
          if (onClose)
            call(onClose);
        };
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Card", "-card", style$e, cardLight$1, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Card", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { size: size2 } = props;
          const { self: { color, colorModal, colorTarget, textColor, titleTextColor, titleFontWeight, borderColor, actionColor, borderRadius, lineHeight: lineHeight2, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, closeBorderRadius, closeIconSize, closeSize, boxShadow, colorPopover, colorEmbedded, colorEmbeddedModal, colorEmbeddedPopover, [createKey("padding", size2)]: padding, [createKey("fontSize", size2)]: fontSize2, [createKey("titleFontSize", size2)]: titleFontSize }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
          const { top: paddingTop, left: paddingLeft, bottom: paddingBottom } = getMargin(padding);
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-border-radius": borderRadius,
            "--n-color": color,
            "--n-color-modal": colorModal,
            "--n-color-popover": colorPopover,
            "--n-color-embedded": colorEmbedded,
            "--n-color-embedded-modal": colorEmbeddedModal,
            "--n-color-embedded-popover": colorEmbeddedPopover,
            "--n-color-target": colorTarget,
            "--n-text-color": textColor,
            "--n-line-height": lineHeight2,
            "--n-action-color": actionColor,
            "--n-title-text-color": titleTextColor,
            "--n-title-font-weight": titleFontWeight,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-border-color": borderColor,
            "--n-box-shadow": boxShadow,
            // size
            "--n-padding-top": paddingTop,
            "--n-padding-bottom": paddingBottom,
            "--n-padding-left": paddingLeft,
            "--n-font-size": fontSize2,
            "--n-title-font-size": titleFontSize,
            "--n-close-size": closeSize,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("card", computed(() => {
          return props.size[0];
        }), cssVarsRef, props) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: themeRef,
          handleCloseClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { segmented, bordered, hoverable, mergedClsPrefix, rtlEnabled, onRender, embedded, tag: Component, $slots } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h(
          Component,
          { class: [
            `${mergedClsPrefix}-card`,
            this.themeClass,
            embedded && `${mergedClsPrefix}-card--embedded`,
            {
              [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
              [`${mergedClsPrefix}-card--content${typeof segmented !== "boolean" && segmented.content === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.content,
              [`${mergedClsPrefix}-card--footer${typeof segmented !== "boolean" && segmented.footer === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.footer,
              [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || segmented !== false && segmented.action,
              [`${mergedClsPrefix}-card--bordered`]: bordered,
              [`${mergedClsPrefix}-card--hoverable`]: hoverable
            }
          ], style: this.cssVars, role: this.role },
          resolveWrappedSlot($slots.cover, (children) => children && h("div", { class: `${mergedClsPrefix}-card-cover`, role: "none" }, children)),
          resolveWrappedSlot($slots.header, (children) => {
            return children || this.title || this.closable ? h(
              "div",
              { class: `${mergedClsPrefix}-card-header`, style: this.headerStyle },
              h("div", { class: `${mergedClsPrefix}-card-header__main`, role: "heading" }, children || this.title),
              resolveWrappedSlot($slots["header-extra"], (children2) => children2 && h("div", { class: `${mergedClsPrefix}-card-header__extra`, style: this.headerExtraStyle }, children2)),
              this.closable ? h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-card-header__close`, onClick: this.handleCloseClick, absolute: true }) : null
            ) : null;
          }),
          resolveWrappedSlot($slots.default, (children) => children && h("div", { class: `${mergedClsPrefix}-card__content`, style: this.contentStyle, role: "none" }, children)),
          resolveWrappedSlot($slots.footer, (children) => children && [
            h("div", { class: `${mergedClsPrefix}-card__footer`, style: this.footerStyle, role: "none" }, children)
          ]),
          resolveWrappedSlot($slots.action, (children) => children && h("div", { class: `${mergedClsPrefix}-card__action`, role: "none" }, children))
        );
      }
    });
    const commonVariables$6 = {
      sizeSmall: "14px",
      sizeMedium: "16px",
      sizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    const self$c = (vars) => {
      const { baseColor, inputColorDisabled, cardColor, modalColor, popoverColor, textColorDisabled, borderColor, primaryColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, borderRadiusSmall, lineHeight: lineHeight2 } = vars;
      return Object.assign(Object.assign({}, commonVariables$6), {
        labelLineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius: borderRadiusSmall,
        color: baseColor,
        colorChecked: primaryColor,
        colorDisabled: inputColorDisabled,
        colorDisabledChecked: inputColorDisabled,
        colorTableHeader: cardColor,
        colorTableHeaderModal: modalColor,
        colorTableHeaderPopover: popoverColor,
        checkMarkColor: baseColor,
        checkMarkColorDisabled: textColorDisabled,
        checkMarkColorDisabledChecked: textColorDisabled,
        border: `1px solid ${borderColor}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderDisabledChecked: `1px solid ${borderColor}`,
        borderChecked: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColor}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
        textColor: textColor2,
        textColorDisabled
      });
    };
    const checkboxLight = {
      name: "Checkbox",
      common: commonLight,
      self: self$c
    };
    const checkboxLight$1 = checkboxLight;
    const CheckMark = h(
      "svg",
      { viewBox: "0 0 64 64", class: "check-icon" },
      h("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })
    );
    const LineMark = h(
      "svg",
      { viewBox: "0 0 100 100", class: "line-icon" },
      h("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })
    );
    const checkboxGroupInjectionKey = createInjectionKey("n-checkbox-group");
    const checkboxGroupProps = {
      min: Number,
      max: Number,
      size: String,
      value: Array,
      defaultValue: {
        type: Array,
        default: null
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      // deprecated
      onChange: [Function, Array]
    };
    const NCheckboxGroup = defineComponent({
      name: "CheckboxGroup",
      props: checkboxGroupProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = computed(() => props.value);
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const checkedCount = computed(() => {
          var _a;
          return ((_a = mergedValueRef.value) === null || _a === void 0 ? void 0 : _a.length) || 0;
        });
        const valueSetRef = computed(() => {
          if (Array.isArray(mergedValueRef.value)) {
            return new Set(mergedValueRef.value);
          }
          return /* @__PURE__ */ new Set();
        });
        function toggleCheckbox(checked, checkboxValue) {
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          const { onChange, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
          if (Array.isArray(mergedValueRef.value)) {
            const groupValue = Array.from(mergedValueRef.value);
            const index = groupValue.findIndex((value) => value === checkboxValue);
            if (checked) {
              if (!~index) {
                groupValue.push(checkboxValue);
                if (onUpdateValue) {
                  call(onUpdateValue, groupValue, {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, groupValue, {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                nTriggerFormInput();
                nTriggerFormChange();
                uncontrolledValueRef.value = groupValue;
                if (onChange)
                  call(onChange, groupValue);
              }
            } else {
              if (~index) {
                groupValue.splice(index, 1);
                if (onUpdateValue) {
                  call(onUpdateValue, groupValue, {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, groupValue, {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (onChange)
                  call(onChange, groupValue);
                uncontrolledValueRef.value = groupValue;
                nTriggerFormInput();
                nTriggerFormChange();
              }
            }
          } else {
            if (checked) {
              if (onUpdateValue) {
                call(onUpdateValue, [checkboxValue], {
                  actionType: "check",
                  value: checkboxValue
                });
              }
              if (_onUpdateValue) {
                call(_onUpdateValue, [checkboxValue], {
                  actionType: "check",
                  value: checkboxValue
                });
              }
              if (onChange)
                call(onChange, [checkboxValue]);
              uncontrolledValueRef.value = [checkboxValue];
              nTriggerFormInput();
              nTriggerFormChange();
            } else {
              if (onUpdateValue) {
                call(onUpdateValue, [], {
                  actionType: "uncheck",
                  value: checkboxValue
                });
              }
              if (_onUpdateValue) {
                call(_onUpdateValue, [], {
                  actionType: "uncheck",
                  value: checkboxValue
                });
              }
              if (onChange)
                call(onChange, []);
              uncontrolledValueRef.value = [];
              nTriggerFormInput();
              nTriggerFormChange();
            }
          }
        }
        provide(checkboxGroupInjectionKey, {
          checkedCountRef: checkedCount,
          maxRef: toRef(props, "max"),
          minRef: toRef(props, "min"),
          valueSetRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          toggleCheckbox
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef
        };
      },
      render() {
        return h("div", { class: `${this.mergedClsPrefix}-checkbox-group`, role: "group" }, this.$slots);
      }
    });
    const style$d = c$1([
      cB("checkbox", `
 line-height: var(--n-label-line-height);
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 --n-merged-color-table: var(--n-color-table);
 `, [c$1("&:hover", [cB("checkbox-box", [cE("border", {
        border: "var(--n-border-checked)"
      })])]), c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cM("inside-table", [cB("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [cB("checkbox-icon", [
        // if not set width to 100%, safari & old chrome won't display the icon
        c$1(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)
      ])])]), cM("indeterminate", [cB("checkbox-box", [cB("checkbox-icon", [c$1(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), c$1(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM("checked, indeterminate", [c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cB("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE("border", {
        border: "var(--n-border-checked)"
      })])]), cM("disabled", {
        cursor: "not-allowed"
      }, [cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [cE("border", {
        border: "var(--n-border-disabled-checked)"
      }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
        fill: "var(--n-check-mark-color-disabled-checked)"
      })])])]), cB("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [cE("border", {
        border: "var(--n-border-disabled)"
      }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
        fill: "var(--n-check-mark-color-disabled)"
      })])]), cE("label", {
        color: "var(--n-text-color-disabled)"
      })]), cB("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), cB("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [cE("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), cB("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [c$1(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), iconSwitchTransition({
        left: "1px",
        top: "1px"
      })])]), cE("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [c$1("&:empty", {
        display: "none"
      })])]),
      // modal table header checkbox
      insideModal(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)),
      // popover table header checkbox
      insidePopover(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))
    ]);
    const checkboxProps = Object.assign(Object.assign({}, useTheme.props), {
      size: String,
      checked: {
        type: [Boolean, String, Number],
        default: void 0
      },
      defaultChecked: {
        type: [Boolean, String, Number],
        default: false
      },
      value: [String, Number],
      disabled: {
        type: Boolean,
        default: void 0
      },
      indeterminate: Boolean,
      label: String,
      focusable: {
        type: Boolean,
        default: true
      },
      checkedValue: {
        type: [Boolean, String, Number],
        default: true
      },
      uncheckedValue: {
        type: [Boolean, String, Number],
        default: false
      },
      "onUpdate:checked": [Function, Array],
      onUpdateChecked: [Function, Array],
      // private
      privateInsideTable: Boolean,
      // deprecated
      onChange: [Function, Array]
    });
    const NCheckbox = defineComponent({
      name: "Checkbox",
      props: checkboxProps,
      setup(props) {
        const selfRef = ref(null);
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const formItem = useFormItem(props, {
          mergedSize(NFormItem2) {
            const { size: size2 } = props;
            if (size2 !== void 0)
              return size2;
            if (NCheckboxGroup2) {
              const { value: mergedSize } = NCheckboxGroup2.mergedSizeRef;
              if (mergedSize !== void 0) {
                return mergedSize;
              }
            }
            if (NFormItem2) {
              const { mergedSize } = NFormItem2;
              if (mergedSize !== void 0)
                return mergedSize.value;
            }
            return "medium";
          },
          mergedDisabled(NFormItem2) {
            const { disabled } = props;
            if (disabled !== void 0)
              return disabled;
            if (NCheckboxGroup2) {
              if (NCheckboxGroup2.disabledRef.value)
                return true;
              const { maxRef: { value: max }, checkedCountRef } = NCheckboxGroup2;
              if (max !== void 0 && checkedCountRef.value >= max && !renderedCheckedRef.value) {
                return true;
              }
              const { minRef: { value: min } } = NCheckboxGroup2;
              if (min !== void 0 && checkedCountRef.value <= min && renderedCheckedRef.value) {
                return true;
              }
            }
            if (NFormItem2) {
              return NFormItem2.disabled.value;
            }
            return false;
          }
        });
        const { mergedDisabledRef, mergedSizeRef } = formItem;
        const NCheckboxGroup2 = inject(checkboxGroupInjectionKey, null);
        const uncontrolledCheckedRef = ref(props.defaultChecked);
        const controlledCheckedRef = toRef(props, "checked");
        const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
        const renderedCheckedRef = useMemo(() => {
          if (NCheckboxGroup2) {
            const groupValueSet = NCheckboxGroup2.valueSetRef.value;
            if (groupValueSet && props.value !== void 0) {
              return groupValueSet.has(props.value);
            }
            return false;
          } else {
            return mergedCheckedRef.value === props.checkedValue;
          }
        });
        const themeRef = useTheme("Checkbox", "-checkbox", style$d, checkboxLight$1, props, mergedClsPrefixRef);
        function toggle(e) {
          if (NCheckboxGroup2 && props.value !== void 0) {
            NCheckboxGroup2.toggleCheckbox(!renderedCheckedRef.value, props.value);
          } else {
            const { onChange, "onUpdate:checked": _onUpdateCheck, onUpdateChecked } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            const nextChecked = renderedCheckedRef.value ? props.uncheckedValue : props.checkedValue;
            if (_onUpdateCheck) {
              call(_onUpdateCheck, nextChecked, e);
            }
            if (onUpdateChecked) {
              call(onUpdateChecked, nextChecked, e);
            }
            if (onChange)
              call(onChange, nextChecked, e);
            nTriggerFormInput();
            nTriggerFormChange();
            uncontrolledCheckedRef.value = nextChecked;
          }
        }
        function handleClick(e) {
          if (!mergedDisabledRef.value) {
            toggle(e);
          }
        }
        function handleKeyUp(e) {
          if (mergedDisabledRef.value)
            return;
          switch (e.key) {
            case " ":
            case "Enter":
              toggle(e);
          }
        }
        function handleKeyDown(e) {
          switch (e.key) {
            case " ":
              e.preventDefault();
          }
        }
        const exposedMethods = {
          focus: () => {
            var _a;
            (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          },
          blur: () => {
            var _a;
            (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.blur();
          }
        };
        const rtlEnabledRef = useRtl("Checkbox", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { value: mergedSize } = mergedSizeRef;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { borderRadius, color, colorChecked, colorDisabled, colorTableHeader, colorTableHeaderModal, colorTableHeaderPopover, checkMarkColor, checkMarkColorDisabled, border, borderFocus, borderDisabled, borderChecked, boxShadowFocus, textColor, textColorDisabled, checkMarkColorDisabledChecked, colorDisabledChecked, borderDisabledChecked, labelPadding, labelLineHeight, labelFontWeight, [createKey("fontSize", mergedSize)]: fontSize2, [createKey("size", mergedSize)]: size2 } } = themeRef.value;
          return {
            "--n-label-line-height": labelLineHeight,
            "--n-label-font-weight": labelFontWeight,
            "--n-size": size2,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-border-radius": borderRadius,
            "--n-border": border,
            "--n-border-checked": borderChecked,
            "--n-border-focus": borderFocus,
            "--n-border-disabled": borderDisabled,
            "--n-border-disabled-checked": borderDisabledChecked,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-color": color,
            "--n-color-checked": colorChecked,
            "--n-color-table": colorTableHeader,
            "--n-color-table-modal": colorTableHeaderModal,
            "--n-color-table-popover": colorTableHeaderPopover,
            "--n-color-disabled": colorDisabled,
            "--n-color-disabled-checked": colorDisabledChecked,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-check-mark-color": checkMarkColor,
            "--n-check-mark-color-disabled": checkMarkColorDisabled,
            "--n-check-mark-color-disabled-checked": checkMarkColorDisabledChecked,
            "--n-font-size": fontSize2,
            "--n-label-padding": labelPadding
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("checkbox", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
        return Object.assign(formItem, exposedMethods, {
          rtlEnabled: rtlEnabledRef,
          selfRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedDisabled: mergedDisabledRef,
          renderedChecked: renderedCheckedRef,
          mergedTheme: themeRef,
          labelId: createId(),
          handleClick,
          handleKeyUp,
          handleKeyDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a;
        const { $slots, renderedChecked, mergedDisabled, indeterminate, privateInsideTable, cssVars, labelId, label, mergedClsPrefix, focusable, handleKeyUp, handleKeyDown, handleClick } = this;
        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
        return h(
          "div",
          { ref: "selfRef", class: [
            `${mergedClsPrefix}-checkbox`,
            this.themeClass,
            this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`,
            renderedChecked && `${mergedClsPrefix}-checkbox--checked`,
            mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`,
            indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`,
            privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`
          ], tabindex: mergedDisabled || !focusable ? void 0 : 0, role: "checkbox", "aria-checked": indeterminate ? "mixed" : renderedChecked, "aria-labelledby": labelId, style: cssVars, onKeyup: handleKeyUp, onKeydown: handleKeyDown, onClick: handleClick, onMousedown: () => {
            on("selectstart", window, (e) => {
              e.preventDefault();
            }, {
              once: true
            });
          } },
          h(
            "div",
            { class: `${mergedClsPrefix}-checkbox-box-wrapper` },
            " ",
            h(
              "div",
              { class: `${mergedClsPrefix}-checkbox-box` },
              h(NIconSwitchTransition, null, {
                default: () => this.indeterminate ? h("div", { key: "indeterminate", class: `${mergedClsPrefix}-checkbox-icon` }, LineMark) : h("div", { key: "check", class: `${mergedClsPrefix}-checkbox-icon` }, CheckMark)
              }),
              h("div", { class: `${mergedClsPrefix}-checkbox-box__border` })
            )
          ),
          label !== null || $slots.default ? h("span", { class: `${mergedClsPrefix}-checkbox__label`, id: labelId }, $slots.default ? $slots.default() : label) : null
        );
      }
    });
    function self$b(vars) {
      const { boxShadow2 } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const popselectLight = createTheme({
      name: "Popselect",
      common: commonLight,
      peers: {
        Popover: popoverLight$1,
        InternalSelectMenu: internalSelectMenuLight$1
      },
      self: self$b
    });
    const popselectLight$1 = popselectLight;
    const popselectInjectionKey = createInjectionKey("n-popselect");
    const style$c = cB("popselect-menu", `
 box-shadow: var(--n-menu-box-shadow);
`);
    const panelProps = {
      multiple: Boolean,
      value: {
        type: [String, Number, Array],
        default: null
      },
      cancelable: Boolean,
      options: {
        type: Array,
        default: () => []
      },
      size: {
        type: String,
        default: "medium"
      },
      scrollable: Boolean,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onMouseenter: Function,
      onMouseleave: Function,
      renderLabel: Function,
      showCheckmark: {
        type: Boolean,
        default: void 0
      },
      nodeProps: Function,
      virtualScroll: Boolean,
      // deprecated
      onChange: [Function, Array]
    };
    const panelPropKeys = keysOf(panelProps);
    const NPopselectPanel = defineComponent({
      name: "PopselectPanel",
      props: panelProps,
      setup(props) {
        const NPopselect2 = inject(popselectInjectionKey);
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Popselect", "-pop-select", style$c, popselectLight$1, NPopselect2.props, mergedClsPrefixRef);
        const treeMateRef = computed(() => {
          return createTreeMate(props.options, createTmOptions("value", "children"));
        });
        function doUpdateValue(value, option) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue, onChange } = props;
          if (onUpdateValue)
            call(onUpdateValue, value, option);
          if (_onUpdateValue) {
            call(_onUpdateValue, value, option);
          }
          if (onChange)
            call(onChange, value, option);
        }
        function handleToggle(tmNode) {
          toggle(tmNode.key);
        }
        function handleMenuMousedown(e) {
          if (!happensIn(e, "action"))
            e.preventDefault();
        }
        function toggle(value) {
          const { value: { getNode } } = treeMateRef;
          if (props.multiple) {
            if (Array.isArray(props.value)) {
              const newValue = [];
              const newOptions = [];
              let shouldAddValue = true;
              props.value.forEach((v) => {
                if (v === value) {
                  shouldAddValue = false;
                  return;
                }
                const tmNode = getNode(v);
                if (tmNode) {
                  newValue.push(tmNode.key);
                  newOptions.push(tmNode.rawNode);
                }
              });
              if (shouldAddValue) {
                newValue.push(value);
                newOptions.push(getNode(value).rawNode);
              }
              doUpdateValue(newValue, newOptions);
            } else {
              const tmNode = getNode(value);
              if (tmNode) {
                doUpdateValue([value], [tmNode.rawNode]);
              }
            }
          } else {
            if (props.value === value && props.cancelable) {
              doUpdateValue(null, null);
            } else {
              const tmNode = getNode(value);
              if (tmNode) {
                doUpdateValue(value, tmNode.rawNode);
              }
              const { "onUpdate:show": _onUpdateShow, onUpdateShow } = NPopselect2.props;
              if (_onUpdateShow)
                call(_onUpdateShow, false);
              if (onUpdateShow)
                call(onUpdateShow, false);
              NPopselect2.setShow(false);
            }
          }
          void nextTick(() => {
            NPopselect2.syncPosition();
          });
        }
        watch(toRef(props, "options"), () => {
          void nextTick(() => {
            NPopselect2.syncPosition();
          });
        });
        const cssVarsRef = computed(() => {
          const { self: { menuBoxShadow } } = themeRef.value;
          return {
            "--n-menu-box-shadow": menuBoxShadow
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, NPopselect2.props) : void 0;
        return {
          mergedTheme: NPopselect2.mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          treeMate: treeMateRef,
          handleToggle,
          handleMenuMousedown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        var _a;
        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
        return h(NInternalSelectMenu, { clsPrefix: this.mergedClsPrefix, focusable: true, nodeProps: this.nodeProps, class: [`${this.mergedClsPrefix}-popselect-menu`, this.themeClass], style: this.cssVars, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, multiple: this.multiple, treeMate: this.treeMate, size: this.size, value: this.value, virtualScroll: this.virtualScroll, scrollable: this.scrollable, renderLabel: this.renderLabel, onToggle: this.handleToggle, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseenter, onMousedown: this.handleMenuMousedown, showCheckmark: this.showCheckmark }, {
          action: () => {
            var _a2, _b;
            return ((_b = (_a2 = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
          },
          empty: () => {
            var _a2, _b;
            return ((_b = (_a2 = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
          }
        });
      }
    });
    const popselectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), omit(popoverBaseProps, ["showArrow", "arrow"])), { placement: Object.assign(Object.assign({}, popoverBaseProps.placement), { default: "bottom" }), trigger: {
      type: String,
      default: "hover"
    } }), panelProps);
    const NPopselect = defineComponent({
      name: "Popselect",
      props: popselectProps,
      inheritAttrs: false,
      __popover__: true,
      setup(props) {
        const themeRef = useTheme("Popselect", "-popselect", void 0, popselectLight$1, props);
        const popoverInstRef = ref(null);
        function syncPosition() {
          var _a;
          (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
        }
        function setShow(value) {
          var _a;
          (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
        }
        provide(popselectInjectionKey, {
          props,
          mergedThemeRef: themeRef,
          syncPosition,
          setShow
        });
        const exposedMethods = {
          syncPosition,
          setShow
        };
        return Object.assign(Object.assign({}, exposedMethods), { popoverInstRef, mergedTheme: themeRef });
      },
      render() {
        const { mergedTheme } = this;
        const popoverProps2 = {
          theme: mergedTheme.peers.Popover,
          themeOverrides: mergedTheme.peerOverrides.Popover,
          builtinThemeOverrides: {
            padding: "0"
          },
          ref: "popoverInstRef",
          internalRenderBody: (className, ref2, style2, onMouseenter, onMouseleave) => {
            const { $attrs } = this;
            return h(NPopselectPanel, Object.assign({}, $attrs, { class: [$attrs.class, className], style: [$attrs.style, style2] }, keep(this.$props, panelPropKeys), { ref: createRefSetter(ref2), onMouseenter: mergeEventHandlers([
              onMouseenter,
              $attrs.onMouseenter
            ]), onMouseleave: mergeEventHandlers([
              onMouseleave,
              $attrs.onMouseleave
            ]) }), {
              action: () => {
                var _a, _b;
                return (_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a);
              },
              empty: () => {
                var _a, _b;
                return (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a);
              }
            });
          }
        };
        return h(NPopover, Object.assign({}, omit(this.$props, panelPropKeys), popoverProps2, { internalDeactivateImmediately: true }), {
          trigger: () => {
            var _a, _b;
            return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
          }
        });
      }
    });
    function self$a(vars) {
      const { boxShadow2 } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const selectLight = createTheme({
      name: "Select",
      common: commonLight,
      peers: {
        InternalSelection: internalSelectionLight$1,
        InternalSelectMenu: internalSelectMenuLight$1
      },
      self: self$a
    });
    const selectLight$1 = selectLight;
    const style$b = c$1([cB("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 `), cB("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
      originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
    })])]);
    const selectProps = Object.assign(Object.assign({}, useTheme.props), {
      to: useAdjustedTo.propTo,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clearable: Boolean,
      clearFilterAfterSelect: {
        type: Boolean,
        default: true
      },
      options: {
        type: Array,
        default: () => []
      },
      defaultValue: {
        type: [String, Number, Array],
        default: null
      },
      value: [String, Number, Array],
      placeholder: String,
      menuProps: Object,
      multiple: Boolean,
      size: String,
      filterable: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      remote: Boolean,
      loading: Boolean,
      filter: Function,
      placement: {
        type: String,
        default: "bottom-start"
      },
      widthMode: {
        type: String,
        default: "trigger"
      },
      tag: Boolean,
      onCreate: Function,
      fallbackOption: {
        type: [Function, Boolean],
        default: void 0
      },
      show: {
        type: Boolean,
        default: void 0
      },
      showArrow: {
        type: Boolean,
        default: true
      },
      maxTagCount: [Number, String],
      consistentMenuWidth: {
        type: Boolean,
        default: true
      },
      virtualScroll: {
        type: Boolean,
        default: true
      },
      labelField: {
        type: String,
        default: "label"
      },
      valueField: {
        type: String,
        default: "value"
      },
      childrenField: {
        type: String,
        default: "children"
      },
      renderLabel: Function,
      renderOption: Function,
      renderTag: Function,
      "onUpdate:value": [Function, Array],
      inputProps: Object,
      nodeProps: Function,
      ignoreComposition: { type: Boolean, default: true },
      showOnFocus: Boolean,
      // for jsx
      onUpdateValue: [Function, Array],
      onBlur: [Function, Array],
      onClear: [Function, Array],
      onFocus: [Function, Array],
      onScroll: [Function, Array],
      onSearch: [Function, Array],
      onUpdateShow: [Function, Array],
      "onUpdate:show": [Function, Array],
      displayDirective: {
        type: String,
        default: "show"
      },
      resetMenuOnOptionsChange: {
        type: Boolean,
        default: true
      },
      status: String,
      showCheckmark: {
        type: Boolean,
        default: true
      },
      /** deprecated */
      onChange: [Function, Array],
      items: Array
    });
    const NSelect = defineComponent({
      name: "Select",
      props: selectProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedBorderedRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Select", "-select", style$b, selectLight$1, props, mergedClsPrefixRef);
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const focusedRef = ref(false);
        const patternRef = ref("");
        const treeMateRef = computed(() => {
          const { valueField, childrenField } = props;
          const options = createTmOptions(valueField, childrenField);
          return createTreeMate(filteredOptionsRef.value, options);
        });
        const valOptMapRef = computed(() => createValOptMap(localOptionsRef.value, props.valueField, props.childrenField));
        const uncontrolledShowRef = ref(false);
        const mergedShowRef = useMergedState(toRef(props, "show"), uncontrolledShowRef);
        const triggerRef = ref(null);
        const followerRef = ref(null);
        const menuRef = ref(null);
        const { localeRef } = useLocale("Select");
        const localizedPlaceholderRef = computed(() => {
          var _a;
          return (_a = props.placeholder) !== null && _a !== void 0 ? _a : localeRef.value.placeholder;
        });
        const compitableOptionsRef = useCompitable(props, ["items", "options"]);
        const emptyArray = [];
        const createdOptionsRef = ref([]);
        const beingCreatedOptionsRef = ref([]);
        const memoValOptMapRef = ref(/* @__PURE__ */ new Map());
        const wrappedFallbackOptionRef = computed(() => {
          const { fallbackOption } = props;
          if (fallbackOption === void 0) {
            const { labelField, valueField } = props;
            return (value) => ({
              [labelField]: String(value),
              [valueField]: value
            });
          }
          if (fallbackOption === false)
            return false;
          return (value) => {
            return Object.assign(fallbackOption(value), {
              value
            });
          };
        });
        const localOptionsRef = computed(() => {
          return beingCreatedOptionsRef.value.concat(createdOptionsRef.value).concat(compitableOptionsRef.value);
        });
        const resolvedFilterRef = computed(() => {
          const { filter } = props;
          if (filter)
            return filter;
          const { labelField, valueField } = props;
          return (pattern2, option) => {
            if (!option)
              return false;
            const label = option[labelField];
            if (typeof label === "string") {
              return patternMatched(pattern2, label);
            }
            const value = option[valueField];
            if (typeof value === "string") {
              return patternMatched(pattern2, value);
            }
            if (typeof value === "number") {
              return patternMatched(pattern2, String(value));
            }
            return false;
          };
        });
        const filteredOptionsRef = computed(() => {
          if (props.remote) {
            return compitableOptionsRef.value;
          } else {
            const { value: localOptions } = localOptionsRef;
            const { value: pattern2 } = patternRef;
            if (!pattern2.length || !props.filterable) {
              return localOptions;
            } else {
              return filterOptions(localOptions, resolvedFilterRef.value, pattern2, props.childrenField);
            }
          }
        });
        function getMergedOptions(values) {
          const remote = props.remote;
          const { value: memoValOptMap } = memoValOptMapRef;
          const { value: valOptMap } = valOptMapRef;
          const { value: wrappedFallbackOption } = wrappedFallbackOptionRef;
          const options = [];
          values.forEach((value) => {
            if (valOptMap.has(value)) {
              options.push(valOptMap.get(value));
            } else if (remote && memoValOptMap.has(value)) {
              options.push(memoValOptMap.get(value));
            } else if (wrappedFallbackOption) {
              const option = wrappedFallbackOption(value);
              if (option) {
                options.push(option);
              }
            }
          });
          return options;
        }
        const selectedOptionsRef = computed(() => {
          if (props.multiple) {
            const { value: values } = mergedValueRef;
            if (!Array.isArray(values))
              return [];
            return getMergedOptions(values);
          }
          return null;
        });
        const selectedOptionRef = computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (!props.multiple && !Array.isArray(mergedValue)) {
            if (mergedValue === null)
              return null;
            return getMergedOptions([mergedValue])[0] || null;
          }
          return null;
        });
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        function doUpdateValue(value, option) {
          const { onChange, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
          const { nTriggerFormChange, nTriggerFormInput } = formItem;
          if (onChange)
            call(onChange, value, option);
          if (onUpdateValue)
            call(onUpdateValue, value, option);
          if (_onUpdateValue) {
            call(_onUpdateValue, value, option);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doClear() {
          const { onClear } = props;
          if (onClear)
            call(onClear);
        }
        function doFocus(e) {
          const { onFocus, showOnFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
          if (showOnFocus) {
            openMenu();
          }
        }
        function doSearch(value) {
          const { onSearch } = props;
          if (onSearch)
            call(onSearch, value);
        }
        function doScroll(e) {
          const { onScroll } = props;
          if (onScroll)
            call(onScroll, e);
        }
        function updateMemorizedOptions() {
          var _a;
          const { remote, multiple } = props;
          if (remote) {
            const { value: memoValOptMap } = memoValOptMapRef;
            if (multiple) {
              const { valueField } = props;
              (_a = selectedOptionsRef.value) === null || _a === void 0 ? void 0 : _a.forEach((option) => {
                memoValOptMap.set(option[valueField], option);
              });
            } else {
              const option = selectedOptionRef.value;
              if (option) {
                memoValOptMap.set(option[props.valueField], option);
              }
            }
          }
        }
        function doUpdateShow(value) {
          const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow)
            call(onUpdateShow, value);
          if (_onUpdateShow)
            call(_onUpdateShow, value);
          uncontrolledShowRef.value = value;
        }
        function openMenu() {
          if (!mergedDisabledRef.value) {
            doUpdateShow(true);
            uncontrolledShowRef.value = true;
            if (props.filterable) {
              focusSelectionInput();
            }
          }
        }
        function closeMenu() {
          doUpdateShow(false);
        }
        function handleMenuAfterLeave() {
          patternRef.value = "";
          beingCreatedOptionsRef.value = emptyArray;
        }
        const activeWithoutMenuOpenRef = ref(false);
        function onTriggerInputFocus() {
          if (props.filterable) {
            activeWithoutMenuOpenRef.value = true;
          }
        }
        function onTriggerInputBlur() {
          if (props.filterable) {
            activeWithoutMenuOpenRef.value = false;
            if (!mergedShowRef.value) {
              handleMenuAfterLeave();
            }
          }
        }
        function handleTriggerClick() {
          if (mergedDisabledRef.value)
            return;
          if (!mergedShowRef.value) {
            openMenu();
          } else {
            if (!props.filterable) {
              closeMenu();
            } else {
              focusSelectionInput();
            }
          }
        }
        function handleTriggerBlur(e) {
          var _a, _b;
          if ((_b = (_a = menuRef.value) === null || _a === void 0 ? void 0 : _a.selfRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) {
            return;
          }
          focusedRef.value = false;
          doBlur(e);
          closeMenu();
        }
        function handleTriggerFocus(e) {
          doFocus(e);
          focusedRef.value = true;
        }
        function handleMenuFocus(e) {
          focusedRef.value = true;
        }
        function handleMenuBlur(e) {
          var _a;
          if ((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))
            return;
          focusedRef.value = false;
          doBlur(e);
          closeMenu();
        }
        function handleMenuTabOut() {
          var _a;
          (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          closeMenu();
        }
        function handleMenuClickOutside(e) {
          var _a;
          if (mergedShowRef.value) {
            if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
              closeMenu();
            }
          }
        }
        function createClearedMultipleSelectValue(value) {
          if (!Array.isArray(value))
            return [];
          if (wrappedFallbackOptionRef.value) {
            return Array.from(value);
          } else {
            const { remote } = props;
            const { value: valOptMap } = valOptMapRef;
            if (remote) {
              const { value: memoValOptMap } = memoValOptMapRef;
              return value.filter((v) => valOptMap.has(v) || memoValOptMap.has(v));
            } else {
              return value.filter((v) => valOptMap.has(v));
            }
          }
        }
        function handleToggleByTmNode(tmNode) {
          handleToggleByOption(tmNode.rawNode);
        }
        function handleToggleByOption(option) {
          if (mergedDisabledRef.value)
            return;
          const { tag, remote, clearFilterAfterSelect, valueField } = props;
          if (tag && !remote) {
            const { value: beingCreatedOptions } = beingCreatedOptionsRef;
            const beingCreatedOption = beingCreatedOptions[0] || null;
            if (beingCreatedOption) {
              const createdOptions = createdOptionsRef.value;
              if (!createdOptions.length) {
                createdOptionsRef.value = [beingCreatedOption];
              } else {
                createdOptions.push(beingCreatedOption);
              }
              beingCreatedOptionsRef.value = emptyArray;
            }
          }
          if (remote) {
            memoValOptMapRef.value.set(option[valueField], option);
          }
          if (props.multiple) {
            const changedValue = createClearedMultipleSelectValue(mergedValueRef.value);
            const index = changedValue.findIndex((value) => value === option[valueField]);
            if (~index) {
              changedValue.splice(index, 1);
              if (tag && !remote) {
                const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
                if (~createdOptionIndex) {
                  createdOptionsRef.value.splice(createdOptionIndex, 1);
                  if (clearFilterAfterSelect)
                    patternRef.value = "";
                }
              }
            } else {
              changedValue.push(option[valueField]);
              if (clearFilterAfterSelect)
                patternRef.value = "";
            }
            doUpdateValue(changedValue, getMergedOptions(changedValue));
          } else {
            if (tag && !remote) {
              const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
              if (~createdOptionIndex) {
                createdOptionsRef.value = [
                  createdOptionsRef.value[createdOptionIndex]
                ];
              } else {
                createdOptionsRef.value = emptyArray;
              }
            }
            focusSelection();
            closeMenu();
            doUpdateValue(option[valueField], option);
          }
        }
        function getCreatedOptionIndex(optionValue) {
          const createdOptions = createdOptionsRef.value;
          return createdOptions.findIndex((createdOption) => createdOption[props.valueField] === optionValue);
        }
        function handlePatternInput(e) {
          if (!mergedShowRef.value) {
            openMenu();
          }
          const { value } = e.target;
          patternRef.value = value;
          const { tag, remote } = props;
          doSearch(value);
          if (tag && !remote) {
            if (!value) {
              beingCreatedOptionsRef.value = emptyArray;
              return;
            }
            const { onCreate } = props;
            const optionBeingCreated = onCreate ? onCreate(value) : { [props.labelField]: value, [props.valueField]: value };
            const { valueField } = props;
            if (compitableOptionsRef.value.some((option) => option[valueField] === optionBeingCreated[valueField]) || createdOptionsRef.value.some((option) => option[valueField] === optionBeingCreated[valueField])) {
              beingCreatedOptionsRef.value = emptyArray;
            } else {
              beingCreatedOptionsRef.value = [optionBeingCreated];
            }
          }
        }
        function handleClear(e) {
          e.stopPropagation();
          const { multiple } = props;
          if (!multiple && props.filterable) {
            closeMenu();
          }
          doClear();
          if (multiple) {
            doUpdateValue([], []);
          } else {
            doUpdateValue(null, null);
          }
        }
        function handleMenuMousedown(e) {
          if (!happensIn(e, "action") && !happensIn(e, "empty"))
            e.preventDefault();
        }
        function handleMenuScroll(e) {
          doScroll(e);
        }
        function handleKeydown(e) {
          var _a, _b, _c, _d, _e;
          switch (e.key) {
            case " ":
              if (props.filterable)
                break;
              else {
                e.preventDefault();
              }
            case "Enter":
              if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.isComposing)) {
                if (mergedShowRef.value) {
                  const pendingTmNode = (_b = menuRef.value) === null || _b === void 0 ? void 0 : _b.getPendingTmNode();
                  if (pendingTmNode) {
                    handleToggleByTmNode(pendingTmNode);
                  } else if (!props.filterable) {
                    closeMenu();
                    focusSelection();
                  }
                } else {
                  openMenu();
                  if (props.tag && activeWithoutMenuOpenRef.value) {
                    const beingCreatedOption = beingCreatedOptionsRef.value[0];
                    if (beingCreatedOption) {
                      const optionValue = beingCreatedOption[props.valueField];
                      const { value: mergedValue } = mergedValueRef;
                      if (props.multiple) {
                        if (Array.isArray(mergedValue) && mergedValue.some((value) => value === optionValue))
                          ;
                        else {
                          handleToggleByOption(beingCreatedOption);
                        }
                      } else {
                        handleToggleByOption(beingCreatedOption);
                      }
                    }
                  }
                }
              }
              e.preventDefault();
              break;
            case "ArrowUp":
              e.preventDefault();
              if (props.loading)
                return;
              if (mergedShowRef.value) {
                (_c = menuRef.value) === null || _c === void 0 ? void 0 : _c.prev();
              }
              break;
            case "ArrowDown":
              e.preventDefault();
              if (props.loading)
                return;
              if (mergedShowRef.value) {
                (_d = menuRef.value) === null || _d === void 0 ? void 0 : _d.next();
              } else {
                openMenu();
              }
              break;
            case "Escape":
              if (mergedShowRef.value) {
                markEventEffectPerformed(e);
                closeMenu();
              }
              (_e = triggerRef.value) === null || _e === void 0 ? void 0 : _e.focus();
              break;
          }
        }
        function focusSelection() {
          var _a;
          (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        }
        function focusSelectionInput() {
          var _a;
          (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
        }
        function handleTriggerOrMenuResize() {
          var _a;
          if (!mergedShowRef.value)
            return;
          (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
        }
        updateMemorizedOptions();
        watch(toRef(props, "options"), updateMemorizedOptions);
        const exposedMethods = {
          focus: () => {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          },
          blur: () => {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blur();
          }
        };
        const cssVarsRef = computed(() => {
          const { self: { menuBoxShadow } } = themeRef.value;
          return {
            "--n-menu-box-shadow": menuBoxShadow
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, props) : void 0;
        return Object.assign(Object.assign({}, exposedMethods), {
          mergedStatus: mergedStatusRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          namespace: namespaceRef,
          treeMate: treeMateRef,
          isMounted: isMounted(),
          triggerRef,
          menuRef,
          pattern: patternRef,
          uncontrolledShow: uncontrolledShowRef,
          mergedShow: mergedShowRef,
          adjustedTo: useAdjustedTo(props),
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          followerRef,
          localizedPlaceholder: localizedPlaceholderRef,
          selectedOption: selectedOptionRef,
          selectedOptions: selectedOptionsRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          focused: focusedRef,
          activeWithoutMenuOpen: activeWithoutMenuOpenRef,
          inlineThemeDisabled,
          onTriggerInputFocus,
          onTriggerInputBlur,
          handleTriggerOrMenuResize,
          handleMenuFocus,
          handleMenuBlur,
          handleMenuTabOut,
          handleTriggerClick,
          handleToggle: handleToggleByTmNode,
          handleDeleteOption: handleToggleByOption,
          handlePatternInput,
          handleClear,
          handleTriggerBlur,
          handleTriggerFocus,
          handleKeydown,
          handleMenuAfterLeave,
          handleMenuClickOutside,
          handleMenuScroll,
          handleMenuKeydown: handleKeydown,
          handleMenuMousedown,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        return h(
          "div",
          { class: `${this.mergedClsPrefix}-select` },
          h(VBinder, null, {
            default: () => [
              h(VTarget, null, {
                default: () => h(NInternalSelection, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, {
                  arrow: () => {
                    var _a, _b;
                    return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)];
                  }
                })
              }),
              h(VFollower, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, {
                default: () => h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, {
                  default: () => {
                    var _a, _b, _c;
                    if (!(this.mergedShow || this.displayDirective === "show")) {
                      return null;
                    }
                    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                    return withDirectives(h(NInternalSelectMenu, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [
                      `${this.mergedClsPrefix}-select-menu`,
                      this.themeClass,
                      (_b = this.menuProps) === null || _b === void 0 ? void 0 : _b.class
                    ], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: "medium", renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(_c = this.menuProps) === null || _c === void 0 ? void 0 : _c.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), {
                      empty: () => {
                        var _a2, _b2;
                        return [(_b2 = (_a2 = this.$slots).empty) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                      },
                      action: () => {
                        var _a2, _b2;
                        return [(_b2 = (_a2 = this.$slots).action) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                      }
                    }), this.displayDirective === "show" ? [
                      [vShow, this.mergedShow],
                      [
                        clickoutside$1,
                        this.handleMenuClickOutside,
                        void 0,
                        { capture: true }
                      ]
                    ] : [
                      [
                        clickoutside$1,
                        this.handleMenuClickOutside,
                        void 0,
                        { capture: true }
                      ]
                    ]);
                  }
                })
              })
            ]
          })
        );
      }
    });
    const commonVariables$5 = {
      itemPaddingSmall: "0 4px",
      itemMarginSmall: "0 0 0 8px",
      itemMarginSmallRtl: "0 8px 0 0",
      itemPaddingMedium: "0 4px",
      itemMarginMedium: "0 0 0 8px",
      itemMarginMediumRtl: "0 8px 0 0",
      itemPaddingLarge: "0 4px",
      itemMarginLarge: "0 0 0 8px",
      itemMarginLargeRtl: "0 8px 0 0",
      buttonIconSizeSmall: "14px",
      buttonIconSizeMedium: "16px",
      buttonIconSizeLarge: "18px",
      inputWidthSmall: "60px",
      selectWidthSmall: "unset",
      inputMarginSmall: "0 0 0 8px",
      inputMarginSmallRtl: "0 8px 0 0",
      selectMarginSmall: "0 0 0 8px",
      prefixMarginSmall: "0 8px 0 0",
      suffixMarginSmall: "0 0 0 8px",
      inputWidthMedium: "60px",
      selectWidthMedium: "unset",
      inputMarginMedium: "0 0 0 8px",
      inputMarginMediumRtl: "0 8px 0 0",
      selectMarginMedium: "0 0 0 8px",
      prefixMarginMedium: "0 8px 0 0",
      suffixMarginMedium: "0 0 0 8px",
      inputWidthLarge: "60px",
      selectWidthLarge: "unset",
      inputMarginLarge: "0 0 0 8px",
      inputMarginLargeRtl: "0 8px 0 0",
      selectMarginLarge: "0 0 0 8px",
      prefixMarginLarge: "0 8px 0 0",
      suffixMarginLarge: "0 0 0 8px"
    };
    const self$9 = (vars) => {
      const {
        textColor2,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        inputColorDisabled,
        textColorDisabled,
        borderColor,
        borderRadius,
        // item font size
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        // item size
        heightTiny,
        heightSmall,
        heightMedium
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$5), { buttonColor: "#0000", buttonColorHover: "#0000", buttonColorPressed: "#0000", buttonBorder: `1px solid ${borderColor}`, buttonBorderHover: `1px solid ${borderColor}`, buttonBorderPressed: `1px solid ${borderColor}`, buttonIconColor: textColor2, buttonIconColorHover: textColor2, buttonIconColorPressed: textColor2, itemTextColor: textColor2, itemTextColorHover: primaryColorHover, itemTextColorPressed: primaryColorPressed, itemTextColorActive: primaryColor, itemTextColorDisabled: textColorDisabled, itemColor: "#0000", itemColorHover: "#0000", itemColorPressed: "#0000", itemColorActive: "#0000", itemColorActiveHover: "#0000", itemColorDisabled: inputColorDisabled, itemBorder: "1px solid #0000", itemBorderHover: "1px solid #0000", itemBorderPressed: "1px solid #0000", itemBorderActive: `1px solid ${primaryColor}`, itemBorderDisabled: `1px solid ${borderColor}`, itemBorderRadius: borderRadius, itemSizeSmall: heightTiny, itemSizeMedium: heightSmall, itemSizeLarge: heightMedium, itemFontSizeSmall: fontSizeTiny, itemFontSizeMedium: fontSizeSmall, itemFontSizeLarge: fontSizeMedium, jumperFontSizeSmall: fontSizeTiny, jumperFontSizeMedium: fontSizeSmall, jumperFontSizeLarge: fontSizeMedium, jumperTextColor: textColor2, jumperTextColorDisabled: textColorDisabled });
    };
    const paginationLight = createTheme({
      name: "Pagination",
      common: commonLight,
      peers: {
        Select: selectLight$1,
        Input: inputLight$1,
        Popselect: popselectLight$1
      },
      self: self$9
    });
    const paginationLight$1 = paginationLight;
    function createPageItemsInfo(currentPage, pageCount, pageSlot) {
      let hasFastBackward = false;
      let hasFastForward = false;
      let fastBackwardTo = 1;
      let fastForwardTo = pageCount;
      if (pageCount === 1) {
        return {
          hasFastBackward: false,
          hasFastForward: false,
          fastForwardTo,
          fastBackwardTo,
          items: [
            {
              type: "page",
              label: 1,
              active: currentPage === 1,
              mayBeFastBackward: false,
              mayBeFastForward: false
            }
          ]
        };
      }
      if (pageCount === 2) {
        return {
          hasFastBackward: false,
          hasFastForward: false,
          fastForwardTo,
          fastBackwardTo,
          items: [
            {
              type: "page",
              label: 1,
              active: currentPage === 1,
              mayBeFastBackward: false,
              mayBeFastForward: false
            },
            {
              type: "page",
              label: 2,
              active: currentPage === 2,
              mayBeFastBackward: true,
              mayBeFastForward: false
            }
          ]
        };
      }
      const firstPage = 1;
      const lastPage = pageCount;
      let middleStart = currentPage;
      let middleEnd = currentPage;
      const middleDelta = (pageSlot - 5) / 2;
      middleEnd += Math.ceil(middleDelta);
      middleEnd = Math.min(Math.max(middleEnd, firstPage + pageSlot - 3), lastPage - 2);
      middleStart -= Math.floor(middleDelta);
      middleStart = Math.max(Math.min(middleStart, lastPage - pageSlot + 3), firstPage + 2);
      let leftSplit = false;
      let rightSplit = false;
      if (middleStart > firstPage + 2)
        leftSplit = true;
      if (middleEnd < lastPage - 2)
        rightSplit = true;
      const items = [];
      items.push({
        type: "page",
        label: 1,
        active: currentPage === 1,
        mayBeFastBackward: false,
        mayBeFastForward: false
      });
      if (leftSplit) {
        hasFastBackward = true;
        fastBackwardTo = middleStart - 1;
        items.push({
          type: "fast-backward",
          active: false,
          label: void 0,
          options: createRange(firstPage + 1, middleStart - 1)
        });
      } else if (lastPage >= firstPage + 1) {
        items.push({
          type: "page",
          label: firstPage + 1,
          mayBeFastBackward: true,
          mayBeFastForward: false,
          active: currentPage === firstPage + 1
        });
      }
      for (let i = middleStart; i <= middleEnd; ++i) {
        items.push({
          type: "page",
          label: i,
          mayBeFastBackward: false,
          mayBeFastForward: false,
          active: currentPage === i
        });
      }
      if (rightSplit) {
        hasFastForward = true;
        fastForwardTo = middleEnd + 1;
        items.push({
          type: "fast-forward",
          active: false,
          label: void 0,
          options: createRange(middleEnd + 1, lastPage - 1)
        });
      } else if (middleEnd === lastPage - 2 && items[items.length - 1].label !== lastPage - 1) {
        items.push({
          type: "page",
          mayBeFastForward: true,
          mayBeFastBackward: false,
          label: lastPage - 1,
          active: currentPage === lastPage - 1
        });
      }
      if (items[items.length - 1].label !== lastPage) {
        items.push({
          type: "page",
          mayBeFastForward: false,
          mayBeFastBackward: false,
          label: lastPage,
          active: currentPage === lastPage
        });
      }
      return {
        hasFastBackward,
        hasFastForward,
        fastBackwardTo,
        fastForwardTo,
        items
      };
    }
    function createRange(from, to) {
      const range2 = [];
      for (let i = from; i <= to; ++i) {
        range2.push({
          label: `${i}`,
          value: i
        });
      }
      return range2;
    }
    const hoverStyleProps = `
 background: var(--n-item-color-hover);
 color: var(--n-item-text-color-hover);
 border: var(--n-item-border-hover);
`;
    const hoverStyleChildren = [cM("button", `
 background: var(--n-button-color-hover);
 border: var(--n-button-border-hover);
 color: var(--n-button-icon-color-hover);
 `)];
    const style$a = cB("pagination", `
 display: flex;
 vertical-align: middle;
 font-size: var(--n-item-font-size);
 flex-wrap: nowrap;
`, [cB("pagination-prefix", `
 display: flex;
 align-items: center;
 margin: var(--n-prefix-margin);
 `), cB("pagination-suffix", `
 display: flex;
 align-items: center;
 margin: var(--n-suffix-margin);
 `), c$1("> *:not(:first-child)", `
 margin: var(--n-item-margin);
 `), cB("select", `
 width: var(--n-select-width);
 `), c$1("&.transition-disabled", [cB("pagination-item", "transition: none!important;")]), cB("pagination-quick-jumper", `
 white-space: nowrap;
 display: flex;
 color: var(--n-jumper-text-color);
 transition: color .3s var(--n-bezier);
 align-items: center;
 font-size: var(--n-jumper-font-size);
 `, [cB("input", `
 margin: var(--n-input-margin);
 width: var(--n-input-width);
 `)]), cB("pagination-item", `
 position: relative;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 display: flex;
 align-items: center;
 justify-content: center;
 box-sizing: border-box;
 min-width: var(--n-item-size);
 height: var(--n-item-size);
 padding: var(--n-item-padding);
 background-color: var(--n-item-color);
 color: var(--n-item-text-color);
 border-radius: var(--n-item-border-radius);
 border: var(--n-item-border);
 fill: var(--n-button-icon-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 fill .3s var(--n-bezier);
 `, [cM("button", `
 background: var(--n-button-color);
 color: var(--n-button-icon-color);
 border: var(--n-button-border);
 padding: 0;
 `, [cB("base-icon", `
 font-size: var(--n-button-icon-size);
 `)]), cNotM("disabled", [cM("hover", hoverStyleProps, hoverStyleChildren), c$1("&:hover", hoverStyleProps, hoverStyleChildren), c$1("&:active", `
 background: var(--n-item-color-pressed);
 color: var(--n-item-text-color-pressed);
 border: var(--n-item-border-pressed);
 `, [cM("button", `
 background: var(--n-button-color-pressed);
 border: var(--n-button-border-pressed);
 color: var(--n-button-icon-color-pressed);
 `)]), cM("active", `
 background: var(--n-item-color-active);
 color: var(--n-item-text-color-active);
 border: var(--n-item-border-active);
 `, [c$1("&:hover", `
 background: var(--n-item-color-active-hover);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `, [cM("active, button", `
 background-color: var(--n-item-color-disabled);
 border: var(--n-item-border-disabled);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cB("pagination-quick-jumper", `
 color: var(--n-jumper-text-color-disabled);
 `)]), cM("simple", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 `, [cB("pagination-quick-jumper", [cB("input", `
 margin: 0;
 `)])])]);
    const paginationProps = Object.assign(Object.assign({}, useTheme.props), {
      simple: Boolean,
      page: Number,
      defaultPage: {
        type: Number,
        default: 1
      },
      itemCount: Number,
      pageCount: Number,
      defaultPageCount: {
        type: Number,
        default: 1
      },
      showSizePicker: Boolean,
      pageSize: Number,
      defaultPageSize: Number,
      pageSizes: {
        type: Array,
        default() {
          return [10];
        }
      },
      showQuickJumper: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      disabled: Boolean,
      pageSlot: {
        type: Number,
        default: 9
      },
      selectProps: Object,
      prev: Function,
      next: Function,
      goto: Function,
      prefix: Function,
      suffix: Function,
      label: Function,
      displayOrder: {
        type: Array,
        default: ["pages", "size-picker", "quick-jumper"]
      },
      to: useAdjustedTo.propTo,
      "onUpdate:page": [Function, Array],
      onUpdatePage: [Function, Array],
      "onUpdate:pageSize": [Function, Array],
      onUpdatePageSize: [Function, Array],
      /** @deprecated */
      onPageSizeChange: [Function, Array],
      /** @deprecated */
      onChange: [Function, Array]
    });
    const NPagination = defineComponent({
      name: "Pagination",
      props: paginationProps,
      setup(props) {
        const { mergedComponentPropsRef, mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Pagination", "-pagination", style$a, paginationLight$1, props, mergedClsPrefixRef);
        const { localeRef } = useLocale("Pagination");
        const selfRef = ref(null);
        const uncontrolledPageRef = ref(props.defaultPage);
        const getDefaultPageSize = () => {
          const { defaultPageSize } = props;
          if (defaultPageSize !== void 0)
            return defaultPageSize;
          const pageSizeOption = props.pageSizes[0];
          if (typeof pageSizeOption === "number")
            return pageSizeOption;
          return pageSizeOption.value || 10;
        };
        const uncontrolledPageSizeRef = ref(getDefaultPageSize());
        const mergedPageRef = useMergedState(toRef(props, "page"), uncontrolledPageRef);
        const mergedPageSizeRef = useMergedState(toRef(props, "pageSize"), uncontrolledPageSizeRef);
        const mergedPageCountRef = computed(() => {
          const { itemCount } = props;
          if (itemCount !== void 0) {
            return Math.max(1, Math.ceil(itemCount / mergedPageSizeRef.value));
          }
          const { pageCount } = props;
          if (pageCount !== void 0)
            return Math.max(pageCount, 1);
          return 1;
        });
        const jumperValueRef = ref("");
        watchEffect(() => {
          void props.simple;
          jumperValueRef.value = String(mergedPageRef.value);
        });
        const fastForwardActiveRef = ref(false);
        const fastBackwardActiveRef = ref(false);
        const showFastForwardMenuRef = ref(false);
        const showFastBackwardMenuRef = ref(false);
        const handleFastForwardMouseenter = () => {
          if (props.disabled)
            return;
          fastForwardActiveRef.value = true;
          disableTransitionOneTick();
        };
        const handleFastForwardMouseleave = () => {
          if (props.disabled)
            return;
          fastForwardActiveRef.value = false;
          disableTransitionOneTick();
        };
        const handleFastBackwardMouseenter = () => {
          fastBackwardActiveRef.value = true;
          disableTransitionOneTick();
        };
        const handleFastBackwardMouseleave = () => {
          fastBackwardActiveRef.value = false;
          disableTransitionOneTick();
        };
        const handleMenuSelect = (value) => {
          doUpdatePage(value);
        };
        const pageItemsInfo = computed(() => createPageItemsInfo(mergedPageRef.value, mergedPageCountRef.value, props.pageSlot));
        watchEffect(() => {
          if (!pageItemsInfo.value.hasFastBackward) {
            fastBackwardActiveRef.value = false;
            showFastBackwardMenuRef.value = false;
          } else if (!pageItemsInfo.value.hasFastForward) {
            fastForwardActiveRef.value = false;
            showFastForwardMenuRef.value = false;
          }
        });
        const pageSizeOptionsRef = computed(() => {
          const suffix2 = localeRef.value.selectionSuffix;
          return props.pageSizes.map((size2) => {
            if (typeof size2 === "number") {
              return {
                label: `${size2} / ${suffix2}`,
                value: size2
              };
            } else {
              return size2;
            }
          });
        });
        const inputSizeRef = computed(() => {
          var _a, _b;
          return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.inputSize) || smallerSize(props.size);
        });
        const selectSizeRef = computed(() => {
          var _a, _b;
          return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.selectSize) || smallerSize(props.size);
        });
        const startIndexRef = computed(() => {
          return (mergedPageRef.value - 1) * mergedPageSizeRef.value;
        });
        const endIndexRef = computed(() => {
          const endIndex = mergedPageRef.value * mergedPageSizeRef.value - 1;
          const { itemCount } = props;
          if (itemCount !== void 0) {
            return endIndex > itemCount - 1 ? itemCount - 1 : endIndex;
          }
          return endIndex;
        });
        const mergedItemCountRef = computed(() => {
          const { itemCount } = props;
          if (itemCount !== void 0)
            return itemCount;
          return (props.pageCount || 1) * mergedPageSizeRef.value;
        });
        const rtlEnabledRef = useRtl("Pagination", mergedRtlRef, mergedClsPrefixRef);
        const disableTransitionOneTick = () => {
          void nextTick(() => {
            var _a;
            const { value: selfEl } = selfRef;
            if (!selfEl)
              return;
            selfEl.classList.add("transition-disabled");
            void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
            selfEl.classList.remove("transition-disabled");
          });
        };
        function doUpdatePage(page) {
          if (page === mergedPageRef.value)
            return;
          const { "onUpdate:page": _onUpdatePage, onUpdatePage, onChange, simple } = props;
          if (_onUpdatePage)
            call(_onUpdatePage, page);
          if (onUpdatePage)
            call(onUpdatePage, page);
          if (onChange)
            call(onChange, page);
          uncontrolledPageRef.value = page;
          if (simple) {
            jumperValueRef.value = String(page);
          }
        }
        function doUpdatePageSize(pageSize) {
          if (pageSize === mergedPageSizeRef.value)
            return;
          const { "onUpdate:pageSize": _onUpdatePageSize, onUpdatePageSize, onPageSizeChange } = props;
          if (_onUpdatePageSize)
            call(_onUpdatePageSize, pageSize);
          if (onUpdatePageSize)
            call(onUpdatePageSize, pageSize);
          if (onPageSizeChange)
            call(onPageSizeChange, pageSize);
          uncontrolledPageSizeRef.value = pageSize;
          if (mergedPageCountRef.value < mergedPageRef.value) {
            doUpdatePage(mergedPageCountRef.value);
          }
        }
        function forward() {
          if (props.disabled)
            return;
          const page = Math.min(mergedPageRef.value + 1, mergedPageCountRef.value);
          doUpdatePage(page);
        }
        function backward() {
          if (props.disabled)
            return;
          const page = Math.max(mergedPageRef.value - 1, 1);
          doUpdatePage(page);
        }
        function fastForward() {
          if (props.disabled)
            return;
          const page = Math.min(pageItemsInfo.value.fastForwardTo, mergedPageCountRef.value);
          doUpdatePage(page);
        }
        function fastBackward() {
          if (props.disabled)
            return;
          const page = Math.max(pageItemsInfo.value.fastBackwardTo, 1);
          doUpdatePage(page);
        }
        function handleSizePickerChange(value) {
          doUpdatePageSize(value);
        }
        function doQuickJump() {
          const page = parseInt(jumperValueRef.value);
          if (Number.isNaN(page))
            return;
          doUpdatePage(Math.max(1, Math.min(page, mergedPageCountRef.value)));
          if (!props.simple) {
            jumperValueRef.value = "";
          }
        }
        function handleQuickJumperChange() {
          doQuickJump();
        }
        function handlePageItemClick(pageItem) {
          if (props.disabled)
            return;
          switch (pageItem.type) {
            case "page":
              doUpdatePage(pageItem.label);
              break;
            case "fast-backward":
              fastBackward();
              break;
            case "fast-forward":
              fastForward();
              break;
          }
        }
        function handleJumperInput(value) {
          jumperValueRef.value = value.replace(/\D+/g, "");
        }
        watchEffect(() => {
          void mergedPageRef.value;
          void mergedPageSizeRef.value;
          disableTransitionOneTick();
        });
        const cssVarsRef = computed(() => {
          const { size: size2 } = props;
          const { self: { buttonBorder, buttonBorderHover, buttonBorderPressed, buttonIconColor, buttonIconColorHover, buttonIconColorPressed, itemTextColor, itemTextColorHover, itemTextColorPressed, itemTextColorActive, itemTextColorDisabled, itemColor, itemColorHover, itemColorPressed, itemColorActive, itemColorActiveHover, itemColorDisabled, itemBorder, itemBorderHover, itemBorderPressed, itemBorderActive, itemBorderDisabled, itemBorderRadius, jumperTextColor, jumperTextColorDisabled, buttonColor, buttonColorHover, buttonColorPressed, [createKey("itemPadding", size2)]: itemPadding, [createKey("itemMargin", size2)]: itemMargin, [createKey("inputWidth", size2)]: inputWidth, [createKey("selectWidth", size2)]: selectWidth, [createKey("inputMargin", size2)]: inputMargin, [createKey("selectMargin", size2)]: selectMargin, [createKey("jumperFontSize", size2)]: jumperFontSize, [createKey("prefixMargin", size2)]: prefixMargin, [createKey("suffixMargin", size2)]: suffixMargin, [createKey("itemSize", size2)]: itemSize, [createKey("buttonIconSize", size2)]: buttonIconSize, [createKey("itemFontSize", size2)]: itemFontSize, [`${createKey("itemMargin", size2)}Rtl`]: itemMarginRtl, [`${createKey("inputMargin", size2)}Rtl`]: inputMarginRtl }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
          return {
            "--n-prefix-margin": prefixMargin,
            "--n-suffix-margin": suffixMargin,
            "--n-item-font-size": itemFontSize,
            "--n-select-width": selectWidth,
            "--n-select-margin": selectMargin,
            "--n-input-width": inputWidth,
            "--n-input-margin": inputMargin,
            "--n-input-margin-rtl": inputMarginRtl,
            "--n-item-size": itemSize,
            "--n-item-text-color": itemTextColor,
            "--n-item-text-color-disabled": itemTextColorDisabled,
            "--n-item-text-color-hover": itemTextColorHover,
            "--n-item-text-color-active": itemTextColorActive,
            "--n-item-text-color-pressed": itemTextColorPressed,
            "--n-item-color": itemColor,
            "--n-item-color-hover": itemColorHover,
            "--n-item-color-disabled": itemColorDisabled,
            "--n-item-color-active": itemColorActive,
            "--n-item-color-active-hover": itemColorActiveHover,
            "--n-item-color-pressed": itemColorPressed,
            "--n-item-border": itemBorder,
            "--n-item-border-hover": itemBorderHover,
            "--n-item-border-disabled": itemBorderDisabled,
            "--n-item-border-active": itemBorderActive,
            "--n-item-border-pressed": itemBorderPressed,
            "--n-item-padding": itemPadding,
            "--n-item-border-radius": itemBorderRadius,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-jumper-font-size": jumperFontSize,
            "--n-jumper-text-color": jumperTextColor,
            "--n-jumper-text-color-disabled": jumperTextColorDisabled,
            "--n-item-margin": itemMargin,
            "--n-item-margin-rtl": itemMarginRtl,
            "--n-button-icon-size": buttonIconSize,
            "--n-button-icon-color": buttonIconColor,
            "--n-button-icon-color-hover": buttonIconColorHover,
            "--n-button-icon-color-pressed": buttonIconColorPressed,
            "--n-button-color-hover": buttonColorHover,
            "--n-button-color": buttonColor,
            "--n-button-color-pressed": buttonColorPressed,
            "--n-button-border": buttonBorder,
            "--n-button-border-hover": buttonBorderHover,
            "--n-button-border-pressed": buttonBorderPressed
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("pagination", computed(() => {
          let hash = "";
          const { size: size2 } = props;
          hash += size2[0];
          return hash;
        }), cssVarsRef, props) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          locale: localeRef,
          selfRef,
          mergedPage: mergedPageRef,
          pageItems: computed(() => {
            return pageItemsInfo.value.items;
          }),
          mergedItemCount: mergedItemCountRef,
          jumperValue: jumperValueRef,
          pageSizeOptions: pageSizeOptionsRef,
          mergedPageSize: mergedPageSizeRef,
          inputSize: inputSizeRef,
          selectSize: selectSizeRef,
          mergedTheme: themeRef,
          mergedPageCount: mergedPageCountRef,
          startIndex: startIndexRef,
          endIndex: endIndexRef,
          showFastForwardMenu: showFastForwardMenuRef,
          showFastBackwardMenu: showFastBackwardMenuRef,
          fastForwardActive: fastForwardActiveRef,
          fastBackwardActive: fastBackwardActiveRef,
          handleMenuSelect,
          handleFastForwardMouseenter,
          handleFastForwardMouseleave,
          handleFastBackwardMouseenter,
          handleFastBackwardMouseleave,
          handleJumperInput,
          handleBackwardClick: backward,
          handleForwardClick: forward,
          handlePageItemClick,
          handleSizePickerChange,
          handleQuickJumperChange,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { $slots, mergedClsPrefix, disabled, cssVars, mergedPage, mergedPageCount, pageItems, showSizePicker, showQuickJumper, mergedTheme, locale: locale2, inputSize, selectSize, mergedPageSize, pageSizeOptions, jumperValue, simple, prev, next, prefix: prefix2, suffix: suffix2, label, goto, handleJumperInput, handleSizePickerChange, handleBackwardClick, handlePageItemClick, handleForwardClick, handleQuickJumperChange, onRender } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const renderPrefix = $slots.prefix || prefix2;
        const renderSuffix = $slots.suffix || suffix2;
        const renderPrev = prev || $slots.prev;
        const renderNext = next || $slots.next;
        const renderLabel = label || $slots.label;
        return h(
          "div",
          { ref: "selfRef", class: [
            `${mergedClsPrefix}-pagination`,
            this.themeClass,
            this.rtlEnabled && `${mergedClsPrefix}-pagination--rtl`,
            disabled && `${mergedClsPrefix}-pagination--disabled`,
            simple && `${mergedClsPrefix}-pagination--simple`
          ], style: cssVars },
          renderPrefix ? h("div", { class: `${mergedClsPrefix}-pagination-prefix` }, renderPrefix({
            page: mergedPage,
            pageSize: mergedPageSize,
            pageCount: mergedPageCount,
            startIndex: this.startIndex,
            endIndex: this.endIndex,
            itemCount: this.mergedItemCount
          })) : null,
          this.displayOrder.map((part) => {
            switch (part) {
              case "pages":
                return h(
                  Fragment,
                  null,
                  h("div", { class: [
                    `${mergedClsPrefix}-pagination-item`,
                    !renderPrev && `${mergedClsPrefix}-pagination-item--button`,
                    (mergedPage <= 1 || mergedPage > mergedPageCount || disabled) && `${mergedClsPrefix}-pagination-item--disabled`
                  ], onClick: handleBackwardClick }, renderPrev ? renderPrev({
                    page: mergedPage,
                    pageSize: mergedPageSize,
                    pageCount: mergedPageCount,
                    startIndex: this.startIndex,
                    endIndex: this.endIndex,
                    itemCount: this.mergedItemCount
                  }) : h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                    default: () => this.rtlEnabled ? h(ForwardIcon, null) : h(BackwardIcon, null)
                  })),
                  simple ? h(
                    Fragment,
                    null,
                    h(
                      "div",
                      { class: `${mergedClsPrefix}-pagination-quick-jumper` },
                      h(NInput, { value: jumperValue, onUpdateValue: handleJumperInput, size: inputSize, placeholder: "", disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, onChange: handleQuickJumperChange })
                    ),
                    " / ",
                    mergedPageCount
                  ) : pageItems.map((pageItem, index) => {
                    let contentNode;
                    let onMouseenter;
                    let onMouseleave;
                    const { type: type2 } = pageItem;
                    switch (type2) {
                      case "page":
                        const pageNode = pageItem.label;
                        if (renderLabel) {
                          contentNode = renderLabel({
                            type: "page",
                            node: pageNode,
                            active: pageItem.active
                          });
                        } else {
                          contentNode = pageNode;
                        }
                        break;
                      case "fast-forward":
                        const fastForwardNode = this.fastForwardActive ? h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                          default: () => this.rtlEnabled ? h(FastBackwardIcon, null) : h(FastForwardIcon, null)
                        }) : h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(MoreIcon, null) });
                        if (renderLabel) {
                          contentNode = renderLabel({
                            type: "fast-forward",
                            node: fastForwardNode,
                            active: this.fastForwardActive || this.showFastForwardMenu
                          });
                        } else {
                          contentNode = fastForwardNode;
                        }
                        onMouseenter = this.handleFastForwardMouseenter;
                        onMouseleave = this.handleFastForwardMouseleave;
                        break;
                      case "fast-backward":
                        const fastBackwardNode = this.fastBackwardActive ? h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                          default: () => this.rtlEnabled ? h(FastForwardIcon, null) : h(FastBackwardIcon, null)
                        }) : h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(MoreIcon, null) });
                        if (renderLabel) {
                          contentNode = renderLabel({
                            type: "fast-backward",
                            node: fastBackwardNode,
                            active: this.fastBackwardActive || this.showFastBackwardMenu
                          });
                        } else {
                          contentNode = fastBackwardNode;
                        }
                        onMouseenter = this.handleFastBackwardMouseenter;
                        onMouseleave = this.handleFastBackwardMouseleave;
                        break;
                    }
                    const itemNode = h("div", { key: index, class: [
                      `${mergedClsPrefix}-pagination-item`,
                      pageItem.active && `${mergedClsPrefix}-pagination-item--active`,
                      type2 !== "page" && (type2 === "fast-backward" && this.showFastBackwardMenu || type2 === "fast-forward" && this.showFastForwardMenu) && `${mergedClsPrefix}-pagination-item--hover`,
                      disabled && `${mergedClsPrefix}-pagination-item--disabled`,
                      type2 === "page" && `${mergedClsPrefix}-pagination-item--clickable`
                    ], onClick: () => handlePageItemClick(pageItem), onMouseenter, onMouseleave }, contentNode);
                    if (type2 === "page" && !pageItem.mayBeFastBackward && !pageItem.mayBeFastForward) {
                      return itemNode;
                    } else {
                      const key = pageItem.type === "page" ? pageItem.mayBeFastBackward ? "fast-backward" : "fast-forward" : pageItem.type;
                      return h(NPopselect, { to: this.to, key, disabled, trigger: "hover", virtualScroll: true, style: { width: "60px" }, theme: mergedTheme.peers.Popselect, themeOverrides: mergedTheme.peerOverrides.Popselect, builtinThemeOverrides: {
                        peers: {
                          InternalSelectMenu: {
                            height: "calc(var(--n-option-height) * 4.6)"
                          }
                        }
                      }, nodeProps: () => ({
                        style: {
                          justifyContent: "center"
                        }
                      }), show: type2 === "page" ? false : type2 === "fast-backward" ? this.showFastBackwardMenu : this.showFastForwardMenu, onUpdateShow: (value) => {
                        if (type2 === "page")
                          return;
                        if (value) {
                          if (type2 === "fast-backward") {
                            this.showFastBackwardMenu = value;
                          } else {
                            this.showFastForwardMenu = value;
                          }
                        } else {
                          this.showFastBackwardMenu = false;
                          this.showFastForwardMenu = false;
                        }
                      }, options: pageItem.type !== "page" ? pageItem.options : [], onUpdateValue: this.handleMenuSelect, scrollable: true, showCheckmark: false }, { default: () => itemNode });
                    }
                  }),
                  h("div", { class: [
                    `${mergedClsPrefix}-pagination-item`,
                    !renderNext && `${mergedClsPrefix}-pagination-item--button`,
                    {
                      [`${mergedClsPrefix}-pagination-item--disabled`]: mergedPage < 1 || mergedPage >= mergedPageCount || disabled
                    }
                  ], onClick: handleForwardClick }, renderNext ? renderNext({
                    page: mergedPage,
                    pageSize: mergedPageSize,
                    pageCount: mergedPageCount,
                    itemCount: this.mergedItemCount,
                    startIndex: this.startIndex,
                    endIndex: this.endIndex
                  }) : h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                    default: () => this.rtlEnabled ? h(BackwardIcon, null) : h(ForwardIcon, null)
                  }))
                );
              case "size-picker": {
                return !simple && showSizePicker ? h(NSelect, Object.assign({ consistentMenuWidth: false, placeholder: "", showCheckmark: false, to: this.to }, this.selectProps, { size: selectSize, options: pageSizeOptions, value: mergedPageSize, disabled, theme: mergedTheme.peers.Select, themeOverrides: mergedTheme.peerOverrides.Select, onUpdateValue: handleSizePickerChange })) : null;
              }
              case "quick-jumper":
                return !simple && showQuickJumper ? h(
                  "div",
                  { class: `${mergedClsPrefix}-pagination-quick-jumper` },
                  goto ? goto() : resolveSlot(this.$slots.goto, () => [locale2.goto]),
                  h(NInput, { value: jumperValue, onUpdateValue: handleJumperInput, size: inputSize, placeholder: "", disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, onChange: handleQuickJumperChange })
                ) : null;
              default:
                return null;
            }
          }),
          renderSuffix ? h("div", { class: `${mergedClsPrefix}-pagination-suffix` }, renderSuffix({
            page: mergedPage,
            pageSize: mergedPageSize,
            pageCount: mergedPageCount,
            startIndex: this.startIndex,
            endIndex: this.endIndex,
            itemCount: this.mergedItemCount
          })) : null
        );
      }
    });
    const commonVars = {
      padding: "8px 14px"
    };
    const self$8 = (vars) => {
      const { borderRadius, boxShadow2, baseColor } = vars;
      return Object.assign(Object.assign({}, commonVars), { borderRadius, boxShadow: boxShadow2, color: composite(baseColor, "rgba(0, 0, 0, .85)"), textColor: baseColor });
    };
    const tooltipLight = createTheme({
      name: "Tooltip",
      common: commonLight,
      peers: {
        Popover: popoverLight$1
      },
      self: self$8
    });
    const tooltipLight$1 = tooltipLight;
    const ellipsisLight = createTheme({
      name: "Ellipsis",
      common: commonLight,
      peers: {
        Tooltip: tooltipLight$1
      }
    });
    const ellipsisLight$1 = ellipsisLight;
    const commonVariables$4 = {
      radioSizeSmall: "14px",
      radioSizeMedium: "16px",
      radioSizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    const self$7 = (vars) => {
      const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight: lineHeight2 } = vars;
      return Object.assign(Object.assign({}, commonVariables$4), {
        labelLineHeight: lineHeight2,
        buttonHeightSmall: heightSmall,
        buttonHeightMedium: heightMedium,
        buttonHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        boxShadow: `inset 0 0 0 1px ${borderColor}`,
        boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`,
        boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
        color: baseColor,
        colorDisabled: inputColorDisabled,
        colorActive: "#0000",
        textColor: textColor2,
        textColorDisabled,
        dotColorActive: primaryColor,
        dotColorDisabled: borderColor,
        buttonBorderColor: borderColor,
        buttonBorderColorActive: primaryColor,
        buttonBorderColorHover: borderColor,
        buttonColor: baseColor,
        buttonColorActive: baseColor,
        buttonTextColor: textColor2,
        buttonTextColorActive: primaryColor,
        buttonTextColorHover: primaryColor,
        opacityDisabled,
        buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
        buttonBoxShadowHover: "inset 0 0 0 1px #0000",
        buttonBoxShadow: "inset 0 0 0 1px #0000",
        buttonBorderRadius: borderRadius
      });
    };
    const radioLight = {
      name: "Radio",
      common: commonLight,
      self: self$7
    };
    const radioLight$1 = radioLight;
    const commonVariables$3 = {
      padding: "4px 0",
      optionIconSizeSmall: "14px",
      optionIconSizeMedium: "16px",
      optionIconSizeLarge: "16px",
      optionIconSizeHuge: "18px",
      optionSuffixWidthSmall: "14px",
      optionSuffixWidthMedium: "14px",
      optionSuffixWidthLarge: "16px",
      optionSuffixWidthHuge: "16px",
      optionIconSuffixWidthSmall: "32px",
      optionIconSuffixWidthMedium: "32px",
      optionIconSuffixWidthLarge: "36px",
      optionIconSuffixWidthHuge: "36px",
      optionPrefixWidthSmall: "14px",
      optionPrefixWidthMedium: "14px",
      optionPrefixWidthLarge: "16px",
      optionPrefixWidthHuge: "16px",
      optionIconPrefixWidthSmall: "36px",
      optionIconPrefixWidthMedium: "36px",
      optionIconPrefixWidthLarge: "40px",
      optionIconPrefixWidthHuge: "40px"
    };
    const self$6 = (vars) => {
      const { primaryColor, textColor2, dividerColor, hoverColor, popoverColor, invertedColor, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge, textColor3, opacityDisabled } = vars;
      return Object.assign(Object.assign({}, commonVariables$3), {
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        // non-inverted
        optionTextColor: textColor2,
        optionTextColorHover: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorChildActive: primaryColor,
        color: popoverColor,
        dividerColor,
        suffixColor: textColor2,
        prefixColor: textColor2,
        optionColorHover: hoverColor,
        optionColorActive: changeColor(primaryColor, { alpha: 0.1 }),
        groupHeaderTextColor: textColor3,
        // inverted
        optionTextColorInverted: "#BBB",
        optionTextColorHoverInverted: "#FFF",
        optionTextColorActiveInverted: "#FFF",
        optionTextColorChildActiveInverted: "#FFF",
        colorInverted: invertedColor,
        dividerColorInverted: "#BBB",
        suffixColorInverted: "#BBB",
        prefixColorInverted: "#BBB",
        optionColorHoverInverted: primaryColor,
        optionColorActiveInverted: primaryColor,
        groupHeaderTextColorInverted: "#AAA",
        optionOpacityDisabled: opacityDisabled
      });
    };
    const dropdownLight = createTheme({
      name: "Dropdown",
      common: commonLight,
      peers: {
        Popover: popoverLight$1
      },
      self: self$6
    });
    const dropdownLight$1 = dropdownLight;
    const commonVariables$2 = {
      thPaddingSmall: "8px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "8px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px",
      sorterSize: "15px",
      resizableContainerSize: "8px",
      resizableSize: "2px",
      filterSize: "15px",
      paginationMargin: "12px 0 0 0",
      emptyPadding: "48px 0",
      actionPadding: "8px 12px",
      actionButtonMargin: "0 8px 0 0"
    };
    const self$5 = (vars) => {
      const { cardColor, modalColor, popoverColor, textColor2, textColor1, tableHeaderColor, tableColorHover, iconColor, primaryColor, fontWeightStrong, borderRadius, lineHeight: lineHeight2, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor, heightSmall, opacityDisabled, tableColorStriped } = vars;
      return Object.assign(Object.assign({}, commonVariables$2), {
        actionDividerColor: dividerColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderColor: composite(cardColor, dividerColor),
        tdColorHover: composite(cardColor, tableColorHover),
        tdColorStriped: composite(cardColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        tdColor: cardColor,
        tdTextColor: textColor2,
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        thButtonColorHover: tableColorHover,
        thIconColor: iconColor,
        thIconColorActive: primaryColor,
        // modal
        borderColorModal: composite(modalColor, dividerColor),
        tdColorHoverModal: composite(modalColor, tableColorHover),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        tdColorModal: modalColor,
        // popover
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColorHoverPopover: composite(popoverColor, tableColorHover),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        tdColorPopover: popoverColor,
        boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
        boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
        // loading
        loadingColor: primaryColor,
        loadingSize: heightSmall,
        opacityLoading: opacityDisabled
      });
    };
    const dataTableLight = createTheme({
      name: "DataTable",
      common: commonLight,
      peers: {
        Button: buttonLight$1,
        Checkbox: checkboxLight$1,
        Radio: radioLight$1,
        Pagination: paginationLight$1,
        Scrollbar: scrollbarLight$1,
        Empty: emptyLight$1,
        Popover: popoverLight$1,
        Ellipsis: ellipsisLight$1,
        Dropdown: dropdownLight$1
      },
      self: self$5
    });
    const dataTableLight$1 = dataTableLight;
    const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
    const NTooltip = defineComponent({
      name: "Tooltip",
      props: tooltipProps,
      __popover__: true,
      setup(props) {
        const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight$1, props);
        const popoverRef = ref(null);
        const tooltipExposedMethod = {
          syncPosition() {
            popoverRef.value.syncPosition();
          },
          setShow(show) {
            popoverRef.value.setShow(show);
          }
        };
        return Object.assign(Object.assign({}, tooltipExposedMethod), { popoverRef, mergedTheme: themeRef, popoverThemeOverrides: computed(() => {
          return themeRef.value.self;
        }) });
      },
      render() {
        const { mergedTheme, internalExtraClass } = this;
        return h(NPopover, Object.assign(Object.assign({}, this.$props), { theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, builtinThemeOverrides: this.popoverThemeOverrides, internalExtraClass: internalExtraClass.concat("tooltip"), ref: "popoverRef" }), this.$slots);
      }
    });
    const style$9 = cB("ellipsis", {
      overflow: "hidden"
    }, [cNotM("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), cM("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), cM("cursor-pointer", `
 cursor: pointer;
 `)]);
    function createLineClampClass(clsPrefix) {
      return `${clsPrefix}-ellipsis--line-clamp`;
    }
    function createCursorClass(clsPrefix, cursor) {
      return `${clsPrefix}-ellipsis--cursor-${cursor}`;
    }
    const ellipsisProps = Object.assign(Object.assign({}, useTheme.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: {
      type: [Boolean, Object],
      default: true
    } });
    const NEllipsis = defineComponent({
      name: "Ellipsis",
      inheritAttrs: false,
      props: ellipsisProps,
      setup(props, { slots, attrs }) {
        const { mergedClsPrefixRef } = useConfig(props);
        const mergedTheme = useTheme("Ellipsis", "-ellipsis", style$9, ellipsisLight$1, props, mergedClsPrefixRef);
        const triggerRef = ref(null);
        const triggerInnerRef = ref(null);
        const tooltipRef = ref(null);
        const expandedRef = ref(false);
        const ellipsisStyleRef = computed(() => {
          const { lineClamp } = props;
          const { value: expanded } = expandedRef;
          if (lineClamp !== void 0) {
            return {
              textOverflow: "",
              "-webkit-line-clamp": expanded ? "" : lineClamp
            };
          } else {
            return {
              textOverflow: expanded ? "" : "ellipsis",
              "-webkit-line-clamp": ""
            };
          }
        });
        function getTooltipDisabled() {
          let tooltipDisabled = false;
          const { value: expanded } = expandedRef;
          if (expanded)
            return true;
          const { value: trigger2 } = triggerRef;
          if (trigger2) {
            const { lineClamp } = props;
            syncEllipsisStyle(trigger2);
            if (lineClamp !== void 0) {
              tooltipDisabled = trigger2.scrollHeight <= trigger2.offsetHeight;
            } else {
              const { value: triggerInner } = triggerInnerRef;
              if (triggerInner) {
                tooltipDisabled = triggerInner.getBoundingClientRect().width <= trigger2.getBoundingClientRect().width;
              }
            }
            syncCursorStyle(trigger2, tooltipDisabled);
          }
          return tooltipDisabled;
        }
        const handleClickRef = computed(() => {
          return props.expandTrigger === "click" ? () => {
            var _a;
            const { value: expanded } = expandedRef;
            if (expanded) {
              (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
            }
            expandedRef.value = !expanded;
          } : void 0;
        });
        onDeactivated(() => {
          var _a;
          if (props.tooltip) {
            (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
          }
        });
        const renderTrigger = () => h("span", Object.assign({}, mergeProps(attrs, {
          class: [
            `${mergedClsPrefixRef.value}-ellipsis`,
            props.lineClamp !== void 0 ? createLineClampClass(mergedClsPrefixRef.value) : void 0,
            props.expandTrigger === "click" ? createCursorClass(mergedClsPrefixRef.value, "pointer") : void 0
          ],
          style: ellipsisStyleRef.value
        }), { ref: "triggerRef", onClick: handleClickRef.value, onMouseenter: (
          // get tooltip disabled will derive cursor style
          props.expandTrigger === "click" ? getTooltipDisabled : void 0
        ) }), props.lineClamp ? slots : h("span", { ref: "triggerInnerRef" }, slots));
        function syncEllipsisStyle(trigger2) {
          if (!trigger2)
            return;
          const latestStyle = ellipsisStyleRef.value;
          const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
          if (props.lineClamp !== void 0) {
            syncTriggerClass(trigger2, lineClampClass, "add");
          } else {
            syncTriggerClass(trigger2, lineClampClass, "remove");
          }
          for (const key in latestStyle) {
            if (trigger2.style[key] !== latestStyle[key]) {
              trigger2.style[key] = latestStyle[key];
            }
          }
        }
        function syncCursorStyle(trigger2, tooltipDisabled) {
          const cursorClass = createCursorClass(mergedClsPrefixRef.value, "pointer");
          if (props.expandTrigger === "click" && !tooltipDisabled) {
            syncTriggerClass(trigger2, cursorClass, "add");
          } else {
            syncTriggerClass(trigger2, cursorClass, "remove");
          }
        }
        function syncTriggerClass(trigger2, styleClass, action) {
          if (action === "add") {
            if (!trigger2.classList.contains(styleClass)) {
              trigger2.classList.add(styleClass);
            }
          } else {
            if (trigger2.classList.contains(styleClass)) {
              trigger2.classList.remove(styleClass);
            }
          }
        }
        return {
          mergedTheme,
          triggerRef,
          triggerInnerRef,
          tooltipRef,
          handleClick: handleClickRef,
          renderTrigger,
          getTooltipDisabled
        };
      },
      render() {
        var _a;
        const { tooltip, renderTrigger, $slots } = this;
        if (tooltip) {
          const { mergedTheme } = this;
          return h(NTooltip, Object.assign({ ref: "tooltipRef", placement: "top" }, tooltip, { getDisabled: this.getTooltipDisabled, theme: mergedTheme.peers.Tooltip, themeOverrides: mergedTheme.peerOverrides.Tooltip }), {
            trigger: renderTrigger,
            default: (_a = $slots.tooltip) !== null && _a !== void 0 ? _a : $slots.default
          });
        } else
          return renderTrigger();
      }
    });
    const RenderSorter = defineComponent({
      name: "DataTableRenderSorter",
      props: {
        render: {
          type: Function,
          required: true
        },
        order: {
          // asc, desc
          type: [String, Boolean],
          default: false
        }
      },
      render() {
        const { render: render2, order } = this;
        return render2({
          order
        });
      }
    });
    const dataTableProps = Object.assign(Object.assign({}, useTheme.props), {
      onUnstableColumnResize: Function,
      pagination: {
        type: [Object, Boolean],
        default: false
      },
      paginateSinglePage: {
        type: Boolean,
        default: true
      },
      minHeight: [Number, String],
      maxHeight: [Number, String],
      // Use any type as row data to make prop data acceptable
      columns: {
        type: Array,
        default: () => []
      },
      rowClassName: [String, Function],
      rowProps: Function,
      rowKey: Function,
      summary: [Function],
      data: {
        type: Array,
        default: () => []
      },
      loading: Boolean,
      bordered: {
        type: Boolean,
        default: void 0
      },
      bottomBordered: {
        type: Boolean,
        default: void 0
      },
      striped: Boolean,
      scrollX: [Number, String],
      defaultCheckedRowKeys: {
        type: Array,
        default: () => []
      },
      checkedRowKeys: Array,
      singleLine: {
        type: Boolean,
        default: true
      },
      singleColumn: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      remote: Boolean,
      defaultExpandedRowKeys: {
        type: Array,
        default: []
      },
      defaultExpandAll: Boolean,
      expandedRowKeys: Array,
      stickyExpandedRows: Boolean,
      virtualScroll: Boolean,
      tableLayout: {
        type: String,
        default: "auto"
      },
      allowCheckingNotLoaded: Boolean,
      cascade: {
        type: Boolean,
        default: true
      },
      childrenKey: {
        type: String,
        default: "children"
      },
      indent: {
        type: Number,
        default: 16
      },
      flexHeight: Boolean,
      summaryPlacement: {
        type: String,
        default: "bottom"
      },
      paginationBehaviorOnFilter: {
        type: String,
        default: "current"
      },
      scrollbarProps: Object,
      renderCell: Function,
      renderExpandIcon: Function,
      spinProps: { type: Object, default: {} },
      onLoad: Function,
      "onUpdate:page": [Function, Array],
      onUpdatePage: [Function, Array],
      "onUpdate:pageSize": [Function, Array],
      onUpdatePageSize: [Function, Array],
      "onUpdate:sorter": [Function, Array],
      onUpdateSorter: [Function, Array],
      "onUpdate:filters": [Function, Array],
      onUpdateFilters: [Function, Array],
      "onUpdate:checkedRowKeys": [Function, Array],
      onUpdateCheckedRowKeys: [Function, Array],
      "onUpdate:expandedRowKeys": [Function, Array],
      onUpdateExpandedRowKeys: [Function, Array],
      onScroll: Function,
      // deprecated
      onPageChange: [Function, Array],
      onPageSizeChange: [Function, Array],
      onSorterChange: [Function, Array],
      onFiltersChange: [Function, Array],
      onCheckedRowKeysChange: [Function, Array]
    });
    const dataTableInjectionKey = createInjectionKey("n-data-table");
    const SortButton = defineComponent({
      name: "SortIcon",
      props: {
        column: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const { mergedComponentPropsRef } = useConfig();
        const { mergedSortStateRef, mergedClsPrefixRef } = inject(dataTableInjectionKey);
        const sortStateRef = computed(() => mergedSortStateRef.value.find((state) => state.columnKey === props.column.key));
        const activeRef = computed(() => {
          return sortStateRef.value !== void 0;
        });
        const mergedSortOrderRef = computed(() => {
          const { value: sortState } = sortStateRef;
          if (sortState && activeRef.value) {
            return sortState.order;
          }
          return false;
        });
        const mergedRenderSorterRef = computed(() => {
          var _a, _b;
          return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderSorter) || props.column.renderSorter;
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          active: activeRef,
          mergedSortOrder: mergedSortOrderRef,
          mergedRenderSorter: mergedRenderSorterRef
        };
      },
      render() {
        const { mergedRenderSorter, mergedSortOrder, mergedClsPrefix } = this;
        const { renderSorterIcon } = this.column;
        return mergedRenderSorter ? h(RenderSorter, { render: mergedRenderSorter, order: mergedSortOrder }) : h("span", { class: [
          `${mergedClsPrefix}-data-table-sorter`,
          mergedSortOrder === "ascend" && `${mergedClsPrefix}-data-table-sorter--asc`,
          mergedSortOrder === "descend" && `${mergedClsPrefix}-data-table-sorter--desc`
        ] }, renderSorterIcon ? renderSorterIcon({ order: mergedSortOrder }) : h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(ArrowDownIcon, null) }));
      }
    });
    const RenderFilter = defineComponent({
      name: "DataTableRenderFilter",
      props: {
        render: {
          type: Function,
          required: true
        },
        active: {
          type: Boolean,
          default: false
        },
        show: {
          type: Boolean,
          default: false
        }
      },
      render() {
        const { render: render2, active, show } = this;
        return render2({
          active,
          show
        });
      }
    });
    const radioProps = {
      name: String,
      value: {
        type: [String, Number, Boolean],
        default: "on"
      },
      checked: {
        type: Boolean,
        default: void 0
      },
      defaultChecked: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      label: String,
      size: String,
      onUpdateChecked: [Function, Array],
      "onUpdate:checked": [Function, Array],
      // deprecated
      checkedValue: {
        type: Boolean,
        default: void 0
      }
    };
    const radioGroupInjectionKey = createInjectionKey("n-radio-group");
    function setup(props) {
      const formItem = useFormItem(props, {
        mergedSize(NFormItem2) {
          const { size: size2 } = props;
          if (size2 !== void 0)
            return size2;
          if (NRadioGroup2) {
            const { mergedSizeRef: { value: mergedSize } } = NRadioGroup2;
            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }
          if (NFormItem2) {
            return NFormItem2.mergedSize.value;
          }
          return "medium";
        },
        mergedDisabled(NFormItem2) {
          if (props.disabled)
            return true;
          if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value)
            return true;
          if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value)
            return true;
          return false;
        }
      });
      const { mergedSizeRef, mergedDisabledRef } = formItem;
      const inputRef = ref(null);
      const labelRef = ref(null);
      const NRadioGroup2 = inject(radioGroupInjectionKey, null);
      const uncontrolledCheckedRef = ref(props.defaultChecked);
      const controlledCheckedRef = toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderSafeCheckedRef = useMemo(() => {
        if (NRadioGroup2)
          return NRadioGroup2.valueRef.value === props.value;
        return mergedCheckedRef.value;
      });
      const mergedNameRef = useMemo(() => {
        const { name } = props;
        if (name !== void 0)
          return name;
        if (NRadioGroup2)
          return NRadioGroup2.nameRef.value;
      });
      const focusRef = ref(false);
      function doUpdateChecked() {
        if (NRadioGroup2) {
          const { doUpdateValue } = NRadioGroup2;
          const { value } = props;
          call(doUpdateValue, value);
        } else {
          const { onUpdateChecked, "onUpdate:checked": _onUpdateChecked } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onUpdateChecked)
            call(onUpdateChecked, true);
          if (_onUpdateChecked)
            call(_onUpdateChecked, true);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = true;
        }
      }
      function toggle() {
        if (mergedDisabledRef.value)
          return;
        if (!renderSafeCheckedRef.value) {
          doUpdateChecked();
        }
      }
      function handleRadioInputChange() {
        toggle();
      }
      function handleRadioInputBlur() {
        focusRef.value = false;
      }
      function handleRadioInputFocus() {
        focusRef.value = true;
      }
      return {
        mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
        inputRef,
        labelRef,
        mergedName: mergedNameRef,
        mergedDisabled: mergedDisabledRef,
        uncontrolledChecked: uncontrolledCheckedRef,
        renderSafeChecked: renderSafeCheckedRef,
        focus: focusRef,
        mergedSize: mergedSizeRef,
        handleRadioInputChange,
        handleRadioInputBlur,
        handleRadioInputFocus
      };
    }
    const style$8 = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM("checked", [cE("dot", `
 background-color: var(--n-color-active);
 `)]), cE("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM("checked", {
      boxShadow: "var(--n-box-shadow-active)"
    }, [c$1("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("dot", {
      boxShadow: "var(--n-box-shadow-hover)"
    })]), cM("focus", [c$1("&:not(:active)", [cE("dot", {
      boxShadow: "var(--n-box-shadow-focus)"
    })])])]), cM("disabled", `
 cursor: not-allowed;
 `, [cE("dot", {
      boxShadow: "var(--n-box-shadow-disabled)",
      backgroundColor: "var(--n-color-disabled)"
    }, [c$1("&::before", {
      backgroundColor: "var(--n-dot-color-disabled)"
    }), cM("checked", `
 opacity: 1;
 `)]), cE("label", {
      color: "var(--n-text-color-disabled)"
    }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
    const NRadio = defineComponent({
      name: "Radio",
      props: Object.assign(Object.assign({}, useTheme.props), radioProps),
      setup(props) {
        const radio = setup(props);
        const themeRef = useTheme("Radio", "-radio", style$8, radioLight$1, props, radio.mergedClsPrefix);
        const cssVarsRef = computed(() => {
          const { mergedSize: { value: size2 } } = radio;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { boxShadow, boxShadowActive, boxShadowDisabled, boxShadowFocus, boxShadowHover, color, colorDisabled, colorActive, textColor, textColorDisabled, dotColorActive, dotColorDisabled, labelPadding, labelLineHeight, labelFontWeight, [createKey("fontSize", size2)]: fontSize2, [createKey("radioSize", size2)]: radioSize } } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-label-line-height": labelLineHeight,
            "--n-label-font-weight": labelFontWeight,
            "--n-box-shadow": boxShadow,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-disabled": boxShadowDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-color": color,
            "--n-color-active": colorActive,
            "--n-color-disabled": colorDisabled,
            "--n-dot-color-active": dotColorActive,
            "--n-dot-color-disabled": dotColorDisabled,
            "--n-font-size": fontSize2,
            "--n-radio-size": radioSize,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-label-padding": labelPadding
          };
        });
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
        return Object.assign(radio, {
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const { $slots, mergedClsPrefix, onRender, label } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h(
          "label",
          { class: [
            `${mergedClsPrefix}-radio`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-radio--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-radio--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-radio--checked`]: this.renderSafeChecked,
              [`${mergedClsPrefix}-radio--focus`]: this.focus
            }
          ], style: this.cssVars },
          h("input", { ref: "inputRef", type: "radio", class: `${mergedClsPrefix}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }),
          h(
            "div",
            { class: `${mergedClsPrefix}-radio__dot-wrapper` },
            " ",
            h("div", { class: [
              `${mergedClsPrefix}-radio__dot`,
              this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`
            ] })
          ),
          resolveWrappedSlot($slots.default, (children) => {
            if (!children && !label)
              return null;
            return h("div", { ref: "labelRef", class: `${mergedClsPrefix}-radio__label` }, children || label);
          })
        );
      }
    });
    const style$7 = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM("checked", {
      backgroundColor: "var(--n-button-border-color-active)"
    }), cM("disabled", {
      opacity: "var(--n-opacity-disabled)"
    })]), cM("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
      height: "var(--n-height)",
      lineHeight: "var(--n-height)"
    }), cE("splitor", {
      height: "var(--n-height)"
    })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c$1("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c$1("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
      color: "var(--n-button-text-color-hover)"
    })]), cM("focus", [c$1("&:not(:active)", [cE("state-border", {
      boxShadow: "var(--n-button-box-shadow-focus)"
    })])])]), cM("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
    function mapSlot(defaultSlot, value, clsPrefix) {
      var _a;
      const children = [];
      let isButtonGroup = false;
      for (let i = 0; i < defaultSlot.length; ++i) {
        const wrappedInstance = defaultSlot[i];
        const name = (_a = wrappedInstance.type) === null || _a === void 0 ? void 0 : _a.name;
        if (name === "RadioButton") {
          isButtonGroup = true;
        }
        const instanceProps = wrappedInstance.props;
        if (name !== "RadioButton") {
          children.push(wrappedInstance);
          continue;
        }
        if (i === 0) {
          children.push(wrappedInstance);
        } else {
          const lastInstanceProps = children[children.length - 1].props;
          const lastInstanceChecked = value === lastInstanceProps.value;
          const lastInstanceDisabled = lastInstanceProps.disabled;
          const currentInstanceChecked = value === instanceProps.value;
          const currentInstanceDisabled = instanceProps.disabled;
          const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
          const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
          const lastInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
          };
          const currentInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
          };
          const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
          children.push(h("div", { class: [`${clsPrefix}-radio-group__splitor`, splitorClass] }), wrappedInstance);
        }
      }
      return {
        children,
        isButtonGroup
      };
    }
    const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), { name: String, value: [String, Number, Boolean], defaultValue: {
      type: [String, Number, Boolean],
      default: null
    }, size: String, disabled: {
      type: Boolean,
      default: void 0
    }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
    const NRadioGroup = defineComponent({
      name: "RadioGroup",
      props: radioGroupProps,
      setup(props) {
        const selfElRef = ref(null);
        const { mergedSizeRef, mergedDisabledRef, nTriggerFormChange, nTriggerFormInput, nTriggerFormBlur, nTriggerFormFocus } = useFormItem(props);
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Radio", "-radio-group", style$7, radioLight$1, props, mergedClsPrefixRef);
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        function doUpdateValue(value) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function handleFocusin(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (selfEl.contains(e.relatedTarget))
            return;
          nTriggerFormFocus();
        }
        function handleFocusout(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (selfEl.contains(e.relatedTarget))
            return;
          nTriggerFormBlur();
        }
        provide(radioGroupInjectionKey, {
          mergedClsPrefixRef,
          nameRef: toRef(props, "name"),
          valueRef: mergedValueRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          doUpdateValue
        });
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { value: size2 } = mergedSizeRef;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { buttonBorderColor, buttonBorderColorActive, buttonBorderRadius, buttonBoxShadow, buttonBoxShadowFocus, buttonBoxShadowHover, buttonColorActive, buttonTextColor, buttonTextColorActive, buttonTextColorHover, opacityDisabled, [createKey("buttonHeight", size2)]: height, [createKey("fontSize", size2)]: fontSize2 } } = themeRef.value;
          return {
            "--n-font-size": fontSize2,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-color": buttonBorderColor,
            "--n-button-border-color-active": buttonBorderColorActive,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-box-shadow-focus": buttonBoxShadowFocus,
            "--n-button-box-shadow-hover": buttonBoxShadowHover,
            "--n-button-color-active": buttonColorActive,
            "--n-button-text-color": buttonTextColor,
            "--n-button-text-color-hover": buttonTextColorHover,
            "--n-button-text-color-active": buttonTextColorActive,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          handleFocusout,
          handleFocusin,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        var _a;
        const { mergedValue, mergedClsPrefix, handleFocusin, handleFocusout } = this;
        const { children, isButtonGroup } = mapSlot(flatten$3(getSlot$1(this)), mergedValue, mergedClsPrefix);
        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
        return h("div", { onFocusin: handleFocusin, onFocusout: handleFocusout, ref: "selfElRef", class: [
          `${mergedClsPrefix}-radio-group`,
          this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`,
          this.themeClass,
          isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`
        ], style: this.cssVars }, children);
      }
    });
    const SELECTION_COL_WIDTH = 40;
    const EXPAND_COL_WIDTH = 40;
    function getNumberColWidth(col) {
      if (col.type === "selection") {
        return col.width === void 0 ? SELECTION_COL_WIDTH : depx(col.width);
      }
      if (col.type === "expand") {
        return col.width === void 0 ? EXPAND_COL_WIDTH : depx(col.width);
      }
      if ("children" in col)
        return void 0;
      if (typeof col.width === "string") {
        return depx(col.width);
      }
      return col.width;
    }
    function getStringColWidth(col) {
      var _a, _b;
      if (col.type === "selection") {
        return formatLength((_a = col.width) !== null && _a !== void 0 ? _a : SELECTION_COL_WIDTH);
      }
      if (col.type === "expand") {
        return formatLength((_b = col.width) !== null && _b !== void 0 ? _b : EXPAND_COL_WIDTH);
      }
      if ("children" in col) {
        return void 0;
      }
      return formatLength(col.width);
    }
    function getColKey(col) {
      if (col.type === "selection")
        return "__n_selection__";
      if (col.type === "expand")
        return "__n_expand__";
      return col.key;
    }
    function createShallowClonedObject(object2) {
      if (!object2)
        return object2;
      if (typeof object2 === "object") {
        return Object.assign({}, object2);
      }
      return object2;
    }
    function getFlagOfOrder(order) {
      if (order === "ascend")
        return 1;
      else if (order === "descend")
        return -1;
      return 0;
    }
    function clampValueFollowCSSRules(value, min, max) {
      if (max !== void 0) {
        value = Math.min(value, typeof max === "number" ? max : parseFloat(max));
      }
      if (min !== void 0) {
        value = Math.max(value, typeof min === "number" ? min : parseFloat(min));
      }
      return value;
    }
    function createCustomWidthStyle(column, resizedWidth) {
      if (resizedWidth !== void 0) {
        return {
          width: resizedWidth,
          minWidth: resizedWidth,
          maxWidth: resizedWidth
        };
      }
      const width = getStringColWidth(column);
      const { minWidth, maxWidth } = column;
      return {
        width,
        minWidth: formatLength(minWidth) || width,
        maxWidth: formatLength(maxWidth)
      };
    }
    function createRowClassName(row, index, rowClassName) {
      if (typeof rowClassName === "function")
        return rowClassName(row, index);
      return rowClassName || "";
    }
    function shouldUseArrayInSingleMode(column) {
      return column.filterOptionValues !== void 0 || column.filterOptionValue === void 0 && column.defaultFilterOptionValues !== void 0;
    }
    function isColumnSortable(column) {
      if ("children" in column)
        return false;
      return !!column.sorter;
    }
    function isColumnResizable(column) {
      if ("children" in column && !!column.children.length)
        return false;
      return !!column.resizable;
    }
    function isColumnFilterable(column) {
      if ("children" in column)
        return false;
      return !!column.filter && (!!column.filterOptions || !!column.renderFilterMenu);
    }
    function getNextOrderOf(order) {
      if (!order)
        return "descend";
      else if (order === "descend")
        return "ascend";
      return false;
    }
    function createNextSorter(column, currentSortState) {
      if (column.sorter === void 0)
        return null;
      if (currentSortState === null || currentSortState.columnKey !== column.key) {
        return {
          columnKey: column.key,
          sorter: column.sorter,
          order: getNextOrderOf(false)
        };
      } else {
        return Object.assign(Object.assign({}, currentSortState), { order: getNextOrderOf(currentSortState.order) });
      }
    }
    function isColumnSorting(column, mergedSortState) {
      return mergedSortState.find((state) => state.columnKey === column.key && state.order) !== void 0;
    }
    const NDataTableFilterMenu = defineComponent({
      name: "DataTableFilterMenu",
      props: {
        column: {
          type: Object,
          required: true
        },
        radioGroupName: {
          type: String,
          required: true
        },
        multiple: {
          type: Boolean,
          required: true
        },
        value: {
          type: [Array, String, Number],
          default: null
        },
        options: {
          type: Array,
          required: true
        },
        onConfirm: {
          type: Function,
          required: true
        },
        onClear: {
          type: Function,
          required: true
        },
        onChange: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          mergedClsPrefixRef,
          mergedThemeRef,
          localeRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        const temporalValueRef = ref(props.value);
        const checkboxGroupValueRef = computed(() => {
          const { value: temporalValue } = temporalValueRef;
          if (!Array.isArray(temporalValue))
            return null;
          return temporalValue;
        });
        const radioGroupValueRef = computed(() => {
          const { value: temporalValue } = temporalValueRef;
          if (shouldUseArrayInSingleMode(props.column)) {
            return Array.isArray(temporalValue) && temporalValue.length && temporalValue[0] || null;
          }
          if (!Array.isArray(temporalValue))
            return temporalValue;
          return null;
        });
        function doChange(value) {
          props.onChange(value);
        }
        function handleChange(value) {
          if (props.multiple && Array.isArray(value)) {
            temporalValueRef.value = value;
          } else if (shouldUseArrayInSingleMode(props.column) && !Array.isArray(value)) {
            temporalValueRef.value = [value];
          } else {
            temporalValueRef.value = value;
          }
        }
        function handleConfirmClick() {
          doChange(temporalValueRef.value);
          props.onConfirm();
        }
        function handleClearClick() {
          if (props.multiple || shouldUseArrayInSingleMode(props.column)) {
            doChange([]);
          } else {
            doChange(null);
          }
          props.onClear();
        }
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          locale: localeRef,
          checkboxGroupValue: checkboxGroupValueRef,
          radioGroupValue: radioGroupValueRef,
          handleChange,
          handleConfirmClick,
          handleClearClick
        };
      },
      render() {
        const { mergedTheme, locale: locale2, mergedClsPrefix } = this;
        return h(
          "div",
          { class: `${mergedClsPrefix}-data-table-filter-menu` },
          h(NScrollbar, null, {
            default: () => {
              const { checkboxGroupValue, handleChange } = this;
              return this.multiple ? h(NCheckboxGroup, { value: checkboxGroupValue, class: `${mergedClsPrefix}-data-table-filter-menu__group`, onUpdateValue: handleChange }, {
                default: () => this.options.map((option) => {
                  return h(NCheckbox, { key: option.value, theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, value: option.value }, { default: () => option.label });
                })
              }) : h(NRadioGroup, { name: this.radioGroupName, class: `${mergedClsPrefix}-data-table-filter-menu__group`, value: this.radioGroupValue, onUpdateValue: this.handleChange }, {
                default: () => this.options.map((option) => h(NRadio, { key: option.value, value: option.value, theme: mergedTheme.peers.Radio, themeOverrides: mergedTheme.peerOverrides.Radio }, { default: () => option.label }))
              });
            }
          }),
          h(
            "div",
            { class: `${mergedClsPrefix}-data-table-filter-menu__action` },
            h(NButton, { size: "tiny", theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.handleClearClick }, { default: () => locale2.clear }),
            h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, type: "primary", size: "tiny", onClick: this.handleConfirmClick }, { default: () => locale2.confirm })
          )
        );
      }
    });
    function createFilterState(currentFilterState, columnKey, mergedFilterValue) {
      const nextFilterState = Object.assign({}, currentFilterState);
      nextFilterState[columnKey] = mergedFilterValue;
      return nextFilterState;
    }
    const FilterButton = defineComponent({
      name: "DataTableFilterButton",
      props: {
        column: {
          type: Object,
          required: true
        },
        options: {
          type: Array,
          default: () => []
        }
      },
      setup(props) {
        const { mergedComponentPropsRef } = useConfig();
        const {
          mergedThemeRef,
          mergedClsPrefixRef,
          mergedFilterStateRef,
          filterMenuCssVarsRef,
          paginationBehaviorOnFilterRef,
          doUpdatePage,
          doUpdateFilters
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        const showPopoverRef = ref(false);
        const filterStateRef = mergedFilterStateRef;
        const filterMultipleRef = computed(() => {
          return props.column.filterMultiple !== false;
        });
        const mergedFilterValueRef = computed(() => {
          const filterValue = filterStateRef.value[props.column.key];
          if (filterValue === void 0) {
            const { value: multiple } = filterMultipleRef;
            if (multiple)
              return [];
            else
              return null;
          }
          return filterValue;
        });
        const activeRef = computed(() => {
          const { value: filterValue } = mergedFilterValueRef;
          if (Array.isArray(filterValue)) {
            return filterValue.length > 0;
          }
          return filterValue !== null;
        });
        const mergedRenderFilterRef = computed(() => {
          var _a, _b;
          return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderFilter) || props.column.renderFilter;
        });
        function handleFilterChange(mergedFilterValue) {
          const nextFilterState = createFilterState(filterStateRef.value, props.column.key, mergedFilterValue);
          doUpdateFilters(nextFilterState, props.column);
          if (paginationBehaviorOnFilterRef.value === "first") {
            doUpdatePage(1);
          }
        }
        function handleFilterMenuCancel() {
          showPopoverRef.value = false;
        }
        function handleFilterMenuConfirm() {
          showPopoverRef.value = false;
        }
        return {
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          active: activeRef,
          showPopover: showPopoverRef,
          mergedRenderFilter: mergedRenderFilterRef,
          filterMultiple: filterMultipleRef,
          mergedFilterValue: mergedFilterValueRef,
          filterMenuCssVars: filterMenuCssVarsRef,
          handleFilterChange,
          handleFilterMenuConfirm,
          handleFilterMenuCancel
        };
      },
      render() {
        const { mergedTheme, mergedClsPrefix, handleFilterMenuCancel } = this;
        return h(NPopover, { show: this.showPopover, onUpdateShow: (v) => this.showPopover = v, trigger: "click", theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, placement: "bottom", style: { padding: 0 } }, {
          trigger: () => {
            const { mergedRenderFilter } = this;
            if (mergedRenderFilter) {
              return h(RenderFilter, { "data-data-table-filter": true, render: mergedRenderFilter, active: this.active, show: this.showPopover });
            }
            const { renderFilterIcon } = this.column;
            return h("div", { "data-data-table-filter": true, class: [
              `${mergedClsPrefix}-data-table-filter`,
              {
                [`${mergedClsPrefix}-data-table-filter--active`]: this.active,
                [`${mergedClsPrefix}-data-table-filter--show`]: this.showPopover
              }
            ] }, renderFilterIcon ? renderFilterIcon({
              active: this.active,
              show: this.showPopover
            }) : h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(FilterIcon, null) }));
          },
          default: () => {
            const { renderFilterMenu } = this.column;
            return renderFilterMenu ? renderFilterMenu({ hide: handleFilterMenuCancel }) : h(NDataTableFilterMenu, { style: this.filterMenuCssVars, radioGroupName: String(this.column.key), multiple: this.filterMultiple, value: this.mergedFilterValue, options: this.options, column: this.column, onChange: this.handleFilterChange, onClear: this.handleFilterMenuCancel, onConfirm: this.handleFilterMenuConfirm });
          }
        });
      }
    });
    const ResizeButton = defineComponent({
      name: "ColumnResizeButton",
      props: {
        onResizeStart: Function,
        onResize: Function,
        onResizeEnd: Function
      },
      setup(props) {
        const { mergedClsPrefixRef } = inject(dataTableInjectionKey);
        const activeRef = ref(false);
        let startX = 0;
        function getMouseX(e) {
          return e.clientX;
        }
        function handleMousedown(e) {
          var _a;
          const alreadyStarted = activeRef.value;
          startX = getMouseX(e);
          activeRef.value = true;
          if (!alreadyStarted) {
            on("mousemove", window, handleMousemove);
            on("mouseup", window, handleMouseup);
            (_a = props.onResizeStart) === null || _a === void 0 ? void 0 : _a.call(props);
          }
        }
        function handleMousemove(e) {
          var _a;
          (_a = props.onResize) === null || _a === void 0 ? void 0 : _a.call(props, getMouseX(e) - startX);
        }
        function handleMouseup() {
          var _a;
          activeRef.value = false;
          (_a = props.onResizeEnd) === null || _a === void 0 ? void 0 : _a.call(props);
          off("mousemove", window, handleMousemove);
          off("mouseup", window, handleMouseup);
        }
        onBeforeUnmount(() => {
          off("mousemove", window, handleMousemove);
          off("mouseup", window, handleMouseup);
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          active: activeRef,
          handleMousedown
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return h("span", { "data-data-table-resizable": true, class: [
          `${mergedClsPrefix}-data-table-resize-button`,
          this.active && `${mergedClsPrefix}-data-table-resize-button--active`
        ], onMousedown: this.handleMousedown });
      }
    });
    const NDropdownDivider = defineComponent({
      name: "DropdownDivider",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      render() {
        return h("div", { class: `${this.clsPrefix}-dropdown-divider` });
      }
    });
    const self$4 = (vars) => {
      const { textColorBase, opacity1, opacity2, opacity3, opacity4, opacity5 } = vars;
      return {
        color: textColorBase,
        opacity1Depth: opacity1,
        opacity2Depth: opacity2,
        opacity3Depth: opacity3,
        opacity4Depth: opacity4,
        opacity5Depth: opacity5
      };
    };
    const iconLight = {
      name: "Icon",
      common: commonLight,
      self: self$4
    };
    const iconLight$1 = iconLight;
    const style$6 = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM("color-transition", {
      transition: "color .3s var(--n-bezier)"
    }), cM("depth", {
      color: "var(--n-color)"
    }, [c$1("svg", {
      opacity: "var(--n-opacity)",
      transition: "opacity .3s var(--n-bezier)"
    })]), c$1("svg", {
      height: "1em",
      width: "1em"
    })]);
    const iconProps = Object.assign(Object.assign({}, useTheme.props), { depth: [String, Number], size: [Number, String], color: String, component: Object });
    const NIcon = defineComponent({
      _n_icon__: true,
      name: "Icon",
      inheritAttrs: false,
      props: iconProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Icon", "-icon", style$6, iconLight$1, props, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { depth } = props;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
          if (depth !== void 0) {
            const { color, [`opacity${depth}Depth`]: opacity } = self2;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color": color,
              "--n-opacity": opacity
            };
          }
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-color": "",
            "--n-opacity": ""
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedStyle: computed(() => {
            const { size: size2, color } = props;
            return {
              fontSize: formatLength(size2),
              color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        var _a;
        const { $parent, depth, mergedClsPrefix, component, onRender, themeClass } = this;
        if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
          warn$2("icon", "don't wrap `n-icon` inside `n-icon`");
        }
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h("i", mergeProps(this.$attrs, {
          role: "img",
          class: [
            `${mergedClsPrefix}-icon`,
            themeClass,
            {
              [`${mergedClsPrefix}-icon--depth`]: depth,
              [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
            }
          ],
          style: [this.cssVars, this.mergedStyle]
        }), component ? h(component) : this.$slots);
      }
    });
    const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
    const dropdownInjectionKey = createInjectionKey("n-dropdown");
    const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
    function isSubmenuNode(rawNode, childrenField) {
      return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
    }
    function isGroupNode(rawNode) {
      return rawNode.type === "group";
    }
    function isDividerNode(rawNode) {
      return rawNode.type === "divider";
    }
    function isRenderNode(rawNode) {
      return rawNode.type === "render";
    }
    const NDropdownOption = defineComponent({
      name: "DropdownOption",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        },
        parentKey: {
          type: [String, Number],
          default: null
        },
        placement: {
          type: String,
          default: "right-start"
        },
        props: Object,
        scrollable: Boolean
      },
      setup(props) {
        const NDropdown2 = inject(dropdownInjectionKey);
        const { hoverKeyRef, keyboardKeyRef, lastToggledSubmenuKeyRef, pendingKeyPathRef, activeKeyPathRef, animatedRef, mergedShowRef, renderLabelRef, renderIconRef, labelFieldRef, childrenFieldRef, renderOptionRef, nodePropsRef, menuPropsRef } = NDropdown2;
        const NDropdownOption2 = inject(dropdownOptionInjectionKey, null);
        const NDropdownMenu2 = inject(dropdownMenuInjectionKey);
        const NPopoverBody2 = inject(popoverBodyInjectionKey);
        const rawNodeRef = computed(() => props.tmNode.rawNode);
        const hasSubmenuRef = computed(() => {
          const { value: childrenField } = childrenFieldRef;
          return isSubmenuNode(props.tmNode.rawNode, childrenField);
        });
        const mergedDisabledRef = computed(() => {
          const { disabled } = props.tmNode;
          return disabled;
        });
        const showSubmenuRef = computed(() => {
          if (!hasSubmenuRef.value)
            return false;
          const { key, disabled } = props.tmNode;
          if (disabled)
            return false;
          const { value: hoverKey } = hoverKeyRef;
          const { value: keyboardKey } = keyboardKeyRef;
          const { value: lastToggledSubmenuKey } = lastToggledSubmenuKeyRef;
          const { value: pendingKeyPath } = pendingKeyPathRef;
          if (hoverKey !== null)
            return pendingKeyPath.includes(key);
          if (keyboardKey !== null) {
            return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
          }
          if (lastToggledSubmenuKey !== null)
            return pendingKeyPath.includes(key);
          return false;
        });
        const shouldDelayRef = computed(() => {
          return keyboardKeyRef.value === null && !animatedRef.value;
        });
        const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
        const parentEnteringSubmenuRef = computed(() => {
          return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
        });
        const enteringSubmenuRef = ref(false);
        provide(dropdownOptionInjectionKey, {
          enteringSubmenuRef
        });
        function handleSubmenuBeforeEnter() {
          enteringSubmenuRef.value = true;
        }
        function handleSubmenuAfterEnter() {
          enteringSubmenuRef.value = false;
        }
        function handleMouseEnter() {
          const { parentKey, tmNode } = props;
          if (tmNode.disabled)
            return;
          if (!mergedShowRef.value)
            return;
          lastToggledSubmenuKeyRef.value = parentKey;
          keyboardKeyRef.value = null;
          hoverKeyRef.value = tmNode.key;
        }
        function handleMouseMove() {
          const { tmNode } = props;
          if (tmNode.disabled)
            return;
          if (!mergedShowRef.value)
            return;
          if (hoverKeyRef.value === tmNode.key)
            return;
          handleMouseEnter();
        }
        function handleMouseLeave(e) {
          if (props.tmNode.disabled)
            return;
          if (!mergedShowRef.value)
            return;
          const { relatedTarget } = e;
          if (relatedTarget && !happensIn({ target: relatedTarget }, "dropdownOption") && !happensIn({ target: relatedTarget }, "scrollbarRail")) {
            hoverKeyRef.value = null;
          }
        }
        function handleClick() {
          const { value: hasSubmenu } = hasSubmenuRef;
          const { tmNode } = props;
          if (!mergedShowRef.value)
            return;
          if (!hasSubmenu && !tmNode.disabled) {
            NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
            NDropdown2.doUpdateShow(false);
          }
        }
        return {
          labelField: labelFieldRef,
          renderLabel: renderLabelRef,
          renderIcon: renderIconRef,
          siblingHasIcon: NDropdownMenu2.showIconRef,
          siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
          menuProps: menuPropsRef,
          popoverBody: NPopoverBody2,
          animated: animatedRef,
          mergedShowSubmenu: computed(() => {
            return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
          }),
          rawNode: rawNodeRef,
          hasSubmenu: hasSubmenuRef,
          pending: useMemo(() => {
            const { value: pendingKeyPath } = pendingKeyPathRef;
            const { key } = props.tmNode;
            return pendingKeyPath.includes(key);
          }),
          childActive: useMemo(() => {
            const { value: activeKeyPath } = activeKeyPathRef;
            const { key } = props.tmNode;
            const index = activeKeyPath.findIndex((k) => key === k);
            if (index === -1)
              return false;
            return index < activeKeyPath.length - 1;
          }),
          active: useMemo(() => {
            const { value: activeKeyPath } = activeKeyPathRef;
            const { key } = props.tmNode;
            const index = activeKeyPath.findIndex((k) => key === k);
            if (index === -1)
              return false;
            return index === activeKeyPath.length - 1;
          }),
          mergedDisabled: mergedDisabledRef,
          renderOption: renderOptionRef,
          nodeProps: nodePropsRef,
          handleClick,
          handleMouseMove,
          handleMouseEnter,
          handleMouseLeave,
          handleSubmenuBeforeEnter,
          handleSubmenuAfterEnter
        };
      },
      render() {
        var _a, _b;
        const { animated, rawNode, mergedShowSubmenu, clsPrefix, siblingHasIcon, siblingHasSubmenu, renderLabel, renderIcon, renderOption, nodeProps, props, scrollable } = this;
        let submenuVNode = null;
        if (mergedShowSubmenu) {
          const submenuNodeProps = (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.call(
            this,
            rawNode,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            rawNode.children
          );
          submenuVNode = h(NDropdownMenu, Object.assign({}, submenuNodeProps, { clsPrefix, scrollable: this.scrollable, tmNodes: this.tmNode.children, parentKey: this.tmNode.key }));
        }
        const builtinProps = {
          class: [
            `${clsPrefix}-dropdown-option-body`,
            this.pending && `${clsPrefix}-dropdown-option-body--pending`,
            this.active && `${clsPrefix}-dropdown-option-body--active`,
            this.childActive && `${clsPrefix}-dropdown-option-body--child-active`,
            this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`
          ],
          onMousemove: this.handleMouseMove,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onClick: this.handleClick
        };
        const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
        const node = h(
          "div",
          Object.assign({ class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class], "data-dropdown-option": true }, optionNodeProps),
          h("div", mergeProps(builtinProps, props), [
            h("div", { class: [
              `${clsPrefix}-dropdown-option-body__prefix`,
              siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
            ] }, [renderIcon ? renderIcon(rawNode) : render$1(rawNode.icon)]),
            h("div", { "data-dropdown-option": true, class: `${clsPrefix}-dropdown-option-body__label` }, renderLabel ? renderLabel(rawNode) : render$1((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)),
            h("div", { "data-dropdown-option": true, class: [
              `${clsPrefix}-dropdown-option-body__suffix`,
              siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
            ] }, this.hasSubmenu ? h(NIcon, null, {
              default: () => h(ChevronRightIcon, null)
            }) : null)
          ]),
          this.hasSubmenu ? h(VBinder, null, {
            default: () => [
              h(VTarget, null, {
                default: () => h(
                  "div",
                  { class: `${clsPrefix}-dropdown-offset-container` },
                  h(VFollower, { show: this.mergedShowSubmenu, placement: this.placement, to: scrollable ? this.popoverBody || void 0 : void 0, teleportDisabled: !scrollable }, {
                    default: () => {
                      return h("div", { class: `${clsPrefix}-dropdown-menu-wrapper` }, animated ? h(Transition, { onBeforeEnter: this.handleSubmenuBeforeEnter, onAfterEnter: this.handleSubmenuAfterEnter, name: "fade-in-scale-up-transition", appear: true }, {
                        default: () => submenuVNode
                      }) : submenuVNode);
                    }
                  })
                )
              })
            ]
          }) : null
        );
        if (renderOption) {
          return renderOption({ node, option: rawNode });
        }
        return node;
      }
    });
    const NDropdownGroupHeader = defineComponent({
      name: "DropdownGroupHeader",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup() {
        const {
          showIconRef,
          hasSubmenuRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dropdownMenuInjectionKey);
        const { renderLabelRef, labelFieldRef, nodePropsRef, renderOptionRef } = (
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          inject(dropdownInjectionKey)
        );
        return {
          labelField: labelFieldRef,
          showIcon: showIconRef,
          hasSubmenu: hasSubmenuRef,
          renderLabel: renderLabelRef,
          nodeProps: nodePropsRef,
          renderOption: renderOptionRef
        };
      },
      render() {
        var _a;
        const { clsPrefix, hasSubmenu, showIcon, nodeProps, renderLabel, renderOption } = this;
        const { rawNode } = this.tmNode;
        const node = h(
          "div",
          Object.assign({ class: `${clsPrefix}-dropdown-option` }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)),
          h(
            "div",
            { class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group` },
            h("div", { "data-dropdown-option": true, class: [
              `${clsPrefix}-dropdown-option-body__prefix`,
              showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
            ] }, render$1(rawNode.icon)),
            h("div", { class: `${clsPrefix}-dropdown-option-body__label`, "data-dropdown-option": true }, renderLabel ? renderLabel(rawNode) : render$1((_a = rawNode.title) !== null && _a !== void 0 ? _a : rawNode[this.labelField])),
            h("div", { class: [
              `${clsPrefix}-dropdown-option-body__suffix`,
              hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
            ], "data-dropdown-option": true })
          )
        );
        if (renderOption) {
          return renderOption({ node, option: rawNode });
        }
        return node;
      }
    });
    const NDropdownGroup = defineComponent({
      name: "NDropdownGroup",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        },
        parentKey: {
          type: [String, Number],
          default: null
        }
      },
      render() {
        const { tmNode, parentKey, clsPrefix } = this;
        const { children } = tmNode;
        return h(
          Fragment,
          null,
          h(NDropdownGroupHeader, { clsPrefix, tmNode, key: tmNode.key }),
          children === null || children === void 0 ? void 0 : children.map((child) => {
            const { rawNode } = child;
            if (rawNode.show === false)
              return null;
            if (isDividerNode(rawNode)) {
              return h(NDropdownDivider, {
                clsPrefix,
                key: child.key
              });
            }
            if (child.isGroup) {
              warn$2("dropdown", "`group` node is not allowed to be put in `group` node.");
              return null;
            }
            return h(NDropdownOption, { clsPrefix, tmNode: child, parentKey, key: child.key });
          })
        );
      }
    });
    const NDropdownRenderOption = defineComponent({
      name: "DropdownRenderOption",
      props: {
        tmNode: {
          type: Object,
          required: true
        }
      },
      render() {
        const { rawNode: { render: render2, props } } = this.tmNode;
        return h("div", props, [render2 === null || render2 === void 0 ? void 0 : render2()]);
      }
    });
    const NDropdownMenu = defineComponent({
      name: "DropdownMenu",
      props: {
        scrollable: Boolean,
        showArrow: Boolean,
        arrowStyle: [String, Object],
        clsPrefix: {
          type: String,
          required: true
        },
        tmNodes: {
          type: Array,
          default: () => []
        },
        parentKey: {
          type: [String, Number],
          default: null
        }
      },
      setup(props) {
        const { renderIconRef, childrenFieldRef } = inject(dropdownInjectionKey);
        provide(dropdownMenuInjectionKey, {
          showIconRef: computed(() => {
            const renderIcon = renderIconRef.value;
            return props.tmNodes.some((tmNode) => {
              var _a;
              if (tmNode.isGroup) {
                return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({ rawNode: rawChild }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
              }
              const { rawNode } = tmNode;
              return renderIcon ? renderIcon(rawNode) : rawNode.icon;
            });
          }),
          hasSubmenuRef: computed(() => {
            const { value: childrenField } = childrenFieldRef;
            return props.tmNodes.some((tmNode) => {
              var _a;
              if (tmNode.isGroup) {
                return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({ rawNode: rawChild }) => isSubmenuNode(rawChild, childrenField));
              }
              const { rawNode } = tmNode;
              return isSubmenuNode(rawNode, childrenField);
            });
          })
        });
        const bodyRef = ref(null);
        provide(modalBodyInjectionKey, null);
        provide(drawerBodyInjectionKey, null);
        provide(popoverBodyInjectionKey, bodyRef);
        return {
          bodyRef
        };
      },
      render() {
        const { parentKey, clsPrefix, scrollable } = this;
        const menuOptionsNode = this.tmNodes.map((tmNode) => {
          const { rawNode } = tmNode;
          if (rawNode.show === false)
            return null;
          if (isRenderNode(rawNode)) {
            return h(NDropdownRenderOption, { tmNode, key: tmNode.key });
          }
          if (isDividerNode(rawNode)) {
            return h(NDropdownDivider, { clsPrefix, key: tmNode.key });
          }
          if (isGroupNode(rawNode)) {
            return h(NDropdownGroup, { clsPrefix, tmNode, parentKey, key: tmNode.key });
          }
          return h(NDropdownOption, { clsPrefix, tmNode, parentKey, key: tmNode.key, props: rawNode.props, scrollable });
        });
        return h(
          "div",
          { class: [
            `${clsPrefix}-dropdown-menu`,
            scrollable && `${clsPrefix}-dropdown-menu--scrollable`
          ], ref: "bodyRef" },
          scrollable ? h(XScrollbar, { contentClass: `${clsPrefix}-dropdown-menu__content` }, {
            default: () => menuOptionsNode
          }) : menuOptionsNode,
          this.showArrow ? renderArrow({
            clsPrefix,
            arrowStyle: this.arrowStyle
          }) : null
        );
      }
    });
    const style$5 = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
    const dropdownBaseProps = {
      animated: {
        type: Boolean,
        default: true
      },
      keyboard: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        default: "medium"
      },
      inverted: Boolean,
      placement: {
        type: String,
        default: "bottom"
      },
      onSelect: [Function, Array],
      options: {
        type: Array,
        default: () => []
      },
      menuProps: Function,
      showArrow: Boolean,
      renderLabel: Function,
      renderIcon: Function,
      renderOption: Function,
      nodeProps: Function,
      labelField: {
        type: String,
        default: "label"
      },
      keyField: {
        type: String,
        default: "key"
      },
      childrenField: {
        type: String,
        default: "children"
      },
      // for menu, not documented
      value: [String, Number]
    };
    const popoverPropKeys = Object.keys(popoverBaseProps);
    const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
    const NDropdown = defineComponent({
      name: "Dropdown",
      inheritAttrs: false,
      props: dropdownProps,
      setup(props) {
        const uncontrolledShowRef = ref(false);
        const mergedShowRef = useMergedState(toRef(props, "show"), uncontrolledShowRef);
        const treemateRef = computed(() => {
          const { keyField, childrenField } = props;
          return createTreeMate(props.options, {
            getKey(node) {
              return node[keyField];
            },
            getDisabled(node) {
              return node.disabled === true;
            },
            getIgnored(node) {
              return node.type === "divider" || node.type === "render";
            },
            getChildren(node) {
              return node[childrenField];
            }
          });
        });
        const tmNodesRef = computed(() => {
          return treemateRef.value.treeNodes;
        });
        const hoverKeyRef = ref(null);
        const keyboardKeyRef = ref(null);
        const lastToggledSubmenuKeyRef = ref(null);
        const pendingKeyRef = computed(() => {
          var _a, _b, _c;
          return (_c = (_b = (_a = hoverKeyRef.value) !== null && _a !== void 0 ? _a : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
        });
        const pendingKeyPathRef = computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
        const activeKeyPathRef = computed(() => treemateRef.value.getPath(props.value).keyPath);
        const keyboardEnabledRef = useMemo(() => {
          return props.keyboard && mergedShowRef.value;
        });
        useKeyboard({
          keydown: {
            ArrowUp: {
              prevent: true,
              handler: handleKeydownUp
            },
            ArrowRight: {
              prevent: true,
              handler: handleKeydownRight
            },
            ArrowDown: {
              prevent: true,
              handler: handleKeydownDown
            },
            ArrowLeft: {
              prevent: true,
              handler: handleKeydownLeft
            },
            Enter: {
              prevent: true,
              handler: handleKeydownEnter
            },
            Escape: handleKeydownEsc
          }
        }, keyboardEnabledRef);
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Dropdown", "-dropdown", style$5, dropdownLight$1, props, mergedClsPrefixRef);
        provide(dropdownInjectionKey, {
          labelFieldRef: toRef(props, "labelField"),
          childrenFieldRef: toRef(props, "childrenField"),
          renderLabelRef: toRef(props, "renderLabel"),
          renderIconRef: toRef(props, "renderIcon"),
          hoverKeyRef,
          keyboardKeyRef,
          lastToggledSubmenuKeyRef,
          pendingKeyPathRef,
          activeKeyPathRef,
          animatedRef: toRef(props, "animated"),
          mergedShowRef,
          nodePropsRef: toRef(props, "nodeProps"),
          renderOptionRef: toRef(props, "renderOption"),
          menuPropsRef: toRef(props, "menuProps"),
          doSelect,
          doUpdateShow
        });
        watch(mergedShowRef, (value) => {
          if (!props.animated && !value) {
            clearPendingState();
          }
        });
        function doSelect(key, node) {
          const { onSelect } = props;
          if (onSelect)
            call(onSelect, key, node);
        }
        function doUpdateShow(value) {
          const { "onUpdate:show": _onUpdateShow, onUpdateShow } = props;
          if (_onUpdateShow)
            call(_onUpdateShow, value);
          if (onUpdateShow)
            call(onUpdateShow, value);
          uncontrolledShowRef.value = value;
        }
        function clearPendingState() {
          hoverKeyRef.value = null;
          keyboardKeyRef.value = null;
          lastToggledSubmenuKeyRef.value = null;
        }
        function handleKeydownEsc() {
          doUpdateShow(false);
        }
        function handleKeydownLeft() {
          handleKeydown("left");
        }
        function handleKeydownRight() {
          handleKeydown("right");
        }
        function handleKeydownUp() {
          handleKeydown("up");
        }
        function handleKeydownDown() {
          handleKeydown("down");
        }
        function handleKeydownEnter() {
          const pendingNode = getPendingNode();
          if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
            doSelect(pendingNode.key, pendingNode.rawNode);
            doUpdateShow(false);
          }
        }
        function getPendingNode() {
          var _a;
          const { value: treeMate } = treemateRef;
          const { value: pendingKey } = pendingKeyRef;
          if (!treeMate || pendingKey === null)
            return null;
          return (_a = treeMate.getNode(pendingKey)) !== null && _a !== void 0 ? _a : null;
        }
        function handleKeydown(direction) {
          const { value: pendingKey } = pendingKeyRef;
          const { value: { getFirstAvailableNode: getFirstAvailableNode2 } } = treemateRef;
          let nextKeyboardKey = null;
          if (pendingKey === null) {
            const firstNode = getFirstAvailableNode2();
            if (firstNode !== null) {
              nextKeyboardKey = firstNode.key;
            }
          } else {
            const currentNode = getPendingNode();
            if (currentNode) {
              let nextNode;
              switch (direction) {
                case "down":
                  nextNode = currentNode.getNext();
                  break;
                case "up":
                  nextNode = currentNode.getPrev();
                  break;
                case "right":
                  nextNode = currentNode.getChild();
                  break;
                case "left":
                  nextNode = currentNode.getParent();
                  break;
              }
              if (nextNode)
                nextKeyboardKey = nextNode.key;
            }
          }
          if (nextKeyboardKey !== null) {
            hoverKeyRef.value = null;
            keyboardKeyRef.value = nextKeyboardKey;
          }
        }
        const cssVarsRef = computed(() => {
          const { size: size2, inverted } = props;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
          const { padding, dividerColor, borderRadius, optionOpacityDisabled, [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth, [createKey("optionSuffixWidth", size2)]: optionSuffixWidth, [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth, [createKey("optionPrefixWidth", size2)]: optionPrefixWidth, [createKey("fontSize", size2)]: fontSize2, [createKey("optionHeight", size2)]: optionHeight, [createKey("optionIconSize", size2)]: optionIconSize } = self2;
          const vars = {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-font-size": fontSize2,
            "--n-padding": padding,
            "--n-border-radius": borderRadius,
            "--n-option-height": optionHeight,
            "--n-option-prefix-width": optionPrefixWidth,
            "--n-option-icon-prefix-width": optionIconPrefixWidth,
            "--n-option-suffix-width": optionSuffixWidth,
            "--n-option-icon-suffix-width": optionIconSuffixWidth,
            "--n-option-icon-size": optionIconSize,
            "--n-divider-color": dividerColor,
            "--n-option-opacity-disabled": optionOpacityDisabled
          };
          if (inverted) {
            vars["--n-color"] = self2.colorInverted;
            vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
            vars["--n-option-color-active"] = self2.optionColorActiveInverted;
            vars["--n-option-text-color"] = self2.optionTextColorInverted;
            vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
            vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
            vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
            vars["--n-prefix-color"] = self2.prefixColorInverted;
            vars["--n-suffix-color"] = self2.suffixColorInverted;
            vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
          } else {
            vars["--n-color"] = self2.color;
            vars["--n-option-color-hover"] = self2.optionColorHover;
            vars["--n-option-color-active"] = self2.optionColorActive;
            vars["--n-option-text-color"] = self2.optionTextColor;
            vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
            vars["--n-option-text-color-active"] = self2.optionTextColorActive;
            vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
            vars["--n-prefix-color"] = self2.prefixColor;
            vars["--n-suffix-color"] = self2.suffixColor;
            vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
          }
          return vars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: themeRef,
          // data
          tmNodes: tmNodesRef,
          // show
          mergedShow: mergedShowRef,
          // methods
          handleAfterLeave: () => {
            if (!props.animated)
              return;
            clearPendingState();
          },
          doUpdateShow,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
          var _a;
          const { mergedClsPrefix, menuProps } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const menuNodeProps = (menuProps === null || menuProps === void 0 ? void 0 : menuProps(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
          const dropdownProps2 = {
            ref: createRefSetter(ref2),
            class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
            clsPrefix: mergedClsPrefix,
            tmNodes: this.tmNodes,
            style: [style2, this.cssVars],
            showArrow: this.showArrow,
            arrowStyle: this.arrowStyle,
            scrollable: this.scrollable,
            onMouseenter,
            onMouseleave
          };
          return h(NDropdownMenu, mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
        };
        const { mergedTheme } = this;
        const popoverProps2 = {
          show: this.mergedShow,
          theme: mergedTheme.peers.Popover,
          themeOverrides: mergedTheme.peerOverrides.Popover,
          internalOnAfterLeave: this.handleAfterLeave,
          internalRenderBody: renderPopoverBody,
          onUpdateShow: this.doUpdateShow,
          "onUpdate:show": void 0
        };
        return h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
          trigger: () => {
            var _a, _b;
            return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
          }
        });
      }
    });
    const allKey = "_n_all__";
    const noneKey = "_n_none__";
    function createSelectHandler(options, rawPaginatedDataRef, doCheckAll, doUncheckAll) {
      if (!options)
        return () => {
        };
      return (key) => {
        for (const option of options) {
          switch (key) {
            case allKey:
              doCheckAll(true);
              return;
            case noneKey:
              doUncheckAll(true);
              return;
            default:
              if (typeof option === "object" && option.key === key) {
                option.onSelect(rawPaginatedDataRef.value);
                return;
              }
          }
        }
      };
    }
    function createDropdownOptions(options, localeRef) {
      if (!options)
        return [];
      return options.map((option) => {
        switch (option) {
          case "all":
            return {
              label: localeRef.checkTableAll,
              key: allKey
            };
          case "none":
            return {
              label: localeRef.uncheckTableAll,
              key: noneKey
            };
          default:
            return option;
        }
      });
    }
    const SelectionMenu = defineComponent({
      name: "DataTableSelectionMenu",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const {
          props: dataTableProps2,
          localeRef,
          checkOptionsRef,
          rawPaginatedDataRef,
          doCheckAll,
          doUncheckAll
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        const handleSelectRef = computed(() => createSelectHandler(checkOptionsRef.value, rawPaginatedDataRef, doCheckAll, doUncheckAll));
        const optionsRef = computed(() => createDropdownOptions(checkOptionsRef.value, localeRef.value));
        return () => {
          var _a, _b, _c, _d;
          const { clsPrefix } = props;
          return h(NDropdown, { theme: (_b = (_a = dataTableProps2.theme) === null || _a === void 0 ? void 0 : _a.peers) === null || _b === void 0 ? void 0 : _b.Dropdown, themeOverrides: (_d = (_c = dataTableProps2.themeOverrides) === null || _c === void 0 ? void 0 : _c.peers) === null || _d === void 0 ? void 0 : _d.Dropdown, options: optionsRef.value, onSelect: handleSelectRef.value }, {
            default: () => h(NBaseIcon, { clsPrefix, class: `${clsPrefix}-data-table-check-extra` }, {
              default: () => h(ChevronDownIcon, null)
            })
          });
        };
      }
    });
    function renderTitle(column) {
      return typeof column.title === "function" ? column.title(column) : column.title;
    }
    const TableHeader = defineComponent({
      name: "DataTableHeader",
      props: {
        discrete: {
          type: Boolean,
          default: true
        }
      },
      setup() {
        const {
          mergedClsPrefixRef,
          scrollXRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          mergedCurrentPageRef,
          allRowsCheckedRef,
          someRowsCheckedRef,
          rowsRef,
          colsRef,
          mergedThemeRef,
          checkOptionsRef,
          mergedSortStateRef,
          componentId,
          scrollPartRef,
          mergedTableLayoutRef,
          headerCheckboxDisabledRef,
          onUnstableColumnResize,
          doUpdateResizableWidth,
          handleTableHeaderScroll,
          deriveNextSorter,
          doUncheckAll,
          doCheckAll
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        const cellElsRef = ref({});
        function getCellActualWidth(key) {
          const element = cellElsRef.value[key];
          return element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width;
        }
        function handleCheckboxUpdateChecked() {
          if (allRowsCheckedRef.value) {
            doUncheckAll();
          } else {
            doCheckAll();
          }
        }
        function handleColHeaderClick(e, column) {
          if (happensIn(e, "dataTableFilter") || happensIn(e, "dataTableResizable")) {
            return;
          }
          if (!isColumnSortable(column))
            return;
          const activeSorter = mergedSortStateRef.value.find((state) => state.columnKey === column.key) || null;
          const nextSorter = createNextSorter(column, activeSorter);
          deriveNextSorter(nextSorter);
        }
        function handleMouseenter() {
          scrollPartRef.value = "head";
        }
        function handleMouseleave() {
          scrollPartRef.value = "body";
        }
        const resizeStartWidthMap = /* @__PURE__ */ new Map();
        function handleColumnResizeStart(column) {
          resizeStartWidthMap.set(column.key, getCellActualWidth(column.key));
        }
        function handleColumnResize(column, displacementX) {
          const startWidth = resizeStartWidthMap.get(column.key);
          if (startWidth === void 0) {
            return;
          }
          const widthAfterResize = startWidth + displacementX;
          const limitWidth = clampValueFollowCSSRules(widthAfterResize, column.minWidth, column.maxWidth);
          onUnstableColumnResize(widthAfterResize, limitWidth, column, getCellActualWidth);
          doUpdateResizableWidth(column, limitWidth);
        }
        return {
          cellElsRef,
          componentId,
          mergedSortState: mergedSortStateRef,
          mergedClsPrefix: mergedClsPrefixRef,
          scrollX: scrollXRef,
          fixedColumnLeftMap: fixedColumnLeftMapRef,
          fixedColumnRightMap: fixedColumnRightMapRef,
          currentPage: mergedCurrentPageRef,
          allRowsChecked: allRowsCheckedRef,
          someRowsChecked: someRowsCheckedRef,
          rows: rowsRef,
          cols: colsRef,
          mergedTheme: mergedThemeRef,
          checkOptions: checkOptionsRef,
          mergedTableLayout: mergedTableLayoutRef,
          headerCheckboxDisabled: headerCheckboxDisabledRef,
          handleMouseenter,
          handleMouseleave,
          handleCheckboxUpdateChecked,
          handleColHeaderClick,
          handleTableHeaderScroll,
          handleColumnResizeStart,
          handleColumnResize
        };
      },
      render() {
        const { cellElsRef, mergedClsPrefix, fixedColumnLeftMap, fixedColumnRightMap, currentPage, allRowsChecked, someRowsChecked, rows, cols, mergedTheme, checkOptions, componentId, discrete, mergedTableLayout, headerCheckboxDisabled, mergedSortState, handleColHeaderClick, handleCheckboxUpdateChecked, handleColumnResizeStart, handleColumnResize } = this;
        const theadVNode = h("thead", { class: `${mergedClsPrefix}-data-table-thead`, "data-n-id": componentId }, rows.map((row) => {
          return h("tr", { class: `${mergedClsPrefix}-data-table-tr` }, row.map(({ column, colSpan, rowSpan, isLast }) => {
            var _a, _b;
            const key = getColKey(column);
            const { ellipsis } = column;
            const createColumnVNode = () => {
              if (column.type === "selection") {
                return column.multiple !== false ? h(
                  Fragment,
                  null,
                  h(NCheckbox, { key: currentPage, privateInsideTable: true, checked: allRowsChecked, indeterminate: someRowsChecked, disabled: headerCheckboxDisabled, onUpdateChecked: handleCheckboxUpdateChecked }),
                  checkOptions ? h(SelectionMenu, { clsPrefix: mergedClsPrefix }) : null
                ) : null;
              }
              return h(
                Fragment,
                null,
                h(
                  "div",
                  { class: `${mergedClsPrefix}-data-table-th__title-wrapper` },
                  h("div", { class: `${mergedClsPrefix}-data-table-th__title` }, ellipsis === true || ellipsis && !ellipsis.tooltip ? h("div", { class: `${mergedClsPrefix}-data-table-th__ellipsis` }, renderTitle(column)) : ellipsis && typeof ellipsis === "object" ? h(NEllipsis, Object.assign({}, ellipsis, { theme: mergedTheme.peers.Ellipsis, themeOverrides: mergedTheme.peerOverrides.Ellipsis }), {
                    default: () => renderTitle(column)
                  }) : renderTitle(column)),
                  isColumnSortable(column) ? h(SortButton, { column }) : null
                ),
                isColumnFilterable(column) ? h(FilterButton, { column, options: column.filterOptions }) : null,
                isColumnResizable(column) ? h(ResizeButton, { onResizeStart: () => handleColumnResizeStart(column), onResize: (displacementX) => handleColumnResize(column, displacementX) }) : null
              );
            };
            const leftFixed = key in fixedColumnLeftMap;
            const rightFixed = key in fixedColumnRightMap;
            return h("th", { ref: (el) => cellElsRef[key] = el, key, style: {
              textAlign: column.align,
              left: pxfy((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start),
              right: pxfy((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.start)
            }, colspan: colSpan, rowspan: rowSpan, "data-col-key": key, class: [
              `${mergedClsPrefix}-data-table-th`,
              (leftFixed || rightFixed) && `${mergedClsPrefix}-data-table-th--fixed-${leftFixed ? "left" : "right"}`,
              {
                [`${mergedClsPrefix}-data-table-th--hover`]: isColumnSorting(column, mergedSortState),
                [`${mergedClsPrefix}-data-table-th--filterable`]: isColumnFilterable(column),
                [`${mergedClsPrefix}-data-table-th--sortable`]: isColumnSortable(column),
                [`${mergedClsPrefix}-data-table-th--selection`]: column.type === "selection",
                [`${mergedClsPrefix}-data-table-th--last`]: isLast
              },
              column.className
            ], onClick: column.type !== "selection" && column.type !== "expand" && !("children" in column) ? (e) => {
              handleColHeaderClick(e, column);
            } : void 0 }, createColumnVNode());
          }));
        }));
        if (!discrete) {
          return theadVNode;
        }
        const { handleTableHeaderScroll, handleMouseenter, handleMouseleave, scrollX } = this;
        return h(
          "div",
          { class: `${mergedClsPrefix}-data-table-base-table-header`, onScroll: handleTableHeaderScroll, onMouseenter: handleMouseenter, onMouseleave: handleMouseleave },
          h(
            "table",
            { ref: "body", class: `${mergedClsPrefix}-data-table-table`, style: {
              minWidth: formatLength(scrollX),
              tableLayout: mergedTableLayout
            } },
            h("colgroup", null, cols.map((col) => h("col", { key: col.key, style: col.style }))),
            theadVNode
          )
        );
      }
    });
    const Cell = defineComponent({
      name: "DataTableCell",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        row: {
          type: Object,
          required: true
        },
        index: {
          type: Number,
          required: true
        },
        column: {
          type: Object,
          required: true
        },
        isSummary: Boolean,
        mergedTheme: {
          type: Object,
          required: true
        },
        renderCell: Function
      },
      render() {
        const { isSummary, column, row, renderCell } = this;
        let cell;
        const { render: render2, key, ellipsis } = column;
        if (render2 && !isSummary) {
          cell = render2(row, this.index);
        } else {
          if (isSummary) {
            cell = row[key].value;
          } else {
            cell = renderCell ? renderCell(get(row, key), row, column) : get(row, key);
          }
        }
        if (ellipsis) {
          if (typeof ellipsis === "object") {
            const { mergedTheme } = this;
            return h(NEllipsis, Object.assign({}, ellipsis, { theme: mergedTheme.peers.Ellipsis, themeOverrides: mergedTheme.peerOverrides.Ellipsis }), { default: () => cell });
          } else {
            return h("span", { class: `${this.clsPrefix}-data-table-td__ellipsis` }, cell);
          }
        }
        return cell;
      }
    });
    const ExpandTrigger = defineComponent({
      name: "DataTableExpandTrigger",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        expanded: Boolean,
        loading: Boolean,
        onClick: {
          type: Function,
          required: true
        },
        renderExpandIcon: {
          type: Function
        }
      },
      render() {
        const { clsPrefix } = this;
        return h(
          "div",
          { class: [
            `${clsPrefix}-data-table-expand-trigger`,
            this.expanded && `${clsPrefix}-data-table-expand-trigger--expanded`
          ], onClick: this.onClick },
          h(NIconSwitchTransition, null, {
            default: () => {
              return this.loading ? h(NBaseLoading, { key: "loading", clsPrefix: this.clsPrefix, radius: 85, strokeWidth: 15, scale: 0.88 }) : this.renderExpandIcon ? this.renderExpandIcon() : h(NBaseIcon, { clsPrefix, key: "base-icon" }, {
                default: () => h(ChevronRightIcon, null)
              });
            }
          })
        );
      }
    });
    const RenderSafeCheckbox = defineComponent({
      name: "DataTableBodyCheckbox",
      props: {
        rowKey: {
          type: [String, Number],
          required: true
        },
        disabled: {
          type: Boolean,
          required: true
        },
        onUpdateChecked: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          mergedCheckedRowKeySetRef,
          mergedInderminateRowKeySetRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        return () => {
          const { rowKey } = props;
          return h(NCheckbox, { privateInsideTable: true, disabled: props.disabled, indeterminate: mergedInderminateRowKeySetRef.value.has(rowKey), checked: mergedCheckedRowKeySetRef.value.has(rowKey), onUpdateChecked: props.onUpdateChecked });
        };
      }
    });
    const RenderSafeRadio = defineComponent({
      name: "DataTableBodyRadio",
      props: {
        rowKey: {
          type: [String, Number],
          required: true
        },
        disabled: {
          type: Boolean,
          required: true
        },
        onUpdateChecked: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          mergedCheckedRowKeySetRef,
          componentId
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        return () => {
          const { rowKey } = props;
          return h(NRadio, { name: componentId, disabled: props.disabled, checked: mergedCheckedRowKeySetRef.value.has(rowKey), onUpdateChecked: props.onUpdateChecked });
        };
      }
    });
    function flatten(rowInfos, expandedRowKeys) {
      const fRows = [];
      function traverse2(rs, rootIndex) {
        rs.forEach((r) => {
          if (r.children && expandedRowKeys.has(r.key)) {
            fRows.push({
              tmNode: r,
              striped: false,
              key: r.key,
              index: rootIndex
            });
            traverse2(r.children, rootIndex);
          } else {
            fRows.push({
              key: r.key,
              tmNode: r,
              striped: false,
              index: rootIndex
            });
          }
        });
      }
      rowInfos.forEach((rowInfo) => {
        fRows.push(rowInfo);
        const { children } = rowInfo.tmNode;
        if (children && expandedRowKeys.has(rowInfo.key)) {
          traverse2(children, rowInfo.index);
        }
      });
      return fRows;
    }
    const VirtualListItemWrapper = defineComponent({
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        id: {
          type: String,
          required: true
        },
        cols: {
          type: Array,
          required: true
        },
        onMouseenter: Function,
        onMouseleave: Function
      },
      render() {
        const { clsPrefix, id, cols, onMouseenter, onMouseleave } = this;
        return h(
          "table",
          { style: { tableLayout: "fixed" }, class: `${clsPrefix}-data-table-table`, onMouseenter, onMouseleave },
          h("colgroup", null, cols.map((col) => h("col", { key: col.key, style: col.style }))),
          h("tbody", { "data-n-id": id, class: `${clsPrefix}-data-table-tbody` }, this.$slots)
        );
      }
    });
    const TableBody = defineComponent({
      name: "DataTableBody",
      props: {
        onResize: Function,
        showHeader: Boolean,
        flexHeight: Boolean,
        bodyStyle: Object
      },
      setup(props) {
        const {
          slots: dataTableSlots,
          bodyWidthRef,
          mergedExpandedRowKeysRef,
          mergedClsPrefixRef,
          mergedThemeRef,
          scrollXRef,
          colsRef,
          paginatedDataRef,
          rawPaginatedDataRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          mergedCurrentPageRef,
          rowClassNameRef,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          renderExpandRef,
          hoverKeyRef,
          summaryRef,
          mergedSortStateRef,
          virtualScrollRef,
          componentId,
          scrollPartRef,
          mergedTableLayoutRef,
          childTriggerColIndexRef,
          indentRef,
          rowPropsRef,
          maxHeightRef,
          stripedRef,
          loadingRef,
          onLoadRef,
          loadingKeySetRef,
          expandableRef,
          stickyExpandedRowsRef,
          renderExpandIconRef,
          summaryPlacementRef,
          treeMateRef,
          scrollbarPropsRef,
          setHeaderScrollLeft,
          doUpdateExpandedRowKeys,
          handleTableBodyScroll,
          doCheck,
          doUncheck,
          renderCell
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        const scrollbarInstRef = ref(null);
        const virtualListRef = ref(null);
        const emptyElRef = ref(null);
        const emptyRef = useMemo(() => paginatedDataRef.value.length === 0);
        const shouldDisplaySomeTablePartRef = useMemo(() => props.showHeader || !emptyRef.value);
        const bodyShowHeaderOnlyRef = useMemo(() => {
          return props.showHeader || emptyRef.value;
        });
        let lastSelectedKey = "";
        const mergedExpandedRowKeySetRef = computed(() => {
          return new Set(mergedExpandedRowKeysRef.value);
        });
        function getRowInfo(key) {
          var _a;
          return (_a = treeMateRef.value.getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
        }
        function handleCheckboxUpdateChecked(tmNode, checked, shiftKey) {
          const rowInfo = getRowInfo(tmNode.key);
          if (!rowInfo) {
            warn$2("data-table", `fail to get row data with key ${tmNode.key}`);
            return;
          }
          if (shiftKey) {
            const lastIndex = paginatedDataRef.value.findIndex((item) => item.key === lastSelectedKey);
            if (lastIndex !== -1) {
              const currentIndex = paginatedDataRef.value.findIndex((item) => item.key === tmNode.key);
              const start = Math.min(lastIndex, currentIndex);
              const end = Math.max(lastIndex, currentIndex);
              const rowKeysToCheck = [];
              paginatedDataRef.value.slice(start, end + 1).forEach((r) => {
                if (!r.disabled) {
                  rowKeysToCheck.push(r.key);
                }
              });
              if (checked) {
                doCheck(rowKeysToCheck, false, rowInfo);
              } else {
                doUncheck(rowKeysToCheck, rowInfo);
              }
              lastSelectedKey = tmNode.key;
              return;
            }
          }
          if (checked) {
            doCheck(tmNode.key, false, rowInfo);
          } else {
            doUncheck(tmNode.key, rowInfo);
          }
          lastSelectedKey = tmNode.key;
        }
        function handleRadioUpdateChecked(tmNode) {
          const rowInfo = getRowInfo(tmNode.key);
          if (!rowInfo) {
            warn$2("data-table", `fail to get row data with key ${tmNode.key}`);
            return;
          }
          doCheck(tmNode.key, true, rowInfo);
        }
        function getScrollContainer() {
          if (!shouldDisplaySomeTablePartRef.value) {
            const { value: emptyEl } = emptyElRef;
            if (emptyEl) {
              return emptyEl;
            } else {
              return null;
            }
          }
          if (virtualScrollRef.value) {
            return virtualListContainer();
          }
          const { value } = scrollbarInstRef;
          if (value)
            return value.containerRef;
          return null;
        }
        function handleUpdateExpanded(key, tmNode) {
          var _a;
          if (loadingKeySetRef.value.has(key))
            return;
          const { value: mergedExpandedRowKeys } = mergedExpandedRowKeysRef;
          const index = mergedExpandedRowKeys.indexOf(key);
          const nextExpandedKeys = Array.from(mergedExpandedRowKeys);
          if (~index) {
            nextExpandedKeys.splice(index, 1);
            doUpdateExpandedRowKeys(nextExpandedKeys);
          } else {
            if (tmNode && !tmNode.isLeaf && !tmNode.shallowLoaded) {
              loadingKeySetRef.value.add(key);
              void ((_a = onLoadRef.value) === null || _a === void 0 ? void 0 : _a.call(onLoadRef, tmNode.rawNode).then(() => {
                const { value: futureMergedExpandedRowKeys } = mergedExpandedRowKeysRef;
                const futureNextExpandedKeys = Array.from(futureMergedExpandedRowKeys);
                const index2 = futureNextExpandedKeys.indexOf(key);
                if (!~index2) {
                  futureNextExpandedKeys.push(key);
                }
                doUpdateExpandedRowKeys(futureNextExpandedKeys);
              }).finally(() => {
                loadingKeySetRef.value.delete(key);
              }));
            } else {
              nextExpandedKeys.push(key);
              doUpdateExpandedRowKeys(nextExpandedKeys);
            }
          }
        }
        function handleMouseleaveTable() {
          hoverKeyRef.value = null;
        }
        function handleMouseenterTable() {
          scrollPartRef.value = "body";
        }
        function virtualListContainer() {
          const { value } = virtualListRef;
          return value === null || value === void 0 ? void 0 : value.listElRef;
        }
        function virtualListContent() {
          const { value } = virtualListRef;
          return value === null || value === void 0 ? void 0 : value.itemsElRef;
        }
        function handleVirtualListScroll(e) {
          var _a;
          handleTableBodyScroll(e);
          (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
        }
        function handleVirtualListResize(e) {
          var _a;
          const { onResize } = props;
          if (onResize)
            onResize(e);
          (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
        }
        const exposedMethods = {
          getScrollContainer,
          scrollTo(arg0, arg1) {
            var _a, _b;
            if (virtualScrollRef.value) {
              (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
            } else {
              (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(arg0, arg1);
            }
          }
        };
        const style2 = c$1([
          ({ props: cProps }) => {
            const createActiveLeftFixedStyle = (leftActiveFixedColKey) => {
              if (leftActiveFixedColKey === null)
                return null;
              return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${leftActiveFixedColKey}"]::after`, { boxShadow: "var(--n-box-shadow-after)" });
            };
            const createActiveRightFixedStyle = (rightActiveFixedColKey) => {
              if (rightActiveFixedColKey === null)
                return null;
              return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${rightActiveFixedColKey}"]::before`, { boxShadow: "var(--n-box-shadow-before)" });
            };
            return c$1([
              createActiveLeftFixedStyle(cProps.leftActiveFixedColKey),
              createActiveRightFixedStyle(cProps.rightActiveFixedColKey),
              cProps.leftActiveFixedChildrenColKeys.map((leftActiveFixedColKey) => createActiveLeftFixedStyle(leftActiveFixedColKey)),
              cProps.rightActiveFixedChildrenColKeys.map((rightActiveFixedColKey) => createActiveRightFixedStyle(rightActiveFixedColKey))
            ]);
          }
        ]);
        let fixedStyleMounted = false;
        watchEffect(() => {
          const { value: leftActiveFixedColKey } = leftActiveFixedColKeyRef;
          const { value: leftActiveFixedChildrenColKeys } = leftActiveFixedChildrenColKeysRef;
          const { value: rightActiveFixedColKey } = rightActiveFixedColKeyRef;
          const { value: rightActiveFixedChildrenColKeys } = rightActiveFixedChildrenColKeysRef;
          if (!fixedStyleMounted && leftActiveFixedColKey === null && rightActiveFixedColKey === null) {
            return;
          }
          const cProps = {
            leftActiveFixedColKey,
            leftActiveFixedChildrenColKeys,
            rightActiveFixedColKey,
            rightActiveFixedChildrenColKeys,
            componentId
          };
          style2.mount({
            id: `n-${componentId}`,
            force: true,
            props: cProps,
            anchorMetaName: cssrAnchorMetaName
          });
          fixedStyleMounted = true;
        });
        onUnmounted(() => {
          style2.unmount({
            id: `n-${componentId}`
          });
        });
        return Object.assign({
          bodyWidth: bodyWidthRef,
          summaryPlacement: summaryPlacementRef,
          dataTableSlots,
          componentId,
          scrollbarInstRef,
          virtualListRef,
          emptyElRef,
          summary: summaryRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          scrollX: scrollXRef,
          cols: colsRef,
          loading: loadingRef,
          bodyShowHeaderOnly: bodyShowHeaderOnlyRef,
          shouldDisplaySomeTablePart: shouldDisplaySomeTablePartRef,
          empty: emptyRef,
          paginatedDataAndInfo: computed(() => {
            const { value: striped } = stripedRef;
            let hasChildren = false;
            const data = paginatedDataRef.value.map(striped ? (tmNode, index) => {
              if (!tmNode.isLeaf)
                hasChildren = true;
              return {
                tmNode,
                key: tmNode.key,
                striped: index % 2 === 1,
                index
              };
            } : (tmNode, index) => {
              if (!tmNode.isLeaf)
                hasChildren = true;
              return {
                tmNode,
                key: tmNode.key,
                striped: false,
                index
              };
            });
            return {
              data,
              hasChildren
            };
          }),
          rawPaginatedData: rawPaginatedDataRef,
          fixedColumnLeftMap: fixedColumnLeftMapRef,
          fixedColumnRightMap: fixedColumnRightMapRef,
          currentPage: mergedCurrentPageRef,
          rowClassName: rowClassNameRef,
          renderExpand: renderExpandRef,
          mergedExpandedRowKeySet: mergedExpandedRowKeySetRef,
          hoverKey: hoverKeyRef,
          mergedSortState: mergedSortStateRef,
          virtualScroll: virtualScrollRef,
          mergedTableLayout: mergedTableLayoutRef,
          childTriggerColIndex: childTriggerColIndexRef,
          indent: indentRef,
          rowProps: rowPropsRef,
          maxHeight: maxHeightRef,
          loadingKeySet: loadingKeySetRef,
          expandable: expandableRef,
          stickyExpandedRows: stickyExpandedRowsRef,
          renderExpandIcon: renderExpandIconRef,
          scrollbarProps: scrollbarPropsRef,
          setHeaderScrollLeft,
          handleMouseenterTable,
          handleVirtualListScroll,
          handleVirtualListResize,
          handleMouseleaveTable,
          virtualListContainer,
          virtualListContent,
          handleTableBodyScroll,
          handleCheckboxUpdateChecked,
          handleRadioUpdateChecked,
          handleUpdateExpanded,
          renderCell
        }, exposedMethods);
      },
      render() {
        const { mergedTheme, scrollX, mergedClsPrefix, virtualScroll, maxHeight, mergedTableLayout, flexHeight, loadingKeySet, onResize, setHeaderScrollLeft } = this;
        const scrollable = scrollX !== void 0 || maxHeight !== void 0 || flexHeight;
        const isBasicAutoLayout = !scrollable && mergedTableLayout === "auto";
        const xScrollable = scrollX !== void 0 || isBasicAutoLayout;
        const contentStyle = {
          minWidth: formatLength(scrollX) || "100%"
        };
        if (scrollX)
          contentStyle.width = "100%";
        const tableNode = h(NScrollbar, Object.assign({}, this.scrollbarProps, { ref: "scrollbarInstRef", scrollable: scrollable || isBasicAutoLayout, class: `${mergedClsPrefix}-data-table-base-table-body`, style: this.bodyStyle, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, contentStyle, container: virtualScroll ? this.virtualListContainer : void 0, content: virtualScroll ? this.virtualListContent : void 0, horizontalRailStyle: { zIndex: 3 }, verticalRailStyle: { zIndex: 3 }, xScrollable, onScroll: virtualScroll ? void 0 : this.handleTableBodyScroll, internalOnUpdateScrollLeft: setHeaderScrollLeft, onResize }), {
          default: () => {
            const cordToPass = {};
            const cordKey = {};
            const { cols, paginatedDataAndInfo, mergedTheme: mergedTheme2, fixedColumnLeftMap, fixedColumnRightMap, currentPage, rowClassName, mergedSortState, mergedExpandedRowKeySet, stickyExpandedRows, componentId, childTriggerColIndex, expandable, rowProps, handleMouseenterTable, handleMouseleaveTable, renderExpand, summary, handleCheckboxUpdateChecked, handleRadioUpdateChecked, handleUpdateExpanded } = this;
            const { length: colCount } = cols;
            let mergedData;
            const { data: paginatedData, hasChildren } = paginatedDataAndInfo;
            const mergedPaginationData = hasChildren ? flatten(paginatedData, mergedExpandedRowKeySet) : paginatedData;
            if (summary) {
              const summaryRows = summary(this.rawPaginatedData);
              if (Array.isArray(summaryRows)) {
                const summaryRowData = summaryRows.map((row, i) => ({
                  isSummaryRow: true,
                  key: `__n_summary__${i}`,
                  tmNode: {
                    rawNode: row,
                    disabled: true
                  },
                  index: -1
                }));
                mergedData = this.summaryPlacement === "top" ? [...summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, ...summaryRowData];
              } else {
                const summaryRowData = {
                  isSummaryRow: true,
                  key: "__n_summary__",
                  tmNode: {
                    rawNode: summaryRows,
                    disabled: true
                  },
                  index: -1
                };
                mergedData = this.summaryPlacement === "top" ? [summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, summaryRowData];
              }
            } else {
              mergedData = mergedPaginationData;
            }
            const indentStyle = hasChildren ? { width: pxfy(this.indent) } : void 0;
            const displayedData = [];
            mergedData.forEach((rowInfo) => {
              if (renderExpand && mergedExpandedRowKeySet.has(rowInfo.key) && (!expandable || expandable(rowInfo.tmNode.rawNode))) {
                displayedData.push(rowInfo, {
                  isExpandedRow: true,
                  key: `${rowInfo.key}-expand`,
                  tmNode: rowInfo.tmNode,
                  index: rowInfo.index
                });
              } else {
                displayedData.push(rowInfo);
              }
            });
            const { length: rowCount } = displayedData;
            const rowIndexToKey = {};
            paginatedData.forEach(({ tmNode }, rowIndex) => {
              rowIndexToKey[rowIndex] = tmNode.key;
            });
            const bodyWidth = stickyExpandedRows ? this.bodyWidth : null;
            const bodyWidthPx = bodyWidth === null ? void 0 : `${bodyWidth}px`;
            const renderRow = (rowInfo, displayedRowIndex, isVirtual) => {
              const { index: actualRowIndex } = rowInfo;
              if ("isExpandedRow" in rowInfo) {
                const { tmNode: { key, rawNode } } = rowInfo;
                return h(
                  "tr",
                  { class: `${mergedClsPrefix}-data-table-tr`, key: `${key}__expand` },
                  h("td", { class: [
                    `${mergedClsPrefix}-data-table-td`,
                    `${mergedClsPrefix}-data-table-td--last-col`,
                    displayedRowIndex + 1 === rowCount && `${mergedClsPrefix}-data-table-td--last-row`
                  ], colspan: colCount }, stickyExpandedRows ? h("div", { class: `${mergedClsPrefix}-data-table-expand`, style: {
                    width: bodyWidthPx
                  } }, renderExpand(rawNode, actualRowIndex)) : renderExpand(rawNode, actualRowIndex))
                );
              }
              const isSummary = "isSummaryRow" in rowInfo;
              const striped = !isSummary && rowInfo.striped;
              const { tmNode, key: rowKey } = rowInfo;
              const { rawNode: rowData } = tmNode;
              const expanded = mergedExpandedRowKeySet.has(rowKey);
              const props = rowProps ? rowProps(rowData, actualRowIndex) : void 0;
              const mergedRowClassName = typeof rowClassName === "string" ? rowClassName : createRowClassName(rowData, actualRowIndex, rowClassName);
              const row = h("tr", Object.assign({ onMouseenter: () => {
                this.hoverKey = rowKey;
              }, key: rowKey, class: [
                `${mergedClsPrefix}-data-table-tr`,
                isSummary && `${mergedClsPrefix}-data-table-tr--summary`,
                striped && `${mergedClsPrefix}-data-table-tr--striped`,
                mergedRowClassName
              ] }, props), cols.map((col, colIndex) => {
                var _a, _b, _c, _d, _e;
                if (displayedRowIndex in cordToPass) {
                  const cordOfRowToPass = cordToPass[displayedRowIndex];
                  const indexInCordOfRowToPass = cordOfRowToPass.indexOf(colIndex);
                  if (~indexInCordOfRowToPass) {
                    cordOfRowToPass.splice(indexInCordOfRowToPass, 1);
                    return null;
                  }
                }
                const { column } = col;
                const colKey = getColKey(col);
                const { rowSpan, colSpan } = column;
                const mergedColSpan = isSummary ? ((_a = rowInfo.tmNode.rawNode[colKey]) === null || _a === void 0 ? void 0 : _a.colSpan) || 1 : colSpan ? colSpan(rowData, actualRowIndex) : 1;
                const mergedRowSpan = isSummary ? ((_b = rowInfo.tmNode.rawNode[colKey]) === null || _b === void 0 ? void 0 : _b.rowSpan) || 1 : rowSpan ? rowSpan(rowData, actualRowIndex) : 1;
                const isLastCol = colIndex + mergedColSpan === colCount;
                const isLastRow = displayedRowIndex + mergedRowSpan === rowCount;
                const isCrossRowTd = mergedRowSpan > 1;
                if (isCrossRowTd) {
                  cordKey[displayedRowIndex] = {
                    [colIndex]: []
                  };
                }
                if (mergedColSpan > 1 || isCrossRowTd) {
                  for (let i = displayedRowIndex; i < displayedRowIndex + mergedRowSpan; ++i) {
                    if (isCrossRowTd) {
                      cordKey[displayedRowIndex][colIndex].push(rowIndexToKey[i]);
                    }
                    for (let j = colIndex; j < colIndex + mergedColSpan; ++j) {
                      if (i === displayedRowIndex && j === colIndex) {
                        continue;
                      }
                      if (!(i in cordToPass)) {
                        cordToPass[i] = [j];
                      } else {
                        cordToPass[i].push(j);
                      }
                    }
                  }
                }
                const hoverKey = isCrossRowTd ? this.hoverKey : null;
                const { cellProps } = column;
                const resolvedCellProps = cellProps === null || cellProps === void 0 ? void 0 : cellProps(rowData, actualRowIndex);
                return h(
                  "td",
                  Object.assign({}, resolvedCellProps, { key: colKey, style: [
                    {
                      textAlign: column.align || void 0,
                      left: pxfy((_c = fixedColumnLeftMap[colKey]) === null || _c === void 0 ? void 0 : _c.start),
                      right: pxfy((_d = fixedColumnRightMap[colKey]) === null || _d === void 0 ? void 0 : _d.start)
                    },
                    (resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.style) || ""
                  ], colspan: mergedColSpan, rowspan: isVirtual ? void 0 : mergedRowSpan, "data-col-key": colKey, class: [
                    `${mergedClsPrefix}-data-table-td`,
                    column.className,
                    resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.class,
                    isSummary && `${mergedClsPrefix}-data-table-td--summary`,
                    (hoverKey !== null && cordKey[displayedRowIndex][colIndex].includes(hoverKey) || isColumnSorting(column, mergedSortState)) && `${mergedClsPrefix}-data-table-td--hover`,
                    column.fixed && `${mergedClsPrefix}-data-table-td--fixed-${column.fixed}`,
                    column.align && `${mergedClsPrefix}-data-table-td--${column.align}-align`,
                    column.type === "selection" && `${mergedClsPrefix}-data-table-td--selection`,
                    column.type === "expand" && `${mergedClsPrefix}-data-table-td--expand`,
                    isLastCol && `${mergedClsPrefix}-data-table-td--last-col`,
                    isLastRow && `${mergedClsPrefix}-data-table-td--last-row`
                  ] }),
                  hasChildren && colIndex === childTriggerColIndex ? [
                    repeat(isSummary ? 0 : rowInfo.tmNode.level, h("div", { class: `${mergedClsPrefix}-data-table-indent`, style: indentStyle })),
                    isSummary || rowInfo.tmNode.isLeaf ? h("div", { class: `${mergedClsPrefix}-data-table-expand-placeholder` }) : h(ExpandTrigger, { class: `${mergedClsPrefix}-data-table-expand-trigger`, clsPrefix: mergedClsPrefix, expanded, renderExpandIcon: this.renderExpandIcon, loading: loadingKeySet.has(rowInfo.key), onClick: () => {
                      handleUpdateExpanded(rowKey, rowInfo.tmNode);
                    } })
                  ] : null,
                  column.type === "selection" ? !isSummary ? column.multiple === false ? h(RenderSafeRadio, { key: currentPage, rowKey, disabled: rowInfo.tmNode.disabled, onUpdateChecked: () => handleRadioUpdateChecked(rowInfo.tmNode) }) : h(RenderSafeCheckbox, { key: currentPage, rowKey, disabled: rowInfo.tmNode.disabled, onUpdateChecked: (checked, e) => handleCheckboxUpdateChecked(rowInfo.tmNode, checked, e.shiftKey) }) : null : column.type === "expand" ? !isSummary ? !column.expandable || ((_e = column.expandable) === null || _e === void 0 ? void 0 : _e.call(column, rowData)) ? h(ExpandTrigger, { clsPrefix: mergedClsPrefix, expanded, renderExpandIcon: this.renderExpandIcon, onClick: () => handleUpdateExpanded(rowKey, null) }) : null : null : h(Cell, { clsPrefix: mergedClsPrefix, index: actualRowIndex, row: rowData, column, isSummary, mergedTheme: mergedTheme2, renderCell: this.renderCell })
                );
              }));
              return row;
            };
            if (!virtualScroll) {
              return h(
                "table",
                { class: `${mergedClsPrefix}-data-table-table`, onMouseleave: handleMouseleaveTable, onMouseenter: handleMouseenterTable, style: {
                  tableLayout: this.mergedTableLayout
                } },
                h("colgroup", null, cols.map((col) => h("col", { key: col.key, style: col.style }))),
                this.showHeader ? h(TableHeader, { discrete: false }) : null,
                !this.empty ? h("tbody", { "data-n-id": componentId, class: `${mergedClsPrefix}-data-table-tbody` }, displayedData.map((rowInfo, displayedRowIndex) => {
                  return renderRow(rowInfo, displayedRowIndex, false);
                })) : null
              );
            } else {
              return h(VVirtualList, { ref: "virtualListRef", items: displayedData, itemSize: 28, visibleItemsTag: VirtualListItemWrapper, visibleItemsProps: {
                clsPrefix: mergedClsPrefix,
                id: componentId,
                cols,
                onMouseenter: handleMouseenterTable,
                onMouseleave: handleMouseleaveTable
              }, showScrollbar: false, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemsStyle: contentStyle, itemResizable: true }, {
                default: ({ item, index }) => renderRow(item, index, true)
              });
            }
          }
        });
        if (this.empty) {
          const createEmptyNode = () => h("div", { class: [
            `${mergedClsPrefix}-data-table-empty`,
            this.loading && `${mergedClsPrefix}-data-table-empty--hide`
          ], style: this.bodyStyle, ref: "emptyElRef" }, resolveSlot(this.dataTableSlots.empty, () => [
            h(NEmpty, { theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })
          ]));
          if (this.shouldDisplaySomeTablePart) {
            return h(
              Fragment,
              null,
              tableNode,
              createEmptyNode()
            );
          } else {
            return h(VResizeObserver, { onResize: this.onResize }, { default: createEmptyNode });
          }
        }
        return tableNode;
      }
    });
    const MainTable = defineComponent({
      setup() {
        const {
          mergedClsPrefixRef,
          rightFixedColumnsRef,
          leftFixedColumnsRef,
          bodyWidthRef,
          maxHeightRef,
          minHeightRef,
          flexHeightRef,
          syncScrollState
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dataTableInjectionKey);
        const headerInstRef = ref(null);
        const bodyInstRef = ref(null);
        const selfElRef = ref(null);
        const fixedStateInitializedRef = ref(!(leftFixedColumnsRef.value.length || rightFixedColumnsRef.value.length));
        const bodyStyleRef = computed(() => {
          return {
            maxHeight: formatLength(maxHeightRef.value),
            minHeight: formatLength(minHeightRef.value)
          };
        });
        function handleBodyResize(entry) {
          bodyWidthRef.value = entry.contentRect.width;
          syncScrollState();
          if (!fixedStateInitializedRef.value) {
            fixedStateInitializedRef.value = true;
          }
        }
        function getHeaderElement() {
          const { value } = headerInstRef;
          if (value) {
            return value.$el;
          }
          return null;
        }
        function getBodyElement() {
          const { value } = bodyInstRef;
          if (value) {
            return value.getScrollContainer();
          }
          return null;
        }
        const exposedMethods = {
          getBodyElement,
          getHeaderElement,
          scrollTo(arg0, arg1) {
            var _a;
            (_a = bodyInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
          }
        };
        watchEffect(() => {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          const transitionDisabledClass = `${mergedClsPrefixRef.value}-data-table-base-table--transition-disabled`;
          if (fixedStateInitializedRef.value) {
            setTimeout(() => {
              selfEl.classList.remove(transitionDisabledClass);
            }, 0);
          } else {
            selfEl.classList.add(transitionDisabledClass);
          }
        });
        return Object.assign({
          maxHeight: maxHeightRef,
          mergedClsPrefix: mergedClsPrefixRef,
          selfElRef,
          headerInstRef,
          bodyInstRef,
          bodyStyle: bodyStyleRef,
          flexHeight: flexHeightRef,
          handleBodyResize
        }, exposedMethods);
      },
      render() {
        const { mergedClsPrefix, maxHeight, flexHeight } = this;
        const headerInBody = maxHeight === void 0 && !flexHeight;
        return h(
          "div",
          { class: `${mergedClsPrefix}-data-table-base-table`, ref: "selfElRef" },
          headerInBody ? null : h(TableHeader, { ref: "headerInstRef" }),
          h(TableBody, { ref: "bodyInstRef", bodyStyle: this.bodyStyle, showHeader: headerInBody, flexHeight, onResize: this.handleBodyResize })
        );
      }
    });
    function useCheck(props, data) {
      const { paginatedDataRef, treeMateRef, selectionColumnRef } = data;
      const uncontrolledCheckedRowKeysRef = ref(props.defaultCheckedRowKeys);
      const mergedCheckState = computed(() => {
        var _a;
        const { checkedRowKeys } = props;
        const sourceKeys = checkedRowKeys === void 0 ? uncontrolledCheckedRowKeysRef.value : checkedRowKeys;
        if (((_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.multiple) === false) {
          return {
            checkedKeys: sourceKeys.slice(0, 1),
            indeterminateKeys: []
          };
        }
        return treeMateRef.value.getCheckedKeys(sourceKeys, {
          cascade: props.cascade,
          allowNotLoaded: props.allowCheckingNotLoaded
        });
      });
      const mergedCheckedRowKeysRef = computed(() => mergedCheckState.value.checkedKeys);
      const mergedInderminateRowKeysRef = computed(() => mergedCheckState.value.indeterminateKeys);
      const mergedCheckedRowKeySetRef = computed(() => {
        return new Set(mergedCheckedRowKeysRef.value);
      });
      const mergedInderminateRowKeySetRef = computed(() => {
        return new Set(mergedInderminateRowKeysRef.value);
      });
      const countOfCurrentPageCheckedRowsRef = computed(() => {
        const { value: mergedCheckedRowKeySet } = mergedCheckedRowKeySetRef;
        return paginatedDataRef.value.reduce((total, tmNode) => {
          const { key, disabled } = tmNode;
          return total + (!disabled && mergedCheckedRowKeySet.has(key) ? 1 : 0);
        }, 0);
      });
      const countOfCurrentPageDisabledRowsRef = computed(() => {
        return paginatedDataRef.value.filter((item) => item.disabled).length;
      });
      const someRowsCheckedRef = computed(() => {
        const { length } = paginatedDataRef.value;
        const { value: mergedInderminateRowKeySet } = mergedInderminateRowKeySetRef;
        return countOfCurrentPageCheckedRowsRef.value > 0 && countOfCurrentPageCheckedRowsRef.value < length - countOfCurrentPageDisabledRowsRef.value || paginatedDataRef.value.some((rowData) => mergedInderminateRowKeySet.has(rowData.key));
      });
      const allRowsCheckedRef = computed(() => {
        const { length } = paginatedDataRef.value;
        return countOfCurrentPageCheckedRowsRef.value !== 0 && countOfCurrentPageCheckedRowsRef.value === length - countOfCurrentPageDisabledRowsRef.value;
      });
      const headerCheckboxDisabledRef = computed(() => {
        return paginatedDataRef.value.length === 0;
      });
      function doUpdateCheckedRowKeys(keys2, row, action) {
        const { "onUpdate:checkedRowKeys": _onUpdateCheckedRowKeys, onUpdateCheckedRowKeys, onCheckedRowKeysChange } = props;
        const rows = [];
        const { value: { getNode } } = treeMateRef;
        keys2.forEach((key) => {
          var _a;
          const row2 = (_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
          rows.push(row2);
        });
        if (_onUpdateCheckedRowKeys) {
          call(_onUpdateCheckedRowKeys, keys2, rows, { row, action });
        }
        if (onUpdateCheckedRowKeys) {
          call(onUpdateCheckedRowKeys, keys2, rows, { row, action });
        }
        if (onCheckedRowKeysChange) {
          call(onCheckedRowKeysChange, keys2, rows, { row, action });
        }
        uncontrolledCheckedRowKeysRef.value = keys2;
      }
      function doCheck(rowKey, single = false, rowInfo) {
        if (props.loading)
          return;
        if (single) {
          doUpdateCheckedRowKeys(Array.isArray(rowKey) ? rowKey.slice(0, 1) : [rowKey], rowInfo, "check");
          return;
        }
        doUpdateCheckedRowKeys(treeMateRef.value.check(rowKey, mergedCheckedRowKeysRef.value, {
          cascade: props.cascade,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys, rowInfo, "check");
      }
      function doUncheck(rowKey, rowInfo) {
        if (props.loading)
          return;
        doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKey, mergedCheckedRowKeysRef.value, {
          cascade: props.cascade,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys, rowInfo, "uncheck");
      }
      function doCheckAll(checkWholeTable = false) {
        const { value: column } = selectionColumnRef;
        if (!column || props.loading)
          return;
        const rowKeysToCheck = [];
        (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
          if (!tmNode.disabled) {
            rowKeysToCheck.push(tmNode.key);
          }
        });
        doUpdateCheckedRowKeys(treeMateRef.value.check(rowKeysToCheck, mergedCheckedRowKeysRef.value, {
          cascade: true,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys, void 0, "checkAll");
      }
      function doUncheckAll(checkWholeTable = false) {
        const { value: column } = selectionColumnRef;
        if (!column || props.loading)
          return;
        const rowKeysToUncheck = [];
        (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
          if (!tmNode.disabled) {
            rowKeysToUncheck.push(tmNode.key);
          }
        });
        doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKeysToUncheck, mergedCheckedRowKeysRef.value, {
          cascade: true,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys, void 0, "uncheckAll");
      }
      return {
        mergedCheckedRowKeySetRef,
        mergedCheckedRowKeysRef,
        mergedInderminateRowKeySetRef,
        someRowsCheckedRef,
        allRowsCheckedRef,
        headerCheckboxDisabledRef,
        doUpdateCheckedRowKeys,
        doCheckAll,
        doUncheckAll,
        doCheck,
        doUncheck
      };
    }
    function getMultiplePriority(sorter) {
      if (typeof sorter === "object" && typeof sorter.multiple === "number") {
        return sorter.multiple;
      }
      return false;
    }
    function getSortFunction(sorter, columnKey) {
      if (columnKey && (sorter === void 0 || sorter === "default" || typeof sorter === "object" && sorter.compare === "default")) {
        return getDefaultSorterFn(columnKey);
      }
      if (typeof sorter === "function") {
        return sorter;
      }
      if (sorter && typeof sorter === "object" && sorter.compare && sorter.compare !== "default") {
        return sorter.compare;
      }
      return false;
    }
    function getDefaultSorterFn(columnKey) {
      return (row1, row2) => {
        const value1 = row1[columnKey];
        const value2 = row2[columnKey];
        if (typeof value1 === "number" && typeof value2 === "number") {
          return value1 - value2;
        } else if (typeof value1 === "string" && typeof value2 === "string") {
          return value1.localeCompare(value2);
        }
        return 0;
      };
    }
    function useSorter(props, { dataRelatedColsRef, filteredDataRef }) {
      const defaultSortState = [];
      dataRelatedColsRef.value.forEach((column) => {
        var _a;
        if (column.sorter !== void 0) {
          updateSortStatesByNewSortState(defaultSortState, {
            columnKey: column.key,
            sorter: column.sorter,
            order: (_a = column.defaultSortOrder) !== null && _a !== void 0 ? _a : false
          });
        }
      });
      const uncontrolledSortStateRef = ref(defaultSortState);
      const mergedSortStateRef = computed(() => {
        const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter((column) => column.type !== "selection" && column.sorter !== void 0 && (column.sortOrder === "ascend" || column.sortOrder === "descend" || column.sortOrder === false));
        const columnToSort = columnsWithControlledSortOrder.filter((col) => col.sortOrder !== false);
        if (columnToSort.length) {
          return columnToSort.map((column) => {
            return {
              columnKey: column.key,
              // column to sort has controlled sorter
              // sorter && sort order won't be undefined
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              order: column.sortOrder,
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              sorter: column.sorter
            };
          });
        }
        if (columnsWithControlledSortOrder.length)
          return [];
        const { value: uncontrolledSortState } = uncontrolledSortStateRef;
        if (Array.isArray(uncontrolledSortState)) {
          return uncontrolledSortState;
        } else if (uncontrolledSortState) {
          return [uncontrolledSortState];
        } else {
          return [];
        }
      });
      const sortedDataRef = computed(() => {
        const activeSorters = mergedSortStateRef.value.slice().sort((a, b) => {
          const item1Priority = getMultiplePriority(a.sorter) || 0;
          const item2Priority = getMultiplePriority(b.sorter) || 0;
          return item2Priority - item1Priority;
        });
        if (activeSorters.length) {
          const filteredData = filteredDataRef.value.slice();
          return filteredData.sort((tmNode1, tmNode2) => {
            let compareResult = 0;
            activeSorters.some((sorterState) => {
              const { columnKey, sorter, order } = sorterState;
              const compareFn = getSortFunction(sorter, columnKey);
              if (compareFn && order) {
                compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);
                if (compareResult !== 0) {
                  compareResult = compareResult * getFlagOfOrder(order);
                  return true;
                }
              }
              return false;
            });
            return compareResult;
          });
        }
        return filteredDataRef.value;
      });
      function getUpdatedSorterState(sortState) {
        let currentSortState = mergedSortStateRef.value.slice();
        if (sortState && getMultiplePriority(sortState.sorter) !== false) {
          currentSortState = currentSortState.filter((sortState2) => getMultiplePriority(sortState2.sorter) !== false);
          updateSortStatesByNewSortState(currentSortState, sortState);
          return currentSortState;
        } else if (sortState) {
          return sortState;
        }
        return null;
      }
      function deriveNextSorter(sortState) {
        const nextSorterState = getUpdatedSorterState(sortState);
        doUpdateSorter(nextSorterState);
      }
      function doUpdateSorter(sortState) {
        const { "onUpdate:sorter": _onUpdateSorter, onUpdateSorter, onSorterChange } = props;
        if (_onUpdateSorter) {
          call(_onUpdateSorter, sortState);
        }
        if (onUpdateSorter) {
          call(onUpdateSorter, sortState);
        }
        if (onSorterChange) {
          call(onSorterChange, sortState);
        }
        uncontrolledSortStateRef.value = sortState;
      }
      function sort(columnKey, order = "ascend") {
        if (!columnKey) {
          clearSorter();
        } else {
          const columnToSort = dataRelatedColsRef.value.find((column) => column.type !== "selection" && column.type !== "expand" && column.key === columnKey);
          if (!(columnToSort === null || columnToSort === void 0 ? void 0 : columnToSort.sorter))
            return;
          const sorter = columnToSort.sorter;
          deriveNextSorter({
            columnKey,
            sorter,
            order
          });
        }
      }
      function clearSorter() {
        doUpdateSorter(null);
      }
      function updateSortStatesByNewSortState(sortStates, sortState) {
        const index = sortStates.findIndex((state) => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);
        if (index !== void 0 && index >= 0) {
          sortStates[index] = sortState;
        } else {
          sortStates.push(sortState);
        }
      }
      return {
        clearSorter,
        sort,
        sortedDataRef,
        mergedSortStateRef,
        deriveNextSorter
      };
    }
    function useTableData(props, { dataRelatedColsRef }) {
      const selectionColumnRef = computed(() => {
        const getSelectionColumn = (cols) => {
          for (let i = 0; i < cols.length; ++i) {
            const col = cols[i];
            if ("children" in col) {
              return getSelectionColumn(col.children);
            } else if (col.type === "selection") {
              return col;
            }
          }
          return null;
        };
        return getSelectionColumn(props.columns);
      });
      const treeMateRef = computed(() => {
        const { childrenKey } = props;
        return createTreeMate(props.data, {
          ignoreEmptyChildren: true,
          getKey: props.rowKey,
          getChildren: (rowData) => rowData[childrenKey],
          getDisabled: (rowData) => {
            var _a, _b;
            if ((_b = (_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.disabled) === null || _b === void 0 ? void 0 : _b.call(_a, rowData)) {
              return true;
            }
            return false;
          }
        });
      });
      const childTriggerColIndexRef = useMemo(() => {
        const { columns } = props;
        const { length } = columns;
        let firstContentfulColIndex = null;
        for (let i = 0; i < length; ++i) {
          const col = columns[i];
          if (!col.type && firstContentfulColIndex === null) {
            firstContentfulColIndex = i;
          }
          if ("tree" in col && col.tree) {
            return i;
          }
        }
        return firstContentfulColIndex || 0;
      });
      const uncontrolledFilterStateRef = ref({});
      const uncontrolledCurrentPageRef = ref(1);
      const uncontrolledPageSizeRef = ref(10);
      const mergedFilterStateRef = computed(() => {
        const columnsWithControlledFilter = dataRelatedColsRef.value.filter((column) => {
          return column.filterOptionValues !== void 0 || column.filterOptionValue !== void 0;
        });
        const controlledFilterState = {};
        columnsWithControlledFilter.forEach((column) => {
          var _a;
          if (column.type === "selection" || column.type === "expand")
            return;
          if (column.filterOptionValues === void 0) {
            controlledFilterState[column.key] = (_a = column.filterOptionValue) !== null && _a !== void 0 ? _a : null;
          } else {
            controlledFilterState[column.key] = column.filterOptionValues;
          }
        });
        const activeFilters = Object.assign(createShallowClonedObject(uncontrolledFilterStateRef.value), controlledFilterState);
        return activeFilters;
      });
      const filteredDataRef = computed(() => {
        const mergedFilterState = mergedFilterStateRef.value;
        const { columns } = props;
        function createDefaultFilter(columnKey) {
          return (filterOptionValue, row) => !!~String(row[columnKey]).indexOf(String(filterOptionValue));
        }
        const { value: { treeNodes: data } } = treeMateRef;
        const columnEntries = [];
        columns.forEach((column) => {
          if (column.type === "selection" || column.type === "expand" || "children" in column) {
            return;
          }
          columnEntries.push([column.key, column]);
        });
        return data ? data.filter((tmNode) => {
          const { rawNode: row } = tmNode;
          for (const [columnKey, column] of columnEntries) {
            let activeFilterOptionValues = mergedFilterState[columnKey];
            if (activeFilterOptionValues == null)
              continue;
            if (!Array.isArray(activeFilterOptionValues)) {
              activeFilterOptionValues = [activeFilterOptionValues];
            }
            if (!activeFilterOptionValues.length)
              continue;
            const filter2 = column.filter === "default" ? createDefaultFilter(columnKey) : column.filter;
            if (column && typeof filter2 === "function") {
              if (column.filterMode === "and") {
                if (activeFilterOptionValues.some((filterOptionValue) => !filter2(filterOptionValue, row))) {
                  return false;
                }
              } else {
                if (activeFilterOptionValues.some((filterOptionValue) => filter2(filterOptionValue, row))) {
                  continue;
                } else {
                  return false;
                }
              }
            }
          }
          return true;
        }) : [];
      });
      const { sortedDataRef, deriveNextSorter, mergedSortStateRef, sort, clearSorter } = useSorter(props, {
        dataRelatedColsRef,
        filteredDataRef
      });
      dataRelatedColsRef.value.forEach((column) => {
        var _a;
        if (column.filter) {
          const defaultFilterOptionValues = column.defaultFilterOptionValues;
          if (column.filterMultiple) {
            uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues || [];
          } else if (defaultFilterOptionValues !== void 0) {
            uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues === null ? [] : defaultFilterOptionValues;
          } else {
            uncontrolledFilterStateRef.value[column.key] = (_a = column.defaultFilterOptionValue) !== null && _a !== void 0 ? _a : null;
          }
        }
      });
      const controlledCurrentPageRef = computed(() => {
        const { pagination } = props;
        if (pagination === false)
          return void 0;
        return pagination.page;
      });
      const controlledPageSizeRef = computed(() => {
        const { pagination } = props;
        if (pagination === false)
          return void 0;
        return pagination.pageSize;
      });
      const _mergedCurrentPageRef = useMergedState(controlledCurrentPageRef, uncontrolledCurrentPageRef);
      const mergedPageSizeRef = useMergedState(controlledPageSizeRef, uncontrolledPageSizeRef);
      const boundedMergedCurrentPageRef = useMemo(() => {
        const page2 = _mergedCurrentPageRef.value;
        return props.remote ? page2 : Math.max(1, Math.min(Math.ceil(filteredDataRef.value.length / mergedPageSizeRef.value), page2));
      });
      const mergedPageCountRef = computed(() => {
        const { pagination } = props;
        if (pagination) {
          const { pageCount } = pagination;
          if (pageCount !== void 0)
            return pageCount;
        }
        return void 0;
      });
      const paginatedDataRef = computed(() => {
        if (props.remote)
          return treeMateRef.value.treeNodes;
        if (!props.pagination)
          return sortedDataRef.value;
        const pageSize = mergedPageSizeRef.value;
        const startIndex = (boundedMergedCurrentPageRef.value - 1) * pageSize;
        return sortedDataRef.value.slice(startIndex, startIndex + pageSize);
      });
      const rawPaginatedDataRef = computed(() => {
        return paginatedDataRef.value.map((tmNode) => tmNode.rawNode);
      });
      function mergedOnUpdatePage(page2) {
        const { pagination } = props;
        if (pagination) {
          const { onChange, "onUpdate:page": _onUpdatePage, onUpdatePage } = pagination;
          if (onChange)
            call(onChange, page2);
          if (onUpdatePage)
            call(onUpdatePage, page2);
          if (_onUpdatePage)
            call(_onUpdatePage, page2);
          doUpdatePage(page2);
        }
      }
      function mergedOnUpdatePageSize(pageSize) {
        const { pagination } = props;
        if (pagination) {
          const { onPageSizeChange, "onUpdate:pageSize": _onUpdatePageSize, onUpdatePageSize } = pagination;
          if (onPageSizeChange)
            call(onPageSizeChange, pageSize);
          if (onUpdatePageSize)
            call(onUpdatePageSize, pageSize);
          if (_onUpdatePageSize)
            call(_onUpdatePageSize, pageSize);
          doUpdatePageSize(pageSize);
        }
      }
      const mergedItemCountRef = computed(() => {
        if (props.remote) {
          const { pagination } = props;
          if (pagination) {
            const { itemCount } = pagination;
            if (itemCount !== void 0)
              return itemCount;
          }
          return void 0;
        }
        return filteredDataRef.value.length;
      });
      const mergedPaginationRef = computed(() => {
        return Object.assign(Object.assign({}, props.pagination), {
          // reset deprecated methods
          onChange: void 0,
          onUpdatePage: void 0,
          onUpdatePageSize: void 0,
          onPageSizeChange: void 0,
          "onUpdate:page": mergedOnUpdatePage,
          "onUpdate:pageSize": mergedOnUpdatePageSize,
          // writing merged props after pagination to avoid
          // pagination[key] === undefined
          // key still exists but value is undefined
          page: boundedMergedCurrentPageRef.value,
          pageSize: mergedPageSizeRef.value,
          pageCount: mergedItemCountRef.value === void 0 ? mergedPageCountRef.value : void 0,
          itemCount: mergedItemCountRef.value
        });
      });
      function doUpdatePage(page2) {
        const { "onUpdate:page": _onUpdatePage, onPageChange, onUpdatePage } = props;
        if (onUpdatePage)
          call(onUpdatePage, page2);
        if (_onUpdatePage)
          call(_onUpdatePage, page2);
        if (onPageChange)
          call(onPageChange, page2);
        uncontrolledCurrentPageRef.value = page2;
      }
      function doUpdatePageSize(pageSize) {
        const { "onUpdate:pageSize": _onUpdatePageSize, onPageSizeChange, onUpdatePageSize } = props;
        if (onPageSizeChange)
          call(onPageSizeChange, pageSize);
        if (onUpdatePageSize)
          call(onUpdatePageSize, pageSize);
        if (_onUpdatePageSize)
          call(_onUpdatePageSize, pageSize);
        uncontrolledPageSizeRef.value = pageSize;
      }
      function doUpdateFilters(filters2, sourceColumn) {
        const { onUpdateFilters, "onUpdate:filters": _onUpdateFilters, onFiltersChange } = props;
        if (onUpdateFilters)
          call(onUpdateFilters, filters2, sourceColumn);
        if (_onUpdateFilters)
          call(_onUpdateFilters, filters2, sourceColumn);
        if (onFiltersChange)
          call(onFiltersChange, filters2, sourceColumn);
        uncontrolledFilterStateRef.value = filters2;
      }
      function onUnstableColumnResize(resizedWidth, limitedWidth, column, getColumnWidth) {
        var _a;
        (_a = props.onUnstableColumnResize) === null || _a === void 0 ? void 0 : _a.call(props, resizedWidth, limitedWidth, column, getColumnWidth);
      }
      function page(page2) {
        doUpdatePage(page2);
      }
      function clearFilter() {
        clearFilters();
      }
      function clearFilters() {
        filters({});
      }
      function filters(filters2) {
        filter(filters2);
      }
      function filter(filters2) {
        if (!filters2) {
          uncontrolledFilterStateRef.value = {};
        } else if (filters2) {
          uncontrolledFilterStateRef.value = createShallowClonedObject(filters2);
        } else
          ;
      }
      return {
        treeMateRef,
        mergedCurrentPageRef: boundedMergedCurrentPageRef,
        mergedPaginationRef,
        paginatedDataRef,
        rawPaginatedDataRef,
        mergedFilterStateRef,
        mergedSortStateRef,
        hoverKeyRef: ref(null),
        selectionColumnRef,
        childTriggerColIndexRef,
        doUpdateFilters,
        deriveNextSorter,
        doUpdatePageSize,
        doUpdatePage,
        onUnstableColumnResize,
        // exported methods
        filter,
        filters,
        clearFilter,
        clearFilters,
        clearSorter,
        page,
        sort
      };
    }
    function useScroll(props, { mainTableInstRef, mergedCurrentPageRef, bodyWidthRef, scrollPartRef }) {
      let scrollLeft = 0;
      const leftActiveFixedColKeyRef = ref(null);
      const leftActiveFixedChildrenColKeysRef = ref([]);
      const rightActiveFixedColKeyRef = ref(null);
      const rightActiveFixedChildrenColKeysRef = ref([]);
      const styleScrollXRef = computed(() => {
        return formatLength(props.scrollX);
      });
      const leftFixedColumnsRef = computed(() => {
        return props.columns.filter((column) => column.fixed === "left");
      });
      const rightFixedColumnsRef = computed(() => {
        return props.columns.filter((column) => column.fixed === "right");
      });
      const fixedColumnLeftMapRef = computed(() => {
        const columns = {};
        let left = 0;
        function traverse2(cols) {
          cols.forEach((col) => {
            const positionInfo = { start: left, end: 0 };
            columns[getColKey(col)] = positionInfo;
            if ("children" in col) {
              traverse2(col.children);
              positionInfo.end = left;
            } else {
              left += getNumberColWidth(col) || 0;
              positionInfo.end = left;
            }
          });
        }
        traverse2(leftFixedColumnsRef.value);
        return columns;
      });
      const fixedColumnRightMapRef = computed(() => {
        const columns = {};
        let right = 0;
        function traverse2(cols) {
          for (let i = cols.length - 1; i >= 0; --i) {
            const col = cols[i];
            const positionInfo = { start: right, end: 0 };
            columns[getColKey(col)] = positionInfo;
            if ("children" in col) {
              traverse2(col.children);
              positionInfo.end = right;
            } else {
              right += getNumberColWidth(col) || 0;
              positionInfo.end = right;
            }
          }
        }
        traverse2(rightFixedColumnsRef.value);
        return columns;
      });
      function deriveActiveLeftFixedColumn() {
        var _a, _b;
        const { value: leftFixedColumns } = leftFixedColumnsRef;
        let leftWidth = 0;
        const { value: fixedColumnLeftMap } = fixedColumnLeftMapRef;
        let leftActiveFixedColKey = null;
        for (let i = 0; i < leftFixedColumns.length; ++i) {
          const key = getColKey(leftFixedColumns[i]);
          if (scrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {
            leftActiveFixedColKey = key;
            leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
          } else {
            break;
          }
        }
        leftActiveFixedColKeyRef.value = leftActiveFixedColKey;
      }
      function deriveActiveLeftFixedChildrenColumns() {
        leftActiveFixedChildrenColKeysRef.value = [];
        let activeLeftFixedColumn = props.columns.find((col) => getColKey(col) === leftActiveFixedColKeyRef.value);
        while (activeLeftFixedColumn && "children" in activeLeftFixedColumn) {
          const length = activeLeftFixedColumn.children.length;
          if (length === 0)
            break;
          const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];
          leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));
          activeLeftFixedColumn = nextActiveLeftFixedColumn;
        }
      }
      function deriveActiveRightFixedColumn() {
        var _a, _b;
        const { value: rightFixedColumns } = rightFixedColumnsRef;
        const scrollWidth = Number(props.scrollX);
        const { value: tableWidth } = bodyWidthRef;
        if (tableWidth === null)
          return;
        let rightWidth = 0;
        let rightActiveFixedColKey = null;
        const { value: fixedColumnRightMap } = fixedColumnRightMapRef;
        for (let i = rightFixedColumns.length - 1; i >= 0; --i) {
          const key = getColKey(rightFixedColumns[i]);
          if (Math.round(scrollLeft + (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) + tableWidth - rightWidth) < scrollWidth) {
            rightActiveFixedColKey = key;
            rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
          } else {
            break;
          }
        }
        rightActiveFixedColKeyRef.value = rightActiveFixedColKey;
      }
      function deriveActiveRightFixedChildrenColumns() {
        rightActiveFixedChildrenColKeysRef.value = [];
        let activeRightFixedColumn = props.columns.find((col) => getColKey(col) === rightActiveFixedColKeyRef.value);
        while (activeRightFixedColumn && "children" in activeRightFixedColumn && activeRightFixedColumn.children.length) {
          const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];
          rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));
          activeRightFixedColumn = nextActiveRightFixedColumn;
        }
      }
      function getScrollElements() {
        const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;
        const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;
        return {
          header,
          body
        };
      }
      function scrollMainTableBodyToTop() {
        const { body } = getScrollElements();
        if (body) {
          body.scrollTop = 0;
        }
      }
      function handleTableHeaderScroll() {
        if (scrollPartRef.value === "head") {
          beforeNextFrameOnce(syncScrollState);
        }
      }
      function handleTableBodyScroll(e) {
        var _a;
        (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
        if (scrollPartRef.value === "body") {
          beforeNextFrameOnce(syncScrollState);
        }
      }
      function syncScrollState() {
        const { header, body } = getScrollElements();
        if (!body)
          return;
        const { value: tableWidth } = bodyWidthRef;
        if (tableWidth === null)
          return;
        const { value: scrollPart } = scrollPartRef;
        if (props.maxHeight || props.flexHeight) {
          if (!header)
            return;
          if (scrollPart === "head") {
            scrollLeft = header.scrollLeft;
            body.scrollLeft = scrollLeft;
          } else {
            scrollLeft = body.scrollLeft;
            header.scrollLeft = scrollLeft;
          }
        } else {
          scrollLeft = body.scrollLeft;
        }
        deriveActiveLeftFixedColumn();
        deriveActiveLeftFixedChildrenColumns();
        deriveActiveRightFixedColumn();
        deriveActiveRightFixedChildrenColumns();
      }
      function setHeaderScrollLeft(left) {
        const { header } = getScrollElements();
        if (!header)
          return;
        header.scrollLeft = left;
        syncScrollState();
      }
      watch(mergedCurrentPageRef, () => {
        scrollMainTableBodyToTop();
      });
      return {
        styleScrollXRef,
        fixedColumnLeftMapRef,
        fixedColumnRightMapRef,
        leftFixedColumnsRef,
        rightFixedColumnsRef,
        leftActiveFixedColKeyRef,
        leftActiveFixedChildrenColKeysRef,
        rightActiveFixedColKeyRef,
        rightActiveFixedChildrenColKeysRef,
        syncScrollState,
        handleTableBodyScroll,
        handleTableHeaderScroll,
        setHeaderScrollLeft
      };
    }
    function useResizable() {
      const resizableWidthsRef = ref({});
      function getResizableWidth(key) {
        return resizableWidthsRef.value[key];
      }
      function doUpdateResizableWidth(column, width) {
        if (isColumnResizable(column) && "key" in column) {
          resizableWidthsRef.value[column.key] = width;
        }
      }
      function clearResizableWidth() {
        resizableWidthsRef.value = {};
      }
      return {
        getResizableWidth,
        doUpdateResizableWidth,
        clearResizableWidth
      };
    }
    function getRowsAndCols(columns, getResizableWidth) {
      const rows = [];
      const cols = [];
      const dataRelatedCols = [];
      const rowItemMap = /* @__PURE__ */ new WeakMap();
      let maxDepth = -1;
      let totalRowSpan = 0;
      let hasEllipsis = false;
      function ensureMaxDepth(columns2, currentDepth) {
        if (currentDepth > maxDepth) {
          rows[currentDepth] = [];
          maxDepth = currentDepth;
        }
        for (const column of columns2) {
          if ("children" in column) {
            ensureMaxDepth(column.children, currentDepth + 1);
          } else {
            const key = "key" in column ? column.key : void 0;
            cols.push({
              key: getColKey(column),
              style: createCustomWidthStyle(column, key !== void 0 ? formatLength(getResizableWidth(key)) : void 0),
              column
            });
            totalRowSpan += 1;
            if (!hasEllipsis) {
              hasEllipsis = !!column.ellipsis;
            }
            dataRelatedCols.push(column);
          }
        }
      }
      ensureMaxDepth(columns, 0);
      let currentLeafIndex = 0;
      function ensureColLayout(columns2, currentDepth) {
        let hideUntilIndex = 0;
        columns2.forEach((column, index) => {
          var _a;
          if ("children" in column) {
            const cachedCurrentLeafIndex = currentLeafIndex;
            const rowItem = {
              column,
              colSpan: 0,
              rowSpan: 1,
              isLast: false
            };
            ensureColLayout(column.children, currentDepth + 1);
            column.children.forEach((childColumn) => {
              var _a2, _b;
              rowItem.colSpan += (_b = (_a2 = rowItemMap.get(childColumn)) === null || _a2 === void 0 ? void 0 : _a2.colSpan) !== null && _b !== void 0 ? _b : 0;
            });
            if (cachedCurrentLeafIndex + rowItem.colSpan === totalRowSpan) {
              rowItem.isLast = true;
            }
            rowItemMap.set(column, rowItem);
            rows[currentDepth].push(rowItem);
          } else {
            if (currentLeafIndex < hideUntilIndex) {
              currentLeafIndex += 1;
              return;
            }
            let colSpan = 1;
            if ("titleColSpan" in column) {
              colSpan = (_a = column.titleColSpan) !== null && _a !== void 0 ? _a : 1;
            }
            if (colSpan > 1) {
              hideUntilIndex = currentLeafIndex + colSpan;
            }
            const isLast = currentLeafIndex + colSpan === totalRowSpan;
            const rowItem = {
              column,
              colSpan,
              rowSpan: maxDepth - currentDepth + 1,
              isLast
            };
            rowItemMap.set(column, rowItem);
            rows[currentDepth].push(rowItem);
            currentLeafIndex += 1;
          }
        });
      }
      ensureColLayout(columns, 0);
      return {
        hasEllipsis,
        rows,
        cols,
        dataRelatedCols
      };
    }
    function useGroupHeader(props, getResizableWidth) {
      const rowsAndCols = computed(() => getRowsAndCols(props.columns, getResizableWidth));
      return {
        rowsRef: computed(() => rowsAndCols.value.rows),
        colsRef: computed(() => rowsAndCols.value.cols),
        hasEllipsisRef: computed(() => rowsAndCols.value.hasEllipsis),
        dataRelatedColsRef: computed(() => rowsAndCols.value.dataRelatedCols)
      };
    }
    function useExpand(props, treeMateRef) {
      const renderExpandRef = useMemo(() => {
        for (const col of props.columns) {
          if (col.type === "expand") {
            return col.renderExpand;
          }
        }
      });
      const expandableRef = useMemo(() => {
        let expandable;
        for (const col of props.columns) {
          if (col.type === "expand") {
            expandable = col.expandable;
            break;
          }
        }
        return expandable;
      });
      const uncontrolledExpandedRowKeysRef = ref(props.defaultExpandAll ? (renderExpandRef === null || renderExpandRef === void 0 ? void 0 : renderExpandRef.value) ? (() => {
        const expandedKeys = [];
        treeMateRef.value.treeNodes.forEach((tmNode) => {
          var _a;
          if ((_a = expandableRef.value) === null || _a === void 0 ? void 0 : _a.call(expandableRef, tmNode.rawNode)) {
            expandedKeys.push(tmNode.key);
          }
        });
        return expandedKeys;
      })() : treeMateRef.value.getNonLeafKeys() : props.defaultExpandedRowKeys);
      const controlledExpandedRowKeysRef = toRef(props, "expandedRowKeys");
      const stickyExpandedRowsRef = toRef(props, "stickyExpandedRows");
      const mergedExpandedRowKeysRef = useMergedState(controlledExpandedRowKeysRef, uncontrolledExpandedRowKeysRef);
      function doUpdateExpandedRowKeys(expandedKeys) {
        const { onUpdateExpandedRowKeys, "onUpdate:expandedRowKeys": _onUpdateExpandedRowKeys } = props;
        if (onUpdateExpandedRowKeys) {
          call(onUpdateExpandedRowKeys, expandedKeys);
        }
        if (_onUpdateExpandedRowKeys) {
          call(_onUpdateExpandedRowKeys, expandedKeys);
        }
        uncontrolledExpandedRowKeysRef.value = expandedKeys;
      }
      return {
        stickyExpandedRowsRef,
        mergedExpandedRowKeysRef,
        renderExpandRef,
        expandableRef,
        doUpdateExpandedRowKeys
      };
    }
    const fixedColumnStyle = createFixedColumnStyle();
    const style$4 = c$1([cB("data-table", `
 width: 100%;
 font-size: var(--n-font-size);
 display: flex;
 flex-direction: column;
 position: relative;
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 --n-merged-th-color-hover: var(--n-th-color-hover);
 --n-merged-td-color-hover: var(--n-td-color-hover);
 --n-merged-td-color-striped: var(--n-td-color-striped);
 `, [cB("data-table-wrapper", `
 flex-grow: 1;
 display: flex;
 flex-direction: column;
 `), cM("flex-height", [c$1(">", [cB("data-table-wrapper", [c$1(">", [cB("data-table-base-table", `
 display: flex;
 flex-direction: column;
 flex-grow: 1;
 `, [c$1(">", [cB("data-table-base-table-body", "flex-basis: 0;", [
      // last-child means there is no empty icon
      // body is a scrollbar, we need to override height 100%
      c$1("&:last-child", "flex-grow: 1;")
    ])])])])])])]), c$1(">", [cB("data-table-loading-wrapper", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [fadeInScaleUpTransition({
      originalTransform: "translateX(-50%) translateY(-50%)"
    })])]), cB("data-table-expand-placeholder", `
 margin-right: 8px;
 display: inline-block;
 width: 16px;
 height: 1px;
 `), cB("data-table-indent", `
 display: inline-block;
 height: 1px;
 `), cB("data-table-expand-trigger", `
 display: inline-flex;
 margin-right: 8px;
 cursor: pointer;
 font-size: 16px;
 vertical-align: -0.2em;
 position: relative;
 width: 16px;
 height: 16px;
 color: var(--n-td-text-color);
 transition: color .3s var(--n-bezier);
 `, [cM("expanded", [cB("icon", "transform: rotate(90deg);", [iconSwitchTransition({
      originalTransform: "rotate(90deg)"
    })]), cB("base-icon", "transform: rotate(90deg);", [iconSwitchTransition({
      originalTransform: "rotate(90deg)"
    })])]), cB("base-loading", `
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("base-icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cB("data-table-thead", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-merged-th-color);
 `), cB("data-table-tr", `
 box-sizing: border-box;
 background-clip: padding-box;
 transition: background-color .3s var(--n-bezier);
 `, [cB("data-table-expand", `
 position: sticky;
 left: 0;
 overflow: hidden;
 margin: calc(var(--n-th-padding) * -1);
 padding: var(--n-th-padding);
 box-sizing: border-box;
 `), cM("striped", "background-color: var(--n-merged-td-color-striped);", [cB("data-table-td", "background-color: var(--n-merged-td-color-striped);")]), cNotM("summary", [c$1("&:hover", "background-color: var(--n-merged-td-color-hover);", [c$1(">", [cB("data-table-td", "background-color: var(--n-merged-td-color-hover);")])])])]), cB("data-table-th", `
 padding: var(--n-th-padding);
 position: relative;
 text-align: start;
 box-sizing: border-box;
 background-color: var(--n-merged-th-color);
 border-color: var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 color: var(--n-th-text-color);
 transition:
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 font-weight: var(--n-th-font-weight);
 `, [cM("filterable", `
 padding-right: 36px;
 `, [cM("sortable", `
 padding-right: calc(var(--n-th-padding) + 36px);
 `)]), fixedColumnStyle, cM("selection", `
 padding: 0;
 text-align: center;
 line-height: 0;
 z-index: 3;
 `), cE("title-wrapper", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 max-width: 100%;
 `, [cE("title", `
 flex: 1;
 min-width: 0;
 `)]), cE("ellipsis", `
 display: inline-block;
 vertical-align: bottom;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 `), cM("hover", `
 background-color: var(--n-merged-th-color-hover);
 `), cM("sortable", `
 cursor: pointer;
 `, [cE("ellipsis", `
 max-width: calc(100% - 18px);
 `), c$1("&:hover", `
 background-color: var(--n-merged-th-color-hover);
 `)]), cB("data-table-sorter", `
 height: var(--n-sorter-size);
 width: var(--n-sorter-size);
 margin-left: 4px;
 position: relative;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 vertical-align: -0.2em;
 color: var(--n-th-icon-color);
 transition: color .3s var(--n-bezier);
 `, [cB("base-icon", "transition: transform .3s var(--n-bezier)"), cM("desc", [cB("base-icon", `
 transform: rotate(0deg);
 `)]), cM("asc", [cB("base-icon", `
 transform: rotate(-180deg);
 `)]), cM("asc, desc", `
 color: var(--n-th-icon-color-active);
 `)]), cB("data-table-resize-button", `
 width: var(--n-resizable-container-size);
 position: absolute;
 top: 0;
 right: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 cursor: col-resize;
 user-select: none;
 `, [c$1("&::after", `
 width: var(--n-resizable-size);
 height: 50%;
 position: absolute;
 top: 50%;
 left: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 background-color: var(--n-merged-border-color);
 transform: translateY(-50%);
 transition: background-color .3s var(--n-bezier);
 z-index: 1;
 content: '';
 `), cM("active", [c$1("&::after", ` 
 background-color: var(--n-th-icon-color-active);
 `)]), c$1("&:hover::after", `
 background-color: var(--n-th-icon-color-active);
 `)]), cB("data-table-filter", `
 position: absolute;
 z-index: auto;
 right: 0;
 width: 36px;
 top: 0;
 bottom: 0;
 cursor: pointer;
 display: flex;
 justify-content: center;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: var(--n-filter-size);
 color: var(--n-th-icon-color);
 `, [c$1("&:hover", `
 background-color: var(--n-th-button-color-hover);
 `), cM("show", `
 background-color: var(--n-th-button-color-hover);
 `), cM("active", `
 background-color: var(--n-th-button-color-hover);
 color: var(--n-th-icon-color-active);
 `)])]), cB("data-table-td", `
 padding: var(--n-td-padding);
 text-align: start;
 box-sizing: border-box;
 border: none;
 background-color: var(--n-merged-td-color);
 color: var(--n-td-text-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cM("expand", [cB("data-table-expand-trigger", `
 margin-right: 0;
 `)]), cM("last-row", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [
      // make sure there is no overlap between bottom border and
      // fixed column box shadow
      c$1("&::after", `
 bottom: 0 !important;
 `),
      c$1("&::before", `
 bottom: 0 !important;
 `)
    ]), cM("summary", `
 background-color: var(--n-merged-th-color);
 `), cM("hover", `
 background-color: var(--n-merged-td-color-hover);
 `), cE("ellipsis", `
 display: inline-block;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 vertical-align: bottom;
 `), cM("selection, expand", `
 text-align: center;
 padding: 0;
 line-height: 0;
 `), fixedColumnStyle]), cB("data-table-empty", `
 box-sizing: border-box;
 padding: var(--n-empty-padding);
 flex-grow: 1;
 flex-shrink: 0;
 opacity: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: opacity .3s var(--n-bezier);
 `, [cM("hide", `
 opacity: 0;
 `)]), cE("pagination", `
 margin: var(--n-pagination-margin);
 display: flex;
 justify-content: flex-end;
 `), cB("data-table-wrapper", `
 position: relative;
 opacity: 1;
 transition: opacity .3s var(--n-bezier), border-color .3s var(--n-bezier);
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 line-height: var(--n-line-height);
 `), cM("loading", [cB("data-table-wrapper", `
 opacity: var(--n-opacity-loading);
 pointer-events: none;
 `)]), cM("single-column", [cB("data-table-td", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [c$1("&::after, &::before", `
 bottom: 0 !important;
 `)])]), cNotM("single-line", [cB("data-table-th", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last", `
 border-right: 0 solid var(--n-merged-border-color);
 `)]), cB("data-table-td", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last-col", `
 border-right: 0 solid var(--n-merged-border-color);
 `)])]), cM("bordered", [cB("data-table-wrapper", `
 border: 1px solid var(--n-merged-border-color);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 overflow: hidden;
 `)]), cB("data-table-base-table", [cM("transition-disabled", [cB("data-table-th", [c$1("&::after, &::before", "transition: none;")]), cB("data-table-td", [c$1("&::after, &::before", "transition: none;")])])]), cM("bottom-bordered", [cB("data-table-td", [cM("last-row", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)])]), cB("data-table-table", `
 font-variant-numeric: tabular-nums;
 width: 100%;
 word-break: break-word;
 transition: background-color .3s var(--n-bezier);
 border-collapse: separate;
 border-spacing: 0;
 background-color: var(--n-merged-td-color);
 `), cB("data-table-base-table-header", `
 border-top-left-radius: calc(var(--n-border-radius) - 1px);
 border-top-right-radius: calc(var(--n-border-radius) - 1px);
 z-index: 3;
 overflow: scroll;
 flex-shrink: 0;
 transition: border-color .3s var(--n-bezier);
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar", `
 width: 0;
 height: 0;
 `)]), cB("data-table-check-extra", `
 transition: color .3s var(--n-bezier);
 color: var(--n-th-icon-color);
 position: absolute;
 font-size: 14px;
 right: -4px;
 top: 50%;
 transform: translateY(-50%);
 z-index: 1;
 `)]), cB("data-table-filter-menu", [cB("scrollbar", `
 max-height: 240px;
 `), cE("group", `
 display: flex;
 flex-direction: column;
 padding: 12px 12px 0 12px;
 `, [cB("checkbox", `
 margin-bottom: 12px;
 margin-right: 0;
 `), cB("radio", `
 margin-bottom: 12px;
 margin-right: 0;
 `)]), cE("action", `
 padding: var(--n-action-padding);
 display: flex;
 flex-wrap: nowrap;
 justify-content: space-evenly;
 border-top: 1px solid var(--n-action-divider-color);
 `, [cB("button", [c$1("&:not(:last-child)", `
 margin: var(--n-action-button-margin);
 `), c$1("&:last-child", `
 margin-right: 0;
 `)])]), cB("divider", `
 margin: 0 !important;
 `)]), insideModal(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 --n-merged-th-color-hover: var(--n-th-color-hover-modal);
 --n-merged-td-color-hover: var(--n-td-color-hover-modal);
 --n-merged-td-color-striped: var(--n-td-color-striped-modal);
 `)), insidePopover(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 --n-merged-th-color-hover: var(--n-th-color-hover-popover);
 --n-merged-td-color-hover: var(--n-td-color-hover-popover);
 --n-merged-td-color-striped: var(--n-td-color-striped-popover);
 `))]);
    function createFixedColumnStyle() {
      return [cM("fixed-left", `
 left: 0;
 position: sticky;
 z-index: 2;
 `, [c$1("&::after", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 right: -36px;
 `)]), cM("fixed-right", `
 right: 0;
 position: sticky;
 z-index: 1;
 `, [c$1("&::before", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 left: -36px;
 `)])];
    }
    const NDataTable = defineComponent({
      name: "DataTable",
      alias: ["AdvancedTable"],
      props: dataTableProps,
      setup(props, { slots }) {
        const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const mergedBottomBorderedRef = computed(() => {
          const { bottomBordered } = props;
          if (mergedBorderedRef.value)
            return false;
          if (bottomBordered !== void 0)
            return bottomBordered;
          return true;
        });
        const themeRef = useTheme("DataTable", "-data-table", style$4, dataTableLight$1, props, mergedClsPrefixRef);
        const bodyWidthRef = ref(null);
        const scrollPartRef = ref("body");
        onDeactivated(() => {
          scrollPartRef.value = "body";
        });
        const mainTableInstRef = ref(null);
        const { getResizableWidth, clearResizableWidth, doUpdateResizableWidth } = useResizable();
        const { rowsRef, colsRef, dataRelatedColsRef, hasEllipsisRef } = useGroupHeader(props, getResizableWidth);
        const { treeMateRef, mergedCurrentPageRef, paginatedDataRef, rawPaginatedDataRef, selectionColumnRef, hoverKeyRef, mergedPaginationRef, mergedFilterStateRef, mergedSortStateRef, childTriggerColIndexRef, doUpdatePage, doUpdateFilters, onUnstableColumnResize, deriveNextSorter, filter, filters, clearFilter, clearFilters, clearSorter, page, sort } = useTableData(props, { dataRelatedColsRef });
        const { doCheckAll, doUncheckAll, doCheck, doUncheck, headerCheckboxDisabledRef, someRowsCheckedRef, allRowsCheckedRef, mergedCheckedRowKeySetRef, mergedInderminateRowKeySetRef } = useCheck(props, {
          selectionColumnRef,
          treeMateRef,
          paginatedDataRef
        });
        const { stickyExpandedRowsRef, mergedExpandedRowKeysRef, renderExpandRef, expandableRef, doUpdateExpandedRowKeys } = useExpand(props, treeMateRef);
        const { handleTableBodyScroll, handleTableHeaderScroll, syncScrollState, setHeaderScrollLeft, leftActiveFixedColKeyRef, leftActiveFixedChildrenColKeysRef, rightActiveFixedColKeyRef, rightActiveFixedChildrenColKeysRef, leftFixedColumnsRef, rightFixedColumnsRef, fixedColumnLeftMapRef, fixedColumnRightMapRef } = useScroll(props, {
          scrollPartRef,
          bodyWidthRef,
          mainTableInstRef,
          mergedCurrentPageRef
        });
        const { localeRef } = useLocale("DataTable");
        const mergedTableLayoutRef = computed(() => {
          if (props.virtualScroll || props.flexHeight || props.maxHeight !== void 0 || hasEllipsisRef.value) {
            return "fixed";
          }
          return props.tableLayout;
        });
        provide(dataTableInjectionKey, {
          props,
          treeMateRef,
          renderExpandIconRef: toRef(props, "renderExpandIcon"),
          loadingKeySetRef: ref(/* @__PURE__ */ new Set()),
          slots,
          indentRef: toRef(props, "indent"),
          childTriggerColIndexRef,
          bodyWidthRef,
          componentId: createId(),
          hoverKeyRef,
          mergedClsPrefixRef,
          mergedThemeRef: themeRef,
          scrollXRef: computed(() => props.scrollX),
          rowsRef,
          colsRef,
          paginatedDataRef,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          leftFixedColumnsRef,
          rightFixedColumnsRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          mergedCurrentPageRef,
          someRowsCheckedRef,
          allRowsCheckedRef,
          mergedSortStateRef,
          mergedFilterStateRef,
          loadingRef: toRef(props, "loading"),
          rowClassNameRef: toRef(props, "rowClassName"),
          mergedCheckedRowKeySetRef,
          mergedExpandedRowKeysRef,
          mergedInderminateRowKeySetRef,
          localeRef,
          scrollPartRef,
          expandableRef,
          stickyExpandedRowsRef,
          rowKeyRef: toRef(props, "rowKey"),
          renderExpandRef,
          summaryRef: toRef(props, "summary"),
          virtualScrollRef: toRef(props, "virtualScroll"),
          rowPropsRef: toRef(props, "rowProps"),
          stripedRef: toRef(props, "striped"),
          checkOptionsRef: computed(() => {
            const { value: selectionColumn } = selectionColumnRef;
            return selectionColumn === null || selectionColumn === void 0 ? void 0 : selectionColumn.options;
          }),
          rawPaginatedDataRef,
          filterMenuCssVarsRef: computed(() => {
            const { self: { actionDividerColor, actionPadding, actionButtonMargin } } = themeRef.value;
            return {
              "--n-action-padding": actionPadding,
              "--n-action-button-margin": actionButtonMargin,
              "--n-action-divider-color": actionDividerColor
            };
          }),
          onLoadRef: toRef(props, "onLoad"),
          mergedTableLayoutRef,
          maxHeightRef: toRef(props, "maxHeight"),
          minHeightRef: toRef(props, "minHeight"),
          flexHeightRef: toRef(props, "flexHeight"),
          headerCheckboxDisabledRef,
          paginationBehaviorOnFilterRef: toRef(props, "paginationBehaviorOnFilter"),
          summaryPlacementRef: toRef(props, "summaryPlacement"),
          scrollbarPropsRef: toRef(props, "scrollbarProps"),
          syncScrollState,
          doUpdatePage,
          doUpdateFilters,
          getResizableWidth,
          onUnstableColumnResize,
          clearResizableWidth,
          doUpdateResizableWidth,
          deriveNextSorter,
          doCheck,
          doUncheck,
          doCheckAll,
          doUncheckAll,
          doUpdateExpandedRowKeys,
          handleTableHeaderScroll,
          handleTableBodyScroll,
          setHeaderScrollLeft,
          renderCell: toRef(props, "renderCell")
        });
        const exposedMethods = {
          filter,
          filters,
          clearFilters,
          clearSorter,
          page,
          sort,
          clearFilter,
          scrollTo: (arg0, arg1) => {
            var _a;
            (_a = mainTableInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
          }
        };
        const cssVarsRef = computed(() => {
          const { size: size2 } = props;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { borderColor, tdColorHover, thColor, thColorHover, tdColor, tdTextColor, thTextColor, thFontWeight, thButtonColorHover, thIconColor, thIconColorActive, filterSize, borderRadius, lineHeight: lineHeight2, tdColorModal, thColorModal, borderColorModal, thColorHoverModal, tdColorHoverModal, borderColorPopover, thColorPopover, tdColorPopover, tdColorHoverPopover, thColorHoverPopover, paginationMargin, emptyPadding, boxShadowAfter, boxShadowBefore, sorterSize, resizableContainerSize, resizableSize, loadingColor, loadingSize, opacityLoading, tdColorStriped, tdColorStripedModal, tdColorStripedPopover, [createKey("fontSize", size2)]: fontSize2, [createKey("thPadding", size2)]: thPadding, [createKey("tdPadding", size2)]: tdPadding } } = themeRef.value;
          return {
            "--n-font-size": fontSize2,
            "--n-th-padding": thPadding,
            "--n-td-padding": tdPadding,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-border-radius": borderRadius,
            "--n-line-height": lineHeight2,
            "--n-border-color": borderColor,
            "--n-border-color-modal": borderColorModal,
            "--n-border-color-popover": borderColorPopover,
            "--n-th-color": thColor,
            "--n-th-color-hover": thColorHover,
            "--n-th-color-modal": thColorModal,
            "--n-th-color-hover-modal": thColorHoverModal,
            "--n-th-color-popover": thColorPopover,
            "--n-th-color-hover-popover": thColorHoverPopover,
            "--n-td-color": tdColor,
            "--n-td-color-hover": tdColorHover,
            "--n-td-color-modal": tdColorModal,
            "--n-td-color-hover-modal": tdColorHoverModal,
            "--n-td-color-popover": tdColorPopover,
            "--n-td-color-hover-popover": tdColorHoverPopover,
            "--n-th-text-color": thTextColor,
            "--n-td-text-color": tdTextColor,
            "--n-th-font-weight": thFontWeight,
            "--n-th-button-color-hover": thButtonColorHover,
            "--n-th-icon-color": thIconColor,
            "--n-th-icon-color-active": thIconColorActive,
            "--n-filter-size": filterSize,
            "--n-pagination-margin": paginationMargin,
            "--n-empty-padding": emptyPadding,
            "--n-box-shadow-before": boxShadowBefore,
            "--n-box-shadow-after": boxShadowAfter,
            "--n-sorter-size": sorterSize,
            "--n-resizable-container-size": resizableContainerSize,
            "--n-resizable-size": resizableSize,
            "--n-loading-size": loadingSize,
            "--n-loading-color": loadingColor,
            "--n-opacity-loading": opacityLoading,
            "--n-td-color-striped": tdColorStriped,
            "--n-td-color-striped-modal": tdColorStripedModal,
            "--n-td-color-striped-popover": tdColorStripedPopover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("data-table", computed(() => props.size[0]), cssVarsRef, props) : void 0;
        const mergedShowPaginationRef = computed(() => {
          if (!props.pagination)
            return false;
          if (props.paginateSinglePage)
            return true;
          const mergedPagination = mergedPaginationRef.value;
          const { pageCount } = mergedPagination;
          if (pageCount !== void 0)
            return pageCount > 1;
          return mergedPagination.itemCount && mergedPagination.pageSize && mergedPagination.itemCount > mergedPagination.pageSize;
        });
        return Object.assign({ mainTableInstRef, mergedClsPrefix: mergedClsPrefixRef, mergedTheme: themeRef, paginatedData: paginatedDataRef, mergedBordered: mergedBorderedRef, mergedBottomBordered: mergedBottomBorderedRef, mergedPagination: mergedPaginationRef, mergedShowPagination: mergedShowPaginationRef, cssVars: inlineThemeDisabled ? void 0 : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);
      },
      render() {
        const { mergedClsPrefix, themeClass, onRender, $slots, spinProps } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h(
          "div",
          { class: [
            `${mergedClsPrefix}-data-table`,
            themeClass,
            {
              [`${mergedClsPrefix}-data-table--bordered`]: this.mergedBordered,
              [`${mergedClsPrefix}-data-table--bottom-bordered`]: this.mergedBottomBordered,
              [`${mergedClsPrefix}-data-table--single-line`]: this.singleLine,
              [`${mergedClsPrefix}-data-table--single-column`]: this.singleColumn,
              [`${mergedClsPrefix}-data-table--loading`]: this.loading,
              [`${mergedClsPrefix}-data-table--flex-height`]: this.flexHeight
            }
          ], style: this.cssVars },
          h(
            "div",
            { class: `${mergedClsPrefix}-data-table-wrapper` },
            h(MainTable, { ref: "mainTableInstRef" })
          ),
          this.mergedShowPagination ? h(
            "div",
            { class: `${mergedClsPrefix}-data-table__pagination` },
            h(NPagination, Object.assign({ theme: this.mergedTheme.peers.Pagination, themeOverrides: this.mergedTheme.peerOverrides.Pagination, disabled: this.loading }, this.mergedPagination))
          ) : null,
          h(Transition, { name: "fade-in-scale-up-transition" }, {
            default: () => {
              return this.loading ? h("div", { class: `${mergedClsPrefix}-data-table-loading-wrapper` }, resolveSlot($slots.loading, () => [
                h(NBaseLoading, Object.assign({ clsPrefix: mergedClsPrefix, strokeWidth: 20 }, spinProps))
              ])) : null;
            }
          })
        );
      }
    });
    const commonVariables$1 = {
      actionMargin: "0 0 0 20px",
      actionMarginRtl: "0 20px 0 0"
    };
    const self$3 = () => {
      return commonVariables$1;
    };
    const dynamicInputLight = createTheme({
      name: "DynamicInput",
      common: commonLight,
      peers: {
        Input: inputLight$1,
        Button: buttonLight$1
      },
      self: self$3
    });
    const dynamicInputLight$1 = dynamicInputLight;
    const dynamicInputInjectionKey = createInjectionKey("n-dynamic-input");
    const NDynamicInputInputPreset = defineComponent({
      name: "DynamicInputInputPreset",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        value: {
          type: String,
          default: ""
        },
        parentPath: String,
        path: String,
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup() {
        const {
          mergedThemeRef,
          placeholderRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(dynamicInputInjectionKey);
        return {
          mergedTheme: mergedThemeRef,
          placeholder: placeholderRef
        };
      },
      render() {
        const { mergedTheme, placeholder, value, clsPrefix, onUpdateValue } = this;
        return h(
          "div",
          { class: `${clsPrefix}-dynamic-input-preset-input` },
          h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value, placeholder, onUpdateValue })
        );
      }
    });
    const NDynamicInputPairPreset = defineComponent({
      name: "DynamicInputPairPreset",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        value: {
          type: Object,
          default: () => ({
            key: "",
            value: ""
          })
        },
        parentPath: String,
        path: String,
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const { mergedThemeRef, keyPlaceholderRef, valuePlaceholderRef } = inject(dynamicInputInjectionKey);
        return {
          mergedTheme: mergedThemeRef,
          keyPlaceholder: keyPlaceholderRef,
          valuePlaceholder: valuePlaceholderRef,
          handleKeyInput(key) {
            props.onUpdateValue({
              key,
              value: props.value.value
            });
          },
          handleValueInput(value) {
            props.onUpdateValue({
              key: props.value.key,
              value
            });
          }
        };
      },
      render() {
        const { mergedTheme, keyPlaceholder, valuePlaceholder, value, clsPrefix } = this;
        return h(
          "div",
          { class: `${clsPrefix}-dynamic-input-preset-pair` },
          h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.key, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: keyPlaceholder, onUpdateValue: this.handleKeyInput }),
          h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.value, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: valuePlaceholder, onUpdateValue: this.handleValueInput })
        );
      }
    });
    const style$3 = cB("dynamic-input", {
      width: "100%"
    }, [cB("dynamic-input-item", `
 margin-bottom: 10px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB("dynamic-input-preset-input", {
      flex: 1,
      alignItems: "center"
    }), cB("dynamic-input-preset-pair", `
 flex: 1;
 display: flex;
 align-items: center;
 `, [cB("dynamic-input-pair-input", [c$1("&:first-child", {
      "margin-right": "12px"
    })])]), cE("action", `
 align-self: flex-start;
 display: flex;
 justify-content: flex-end;
 flex-shrink: 0;
 flex-grow: 0;
 margin: var(--action-margin);
 `, [cM("icon", {
      cursor: "pointer"
    })]), c$1("&:last-child", {
      marginBottom: 0
    })]), cB("form-item", `
 padding-top: 0 !important;
 margin-right: 0 !important;
 `, [cB("form-item-blank", {
      paddingTop: "0 !important"
    })])]);
    const globalDataKeyMap = /* @__PURE__ */ new WeakMap();
    const dynamicInputProps = Object.assign(Object.assign({}, useTheme.props), {
      max: Number,
      min: {
        type: Number,
        default: 0
      },
      value: Array,
      // TODO: make it robust for different types
      defaultValue: {
        type: Array,
        default: () => []
      },
      preset: {
        type: String,
        default: "input"
      },
      keyField: String,
      itemStyle: [String, Object],
      // for preset pair
      keyPlaceholder: {
        type: String,
        default: ""
      },
      valuePlaceholder: {
        type: String,
        default: ""
      },
      // for preset input
      placeholder: {
        type: String,
        default: ""
      },
      showSortButton: Boolean,
      createButtonProps: Object,
      onCreate: Function,
      onRemove: Function,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      // deprecated
      onClear: Function,
      onInput: [Function, Array]
    });
    const NDynamicInput = defineComponent({
      name: "DynamicInput",
      props: dynamicInputProps,
      setup(props, { slots }) {
        const { mergedComponentPropsRef, mergedClsPrefixRef, mergedRtlRef, inlineThemeDisabled } = useConfig();
        const NFormItem2 = inject(formItemInjectionKey, null);
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const themeRef = useTheme("DynamicInput", "-dynamic-input", style$3, dynamicInputLight$1, props, mergedClsPrefixRef);
        const insertionDisabledRef = computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (Array.isArray(mergedValue)) {
            const { max } = props;
            return max !== void 0 && mergedValue.length >= max;
          }
          return false;
        });
        const removeDisabledRef = computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (Array.isArray(mergedValue))
            return mergedValue.length <= props.min;
          return true;
        });
        const buttonSizeRef = computed(() => {
          var _a, _b;
          return (_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DynamicInput) === null || _b === void 0 ? void 0 : _b.buttonSize;
        });
        function doUpdateValue(value) {
          const { onInput, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
          if (onInput)
            call(onInput, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onUpdateValue)
            call(onUpdateValue, value);
          uncontrolledValueRef.value = value;
        }
        function ensureKey(value, index) {
          if (value === void 0 || value === null)
            return index;
          if (typeof value !== "object")
            return index;
          const rawValue = isProxy(value) ? toRaw(value) : value;
          let key = globalDataKeyMap.get(rawValue);
          if (key === void 0) {
            globalDataKeyMap.set(rawValue, key = createId());
          }
          return key;
        }
        function handleValueChange(index, value) {
          const { value: mergedValue } = mergedValueRef;
          const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
          const originalItem = newValue[index];
          newValue[index] = value;
          if (originalItem && value && typeof originalItem === "object" && typeof value === "object") {
            const rawOriginal = isProxy(originalItem) ? toRaw(originalItem) : originalItem;
            const rawNew = isProxy(value) ? toRaw(value) : value;
            const originalKey = globalDataKeyMap.get(rawOriginal);
            if (originalKey !== void 0) {
              globalDataKeyMap.set(rawNew, originalKey);
            }
          }
          doUpdateValue(newValue);
        }
        function handleCreateClick() {
          createItem(0);
        }
        function createItem(index) {
          const { value: mergedValue } = mergedValueRef;
          const { onCreate } = props;
          const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
          if (onCreate) {
            newValue.splice(index + 1, 0, onCreate(index + 1));
            doUpdateValue(newValue);
          } else if (slots.default) {
            newValue.splice(index + 1, 0, null);
            doUpdateValue(newValue);
          } else {
            switch (props.preset) {
              case "input":
                newValue.splice(index + 1, 0, "");
                doUpdateValue(newValue);
                break;
              case "pair":
                newValue.splice(index + 1, 0, { key: "", value: "" });
                doUpdateValue(newValue);
                break;
            }
          }
        }
        function remove2(index) {
          const { value: mergedValue } = mergedValueRef;
          if (!Array.isArray(mergedValue))
            return;
          const { min } = props;
          if (mergedValue.length <= min)
            return;
          const newValue = Array.from(mergedValue);
          newValue.splice(index, 1);
          doUpdateValue(newValue);
          const { onRemove } = props;
          if (onRemove)
            onRemove(index);
        }
        function swap(array2, currentIndex, targetIndex) {
          if (currentIndex < 0 || targetIndex < 0 || currentIndex >= array2.length || targetIndex >= array2.length) {
            return;
          }
          if (currentIndex === targetIndex)
            return;
          const currentItem = array2[currentIndex];
          array2[currentIndex] = array2[targetIndex];
          array2[targetIndex] = currentItem;
        }
        function move2(type2, index) {
          const { value: mergedValue } = mergedValueRef;
          if (!Array.isArray(mergedValue))
            return;
          const newValue = Array.from(mergedValue);
          if (type2 === "up") {
            swap(newValue, index, index - 1);
          }
          if (type2 === "down") {
            swap(newValue, index, index + 1);
          }
          doUpdateValue(newValue);
        }
        provide(dynamicInputInjectionKey, {
          mergedThemeRef: themeRef,
          keyPlaceholderRef: toRef(props, "keyPlaceholder"),
          valuePlaceholderRef: toRef(props, "valuePlaceholder"),
          placeholderRef: toRef(props, "placeholder")
        });
        const rtlEnabledRef = useRtl("DynamicInput", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { self: { actionMargin, actionMarginRtl } } = themeRef.value;
          return {
            "--action-margin": actionMargin,
            "--action-margin-rtl": actionMarginRtl
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("dynamic-input", void 0, cssVarsRef, props) : void 0;
        return {
          locale: useLocale("DynamicInput").localeRef,
          rtlEnabled: rtlEnabledRef,
          buttonSize: buttonSizeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          NFormItem: NFormItem2,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          insertionDisabled: insertionDisabledRef,
          removeDisabled: removeDisabledRef,
          handleCreateClick,
          ensureKey,
          handleValueChange,
          remove: remove2,
          move: move2,
          createItem,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { $slots, buttonSize, mergedClsPrefix, mergedValue, locale: locale2, mergedTheme, keyField, itemStyle, preset, showSortButton, NFormItem: NFormItem2, ensureKey, handleValueChange, remove: remove2, createItem, move: move2, onRender } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h("div", { class: [
          `${mergedClsPrefix}-dynamic-input`,
          this.rtlEnabled && `${mergedClsPrefix}-dynamic-input--rtl`,
          this.themeClass
        ], style: this.cssVars }, !Array.isArray(mergedValue) || mergedValue.length === 0 ? h(NButton, Object.assign({ block: true, ghost: true, dashed: true, size: buttonSize }, this.createButtonProps, { disabled: this.insertionDisabled, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.handleCreateClick }), {
          default: () => resolveSlot($slots["create-button-default"], () => [
            locale2.create
          ]),
          icon: () => resolveSlot($slots["create-button-icon"], () => [
            h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(AddIcon, null) })
          ])
        }) : mergedValue.map((_, index) => h(
          "div",
          { key: keyField ? _[keyField] : ensureKey(_, index), "data-key": keyField ? _[keyField] : ensureKey(_, index), class: `${mergedClsPrefix}-dynamic-input-item`, style: itemStyle },
          resolveSlotWithProps($slots.default, {
            value: mergedValue[index],
            index
          }, () => {
            return [
              preset === "input" ? h(NDynamicInputInputPreset, { clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem2 ? NFormItem2.path.value : void 0, path: (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.path.value) ? `${NFormItem2.path.value}[${index}]` : void 0, onUpdateValue: (v) => handleValueChange(index, v) }) : preset === "pair" ? h(NDynamicInputPairPreset, { clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem2 ? NFormItem2.path.value : void 0, path: (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.path.value) ? `${NFormItem2.path.value}[${index}]` : void 0, onUpdateValue: (v) => handleValueChange(index, v) }) : null
            ];
          }),
          h(
            "div",
            { class: `${mergedClsPrefix}-dynamic-input-item__action` },
            h(NButtonGroup, { size: buttonSize }, {
              default: () => [
                h(NButton, { disabled: this.removeDisabled, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, circle: true, onClick: () => remove2(index) }, {
                  icon: () => h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(RemoveIcon, null) })
                }),
                h(NButton, { disabled: this.insertionDisabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => createItem(index) }, {
                  icon: () => h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(AddIcon, null) })
                }),
                showSortButton ? h(NButton, { disabled: index === 0, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => move2("up", index) }, {
                  icon: () => h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                    default: () => h(ArrowUpIcon, null)
                  })
                }) : null,
                showSortButton ? h(NButton, { disabled: index === mergedValue.length - 1, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => move2("down", index) }, {
                  icon: () => h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(ArrowDownIcon, null) })
                }) : null
              ]
            })
          )
        )));
      }
    });
    const commonVariables = {
      feedbackPadding: "4px 0 0 2px",
      feedbackHeightSmall: "24px",
      feedbackHeightMedium: "24px",
      feedbackHeightLarge: "26px",
      feedbackFontSizeSmall: "13px",
      feedbackFontSizeMedium: "14px",
      feedbackFontSizeLarge: "14px",
      labelFontSizeLeftSmall: "14px",
      labelFontSizeLeftMedium: "14px",
      labelFontSizeLeftLarge: "15px",
      labelFontSizeTopSmall: "13px",
      labelFontSizeTopMedium: "14px",
      labelFontSizeTopLarge: "14px",
      labelHeightSmall: "24px",
      labelHeightMedium: "26px",
      labelHeightLarge: "28px",
      labelPaddingVertical: "0 0 6px 2px",
      labelPaddingHorizontal: "0 12px 0 0",
      labelTextAlignVertical: "left",
      labelTextAlignHorizontal: "right",
      labelFontWeight: "400"
    };
    const self$2 = (vars) => {
      const { heightSmall, heightMedium, heightLarge, textColor1, errorColor, warningColor, lineHeight: lineHeight2, textColor3 } = vars;
      return Object.assign(Object.assign({}, commonVariables), { blankHeightSmall: heightSmall, blankHeightMedium: heightMedium, blankHeightLarge: heightLarge, lineHeight: lineHeight2, labelTextColor: textColor1, asteriskColor: errorColor, feedbackTextColorError: errorColor, feedbackTextColorWarning: warningColor, feedbackTextColor: textColor3 });
    };
    const formLight = {
      name: "Form",
      common: commonLight,
      self: self$2
    };
    const formLight$1 = formLight;
    const style$2 = cB("form", [cM("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
      width: "auto",
      marginRight: "18px"
    }, [c$1("&:last-child", {
      marginRight: 0
    })])])]);
    const formInjectionKey = createInjectionKey("n-form");
    const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
    var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formProps = Object.assign(Object.assign({}, useTheme.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: {
      type: String,
      default: "top"
    }, model: {
      type: Object,
      default: () => {
      }
    }, rules: Object, disabled: Boolean, size: String, showRequireMark: {
      type: Boolean,
      default: void 0
    }, requireMarkPlacement: String, showFeedback: {
      type: Boolean,
      default: true
    }, onSubmit: {
      type: Function,
      default: (e) => e.preventDefault()
    }, showLabel: {
      type: Boolean,
      default: void 0
    }, validateMessages: Object });
    const NForm = defineComponent({
      name: "Form",
      props: formProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        useTheme("Form", "-form", style$2, formLight$1, props, mergedClsPrefixRef);
        const formItems = {};
        const maxChildLabelWidthRef = ref(void 0);
        const deriveMaxChildLabelWidth = (currentWidth) => {
          const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
          if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
            maxChildLabelWidthRef.value = currentWidth;
          }
        };
        function validate(validateCallback, shouldRuleBeApplied = () => true) {
          return __awaiter$1(this, void 0, void 0, function* () {
            return yield new Promise((resolve2, reject) => {
              const formItemValidationPromises = [];
              for (const key of keysOf(formItems)) {
                const formItemInstances = formItems[key];
                for (const formItemInstance of formItemInstances) {
                  if (formItemInstance.path) {
                    formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                  }
                }
              }
              void Promise.all(formItemValidationPromises).then((results) => {
                if (results.some((result) => !result.valid)) {
                  const errors = results.filter((result) => result.errors).map((result) => result.errors);
                  if (validateCallback) {
                    validateCallback(errors);
                  }
                  reject(errors);
                } else {
                  if (validateCallback)
                    validateCallback();
                  resolve2();
                }
              });
            });
          });
        }
        function restoreValidation() {
          for (const key of keysOf(formItems)) {
            const formItemInstances = formItems[key];
            for (const formItemInstance of formItemInstances) {
              formItemInstance.restoreValidation();
            }
          }
        }
        provide(formInjectionKey, {
          props,
          maxChildLabelWidthRef,
          deriveMaxChildLabelWidth
        });
        provide(formItemInstsInjectionKey, { formItems });
        const formExposedMethod = {
          validate,
          restoreValidation
        };
        return Object.assign(formExposedMethod, {
          mergedClsPrefix: mergedClsPrefixRef
        });
      },
      render() {
        const { mergedClsPrefix } = this;
        return h("form", { class: [
          `${mergedClsPrefix}-form`,
          this.inline && `${mergedClsPrefix}-form--inline`
        ], onSubmit: this.onSubmit }, this.$slots);
      }
    });
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper2);
        }
        function Wrapper2() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper2.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper2,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper2, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    if (typeof process !== "undefined" && process.env && false) {
      warning = function warning2(type2, errors) {
        if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
          if (errors.every(function(e) {
            return typeof e === "string";
          })) {
            console.warn(type2, errors);
          }
        }
      };
    }
    function convertFieldsError(errors) {
      if (!errors || !errors.length)
        return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len2 = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x) {
          if (x === "%%") {
            return "%";
          }
          if (i >= len2) {
            return x;
          }
          switch (x) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type2) {
      return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
    }
    function isEmptyValue(value, type2) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type2 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type2) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v = value;
      for (var i = 0; i < path.length; i++) {
        if (v == void 0) {
          return v;
        }
        v = v[path[i]];
      }
      return v;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required2(rule, value, source, errors, options, type2) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b = function b2(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip = function ip2(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
      };
      ip.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
      };
      ip.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer2(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float2(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array2(value) {
        return Array.isArray(value);
      },
      regexp: function regexp2(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date2(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number2(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object2(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method2(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex2(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type2(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len2 = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len2) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern2(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method = function method2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number = function number2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp = function regexp2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer = function integer2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array = function array2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object = function object2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable = function enumerable2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern = function pattern2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date = function date2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required = function required2(rule, value, callback, source, options) {
      var errors = [];
      var type2 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type2);
      callback(errors);
    };
    var type = function type2(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators = {
      string,
      method,
      number,
      "boolean": _boolean,
      regexp,
      integer,
      "float": floatFn,
      array,
      object,
      "enum": enumerable,
      pattern,
      date,
      url: type,
      hex: type,
      email: type,
      required,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o, oc) {
        var _this2 = this;
        if (o === void 0) {
          o = {};
        }
        if (oc === void 0) {
          oc = function oc2() {
          };
        }
        var source = source_;
        var options = o;
        var callback = oc;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add2(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add2(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb(error.message);
            }
            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb();
            }, function(e) {
              return cb(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType2(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type2, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type2] = validator;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators;
    function formItemSize(props) {
      const NForm2 = inject(formInjectionKey, null);
      return {
        mergedSize: computed(() => {
          if (props.size !== void 0)
            return props.size;
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.size) !== void 0)
            return NForm2.props.size;
          return "medium";
        })
      };
    }
    function formItemMisc(props) {
      const NForm2 = inject(formInjectionKey, null);
      const mergedLabelPlacementRef = computed(() => {
        const { labelPlacement } = props;
        if (labelPlacement !== void 0)
          return labelPlacement;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelPlacement)
          return NForm2.props.labelPlacement;
        return "top";
      });
      const isAutoLabelWidthRef = computed(() => {
        return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) === "auto");
      });
      const mergedLabelWidthRef = computed(() => {
        if (mergedLabelPlacementRef.value === "top")
          return;
        const { labelWidth } = props;
        if (labelWidth !== void 0 && labelWidth !== "auto") {
          return formatLength(labelWidth);
        }
        if (isAutoLabelWidthRef.value) {
          const autoComputedWidth = NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.maxChildLabelWidthRef.value;
          if (autoComputedWidth !== void 0) {
            return formatLength(autoComputedWidth);
          } else {
            return void 0;
          }
        }
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) !== void 0) {
          return formatLength(NForm2.props.labelWidth);
        }
        return void 0;
      });
      const mergedLabelAlignRef = computed(() => {
        const { labelAlign } = props;
        if (labelAlign)
          return labelAlign;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelAlign)
          return NForm2.props.labelAlign;
        return void 0;
      });
      const mergedLabelStyleRef = computed(() => {
        var _a;
        return [
          (_a = props.labelProps) === null || _a === void 0 ? void 0 : _a.style,
          props.labelStyle,
          {
            width: mergedLabelWidthRef.value
          }
        ];
      });
      const mergedShowRequireMarkRef = computed(() => {
        const { showRequireMark } = props;
        if (showRequireMark !== void 0)
          return showRequireMark;
        return NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showRequireMark;
      });
      const mergedRequireMarkPlacementRef = computed(() => {
        const { requireMarkPlacement } = props;
        if (requireMarkPlacement !== void 0)
          return requireMarkPlacement;
        return (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.requireMarkPlacement) || "right";
      });
      const validationErroredRef = ref(false);
      const mergedValidationStatusRef = computed(() => {
        const { validationStatus } = props;
        if (validationStatus !== void 0)
          return validationStatus;
        if (validationErroredRef.value)
          return "error";
        return void 0;
      });
      const mergedShowFeedbackRef = computed(() => {
        const { showFeedback } = props;
        if (showFeedback !== void 0)
          return showFeedback;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showFeedback) !== void 0)
          return NForm2.props.showFeedback;
        return true;
      });
      const mergedShowLabelRef = computed(() => {
        const { showLabel } = props;
        if (showLabel !== void 0)
          return showLabel;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showLabel) !== void 0)
          return NForm2.props.showLabel;
        return true;
      });
      return {
        validationErrored: validationErroredRef,
        mergedLabelStyle: mergedLabelStyleRef,
        mergedLabelPlacement: mergedLabelPlacementRef,
        mergedLabelAlign: mergedLabelAlignRef,
        mergedShowRequireMark: mergedShowRequireMarkRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
        mergedValidationStatus: mergedValidationStatusRef,
        mergedShowFeedback: mergedShowFeedbackRef,
        mergedShowLabel: mergedShowLabelRef,
        isAutoLabelWidth: isAutoLabelWidthRef
      };
    }
    function formItemRule(props) {
      const NForm2 = inject(formInjectionKey, null);
      const compatibleRulePathRef = computed(() => {
        const { rulePath } = props;
        if (rulePath !== void 0)
          return rulePath;
        const { path } = props;
        if (path !== void 0)
          return path;
        return void 0;
      });
      const mergedRulesRef = computed(() => {
        const rules2 = [];
        const { rule } = props;
        if (rule !== void 0) {
          if (Array.isArray(rule))
            rules2.push(...rule);
          else
            rules2.push(rule);
        }
        if (NForm2) {
          const { rules: formRules } = NForm2.props;
          const { value: rulePath } = compatibleRulePathRef;
          if (formRules !== void 0 && rulePath !== void 0) {
            const formRule = get(formRules, rulePath);
            if (formRule !== void 0) {
              if (Array.isArray(formRule)) {
                rules2.push(...formRule);
              } else {
                rules2.push(formRule);
              }
            }
          }
        }
        return rules2;
      });
      const hasRequiredRuleRef = computed(() => {
        return mergedRulesRef.value.some((rule) => rule.required);
      });
      const mergedRequiredRef = computed(() => {
        return hasRequiredRuleRef.value || props.required;
      });
      return {
        mergedRules: mergedRulesRef,
        mergedRequired: mergedRequiredRef
      };
    }
    const {
      cubicBezierEaseInOut
    } = commonVariables$d;
    function fadeDownTransition({
      name = "fade-down",
      fromOffset = "-4px",
      enterDuration = ".3s",
      leaveDuration = ".3s",
      enterCubicBezier = cubicBezierEaseInOut,
      leaveCubicBezier = cubicBezierEaseInOut
    } = {}) {
      return [c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0,
        transform: `translateY(${fromOffset})`
      }), c$1(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
        opacity: 1,
        transform: "translateY(0)"
      }), c$1(`&.${name}-transition-leave-active`, {
        transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
      }), c$1(`&.${name}-transition-enter-active`, {
        transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
      })];
    }
    const style$1 = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE("text", `
 grid-area: text; 
 `), cE("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c$1("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
      transition: "color .3s var(--n-bezier)",
      color: "var(--n-feedback-text-color)"
    }, [cM("warning", {
      color: "var(--n-feedback-text-color-warning)"
    }), cM("error", {
      color: "var(--n-feedback-text-color-error)"
    }), fadeDownTransition({
      fromOffset: "-3px",
      enterDuration: ".3s",
      leaveDuration: ".2s"
    })])])]);
    var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formItemProps = Object.assign(Object.assign({}, useTheme.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: {
      type: Boolean,
      default: void 0
    }, requireMarkPlacement: String, showFeedback: {
      type: Boolean,
      default: void 0
    }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, showLabel: {
      type: Boolean,
      default: void 0
    }, labelProps: Object });
    function wrapValidator(validator, async) {
      return (...args) => {
        try {
          const validateResult = validator(...args);
          if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || // Error[]
          (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
            return validateResult;
          } else if (validateResult === void 0) {
            return true;
          } else {
            warn$2("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ` + (async ? "`Promise`" : "`boolean`, `Error` or `Promise`") + " typed value instead.");
            return true;
          }
        } catch (err) {
          warn$2("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
          console.error(err);
          return void 0;
        }
      };
    }
    const NFormItem = defineComponent({
      name: "FormItem",
      props: formItemProps,
      setup(props) {
        useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", toRef(props, "path"));
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const NForm2 = inject(formInjectionKey, null);
        const formItemSizeRefs = formItemSize(props);
        const formItemMiscRefs = formItemMisc(props);
        const { validationErrored: validationErroredRef } = formItemMiscRefs;
        const { mergedRequired: mergedRequiredRef, mergedRules: mergedRulesRef } = formItemRule(props);
        const { mergedSize: mergedSizeRef } = formItemSizeRefs;
        const { mergedLabelPlacement: labelPlacementRef, mergedLabelAlign: labelTextAlignRef, mergedRequireMarkPlacement: mergedRequireMarkPlacementRef } = formItemMiscRefs;
        const renderExplainsRef = ref([]);
        const feedbackIdRef = ref(createId());
        const mergedDisabledRef = NForm2 ? toRef(NForm2.props, "disabled") : ref(false);
        const themeRef = useTheme("Form", "-form-item", style$1, formLight$1, props, mergedClsPrefixRef);
        watch(toRef(props, "path"), () => {
          if (props.ignorePathChange)
            return;
          restoreValidation();
        });
        function restoreValidation() {
          renderExplainsRef.value = [];
          validationErroredRef.value = false;
          if (props.feedback) {
            feedbackIdRef.value = createId();
          }
        }
        function handleContentBlur() {
          void internalValidate("blur");
        }
        function handleContentChange() {
          void internalValidate("change");
        }
        function handleContentFocus() {
          void internalValidate("focus");
        }
        function handleContentInput() {
          void internalValidate("input");
        }
        function validate(options, callback) {
          return __awaiter(this, void 0, void 0, function* () {
            let trigger2;
            let validateCallback;
            let shouldRuleBeApplied;
            let asyncValidatorOptions;
            if (typeof options === "string") {
              trigger2 = options;
              validateCallback = callback;
            } else if (options !== null && typeof options === "object") {
              trigger2 = options.trigger;
              validateCallback = options.callback;
              shouldRuleBeApplied = options.shouldRuleBeApplied;
              asyncValidatorOptions = options.options;
            }
            return yield new Promise((resolve2, reject) => {
              void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({ valid, errors }) => {
                if (valid) {
                  if (validateCallback) {
                    validateCallback();
                  }
                  resolve2();
                } else {
                  if (validateCallback) {
                    validateCallback(errors);
                  }
                  reject(errors);
                }
              });
            });
          });
        }
        const internalValidate = (trigger2 = null, shouldRuleBeApplied = () => true, options = {
          suppressWarning: true
        }) => __awaiter(this, void 0, void 0, function* () {
          const { path } = props;
          if (!options) {
            options = {};
          } else {
            if (!options.first)
              options.first = props.first;
          }
          const { value: rules2 } = mergedRulesRef;
          const value = NForm2 ? get(NForm2.props.model, path || "") : void 0;
          const messageRenderers = {};
          const originalMessageRendersMessage = {};
          const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          })).filter(shouldRuleBeApplied).map((rule, i) => {
            const shallowClonedRule = Object.assign({}, rule);
            if (shallowClonedRule.validator) {
              shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
            }
            if (shallowClonedRule.asyncValidator) {
              shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
            }
            if (shallowClonedRule.renderMessage) {
              const rendererKey = `__renderMessage__${i}`;
              originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
              shallowClonedRule.message = rendererKey;
              messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
            }
            return shallowClonedRule;
          });
          if (!activeRules.length) {
            return {
              valid: true
            };
          }
          const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
          const validator = new Schema({ [mergedPath]: activeRules });
          const { validateMessages } = (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props) || {};
          if (validateMessages) {
            validator.messages(validateMessages);
          }
          return yield new Promise((resolve2) => {
            void validator.validate({ [mergedPath]: value }, options, (errors) => {
              if (errors === null || errors === void 0 ? void 0 : errors.length) {
                renderExplainsRef.value = errors.map((error) => {
                  const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
                  return {
                    key: transformedMessage,
                    render: () => {
                      if (transformedMessage.startsWith("__renderMessage__")) {
                        return messageRenderers[transformedMessage]();
                      }
                      return transformedMessage;
                    }
                  };
                });
                errors.forEach((error) => {
                  var _a;
                  if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith("__renderMessage__")) {
                    error.message = originalMessageRendersMessage[error.message];
                  }
                });
                validationErroredRef.value = true;
                resolve2({
                  valid: false,
                  errors
                });
              } else {
                restoreValidation();
                resolve2({
                  valid: true
                });
              }
            });
          });
        });
        provide(formItemInjectionKey, {
          path: toRef(props, "path"),
          disabled: mergedDisabledRef,
          mergedSize: formItemSizeRefs.mergedSize,
          mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
          restoreValidation,
          handleContentBlur,
          handleContentChange,
          handleContentFocus,
          handleContentInput
        });
        const exposedRef = {
          validate,
          restoreValidation,
          internalValidate
        };
        const labelElementRef = ref(null);
        onMounted(() => {
          if (!formItemMiscRefs.isAutoLabelWidth.value)
            return;
          const labelElement = labelElementRef.value;
          if (labelElement !== null) {
            const memoizedWhitespace = labelElement.style.whiteSpace;
            labelElement.style.whiteSpace = "nowrap";
            labelElement.style.width = "";
            NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
            labelElement.style.whiteSpace = memoizedWhitespace;
          }
        });
        const cssVarsRef = computed(() => {
          var _a;
          const { value: size2 } = mergedSizeRef;
          const { value: labelPlacement } = labelPlacementRef;
          const direction = labelPlacement === "top" ? "vertical" : "horizontal";
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { labelTextColor, asteriskColor, lineHeight: lineHeight2, feedbackTextColor, feedbackTextColorWarning, feedbackTextColorError, feedbackPadding, labelFontWeight, [createKey("labelHeight", size2)]: labelHeight, [createKey("blankHeight", size2)]: blankHeight, [createKey("feedbackFontSize", size2)]: feedbackFontSize, [createKey("feedbackHeight", size2)]: feedbackHeight, [createKey("labelPadding", direction)]: labelPadding, [createKey("labelTextAlign", direction)]: labelTextAlign, [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize } } = themeRef.value;
          let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
          if (labelPlacement === "top") {
            mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
          }
          const cssVars = {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-line-height": lineHeight2,
            "--n-blank-height": blankHeight,
            "--n-label-font-size": labelFontSize,
            "--n-label-text-align": mergedLabelTextAlign,
            "--n-label-height": labelHeight,
            "--n-label-padding": labelPadding,
            "--n-label-font-weight": labelFontWeight,
            "--n-asterisk-color": asteriskColor,
            "--n-label-text-color": labelTextColor,
            "--n-feedback-padding": feedbackPadding,
            "--n-feedback-font-size": feedbackFontSize,
            "--n-feedback-height": feedbackHeight,
            "--n-feedback-text-color": feedbackTextColor,
            "--n-feedback-text-color-warning": feedbackTextColorWarning,
            "--n-feedback-text-color-error": feedbackTextColorError
          };
          return cssVars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", computed(() => {
          var _a;
          return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a = labelTextAlignRef.value) === null || _a === void 0 ? void 0 : _a[0]) || ""}`;
        }), cssVarsRef, props) : void 0;
        const reverseColSpaceRef = computed(() => {
          return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
        });
        return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef, mergedClsPrefix: mergedClsPrefixRef, mergedRequired: mergedRequiredRef, feedbackId: feedbackIdRef, renderExplains: renderExplainsRef, reverseColSpace: reverseColSpaceRef }, formItemMiscRefs), formItemSizeRefs), exposedRef), { cssVars: inlineThemeDisabled ? void 0 : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
        const { $slots, mergedClsPrefix, mergedShowLabel, mergedShowRequireMark, mergedRequireMarkPlacement, onRender } = this;
        const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const renderLabel = () => {
          const labelText = this.$slots.label ? this.$slots.label() : this.label;
          if (!labelText)
            return null;
          const textNode = h("span", { class: `${mergedClsPrefix}-form-item-label__text` }, labelText);
          const markNode = renderedShowRequireMark ? h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk` }, mergedRequireMarkPlacement !== "left" ? " *" : "* ") : mergedRequireMarkPlacement === "right-hanging" && h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder` }, " *");
          const { labelProps } = this;
          return h("label", Object.assign({}, labelProps, { class: [
            labelProps === null || labelProps === void 0 ? void 0 : labelProps.class,
            `${mergedClsPrefix}-form-item-label`,
            `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`,
            this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`
          ], style: this.mergedLabelStyle, ref: "labelElementRef" }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
        };
        return h(
          "div",
          { class: [
            `${mergedClsPrefix}-form-item`,
            this.themeClass,
            `${mergedClsPrefix}-form-item--${this.mergedSize}-size`,
            `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`,
            this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`,
            !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`
          ], style: this.cssVars },
          mergedShowLabel && renderLabel(),
          h("div", { class: [
            `${mergedClsPrefix}-form-item-blank`,
            this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`
          ] }, $slots),
          this.mergedShowFeedback ? h(
            "div",
            { key: this.feedbackId, class: `${mergedClsPrefix}-form-item-feedback-wrapper` },
            h(Transition, { name: "fade-down-transition", mode: "out-in" }, {
              default: () => {
                const { mergedValidationStatus } = this;
                return resolveWrappedSlot($slots.feedback, (children) => {
                  var _a;
                  const { feedback } = this;
                  const feedbackNodes = children || feedback ? h("div", { key: "__feedback__", class: `${mergedClsPrefix}-form-item-feedback__line` }, children || feedback) : this.renderExplains.length ? (_a = this.renderExplains) === null || _a === void 0 ? void 0 : _a.map(({ key, render: render2 }) => h("div", { key, class: `${mergedClsPrefix}-form-item-feedback__line` }, render2())) : null;
                  return feedbackNodes ? mergedValidationStatus === "warning" ? h("div", { key: "controlled-warning", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning` }, feedbackNodes) : mergedValidationStatus === "error" ? h("div", { key: "controlled-error", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error` }, feedbackNodes) : mergedValidationStatus === "success" ? h("div", { key: "controlled-success", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success` }, feedbackNodes) : h("div", { key: "controlled-default", class: `${mergedClsPrefix}-form-item-feedback` }, feedbackNodes) : null;
                });
              }
            })
          ) : null
        );
      }
    });
    const sizeVariables = {
      tabFontSizeSmall: "14px",
      tabFontSizeMedium: "14px",
      tabFontSizeLarge: "16px",
      tabGapSmallLine: "36px",
      tabGapMediumLine: "36px",
      tabGapLargeLine: "36px",
      tabPaddingSmallLine: "6px 0",
      tabPaddingMediumLine: "10px 0",
      tabPaddingLargeLine: "14px 0",
      tabPaddingVerticalSmallLine: "0 6px",
      tabPaddingVerticalMediumLine: "0 10px",
      tabPaddingVerticalLargeLine: "0 14px",
      tabGapSmallBar: "36px",
      tabGapMediumBar: "36px",
      tabGapLargeBar: "36px",
      tabPaddingSmallBar: "4px 0",
      tabPaddingMediumBar: "6px 0",
      tabPaddingLargeBar: "10px 0",
      tabPaddingVerticalSmallBar: "0 4px",
      tabPaddingVerticalMediumBar: "0 6px ",
      tabPaddingVerticalLargeBar: "0 10px ",
      tabGapSmallCard: "4px",
      tabGapMediumCard: "4px",
      tabGapLargeCard: "4px",
      tabPaddingSmallCard: "6px 10px",
      tabPaddingMediumCard: "8px 12px",
      tabPaddingLargeCard: "8px 16px",
      tabPaddingSmallSegment: "4px 0",
      tabPaddingMediumSegment: "6px 0",
      tabPaddingLargeSegment: "8px 0",
      tabPaddingVerticalLargeSegment: "0 8px",
      tabPaddingVerticalSmallCard: "10px 6px",
      tabPaddingVerticalMediumCard: "12px 8px",
      tabPaddingVerticalLargeCard: "16px 8px",
      tabPaddingVerticalSmallSegment: "0 4px",
      tabPaddingVerticalMediumSegment: "0 6px",
      tabGapSmallSegment: "0",
      tabGapMediumSegment: "0",
      tabGapLargeSegment: "0",
      panePaddingSmall: "8px 0 0 0",
      panePaddingMedium: "12px 0 0 0",
      panePaddingLarge: "16px 0 0 0",
      closeSize: "18px",
      closeIconSize: "14px"
    };
    const self$1 = (vars) => {
      const { textColor2, primaryColor, textColorDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, tabColor, baseColor, dividerColor, fontWeight, textColor1, borderRadius, fontSize: fontSize2, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, sizeVariables), {
        colorSegment: tabColor,
        tabFontSizeCard: fontSize2,
        tabTextColorLine: textColor1,
        tabTextColorActiveLine: primaryColor,
        tabTextColorHoverLine: primaryColor,
        tabTextColorDisabledLine: textColorDisabled,
        tabTextColorSegment: textColor1,
        tabTextColorActiveSegment: textColor2,
        tabTextColorHoverSegment: textColor2,
        tabTextColorDisabledSegment: textColorDisabled,
        tabTextColorBar: textColor1,
        tabTextColorActiveBar: primaryColor,
        tabTextColorHoverBar: primaryColor,
        tabTextColorDisabledBar: textColorDisabled,
        tabTextColorCard: textColor1,
        tabTextColorHoverCard: textColor1,
        tabTextColorActiveCard: primaryColor,
        tabTextColorDisabledCard: textColorDisabled,
        barColor: primaryColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        tabColor,
        tabColorSegment: baseColor,
        tabBorderColor: dividerColor,
        tabFontWeightActive: fontWeight,
        tabFontWeight: fontWeight,
        tabBorderRadius: borderRadius,
        paneTextColor: textColor2,
        fontWeightStrong
      });
    };
    const tabsLight = {
      name: "Tabs",
      common: commonLight,
      self: self$1
    };
    const tabsLight$1 = tabsLight;
    const tabsInjectionKey = createInjectionKey("n-tabs");
    const tabPaneProps = {
      tab: [String, Number, Object, Function],
      name: {
        type: [String, Number],
        required: true
      },
      disabled: Boolean,
      displayDirective: {
        type: String,
        default: "if"
      },
      closable: {
        type: Boolean,
        default: void 0
      },
      tabProps: Object,
      /** @deprecated */
      label: [String, Number, Object, Function]
    };
    const NTabPane = defineComponent({
      __TAB_PANE__: true,
      name: "TabPane",
      alias: ["TabPanel"],
      props: tabPaneProps,
      setup(props) {
        const NTab = inject(tabsInjectionKey, null);
        if (!NTab) {
          throwError("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`.");
        }
        return {
          style: NTab.paneStyleRef,
          class: NTab.paneClassRef,
          mergedClsPrefix: NTab.mergedClsPrefixRef
        };
      },
      render() {
        return h("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
      }
    });
    const tabProps = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, omit(tabPaneProps, ["displayDirective"]));
    const Tab = defineComponent({
      __TAB__: true,
      inheritAttrs: false,
      name: "Tab",
      props: tabProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          valueRef,
          typeRef,
          closableRef,
          tabStyleRef,
          tabChangeIdRef,
          onBeforeLeaveRef,
          triggerRef,
          handleAdd,
          activateTab,
          handleClose
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = inject(tabsInjectionKey);
        return {
          trigger: triggerRef,
          mergedClosable: computed(() => {
            if (props.internalAddable)
              return false;
            const { closable } = props;
            if (closable === void 0)
              return closableRef.value;
            return closable;
          }),
          style: tabStyleRef,
          clsPrefix: mergedClsPrefixRef,
          value: valueRef,
          type: typeRef,
          handleClose(e) {
            e.stopPropagation();
            if (props.disabled)
              return;
            handleClose(props.name);
          },
          activateTab() {
            if (props.disabled)
              return;
            if (props.internalAddable) {
              handleAdd();
              return;
            }
            const { name: nameProp } = props;
            const id = ++tabChangeIdRef.id;
            if (nameProp !== valueRef.value) {
              const { value: onBeforeLeave } = onBeforeLeaveRef;
              if (!onBeforeLeave) {
                activateTab(nameProp);
              } else {
                void Promise.resolve(onBeforeLeave(props.name, valueRef.value)).then((allowLeave) => {
                  if (allowLeave && tabChangeIdRef.id === id) {
                    activateTab(nameProp);
                  }
                });
              }
            }
          }
        };
      },
      render() {
        const { internalAddable, clsPrefix, name, disabled, label, tab, value, mergedClosable, style: style2, trigger: trigger2, $slots: { default: defaultSlot } } = this;
        const mergedTab = label !== null && label !== void 0 ? label : tab;
        return h(
          "div",
          { class: `${clsPrefix}-tabs-tab-wrapper` },
          this.internalLeftPadded ? h("div", { class: `${clsPrefix}-tabs-tab-pad` }) : null,
          h(
            "div",
            Object.assign({ key: name, "data-name": name, "data-disabled": disabled ? true : void 0 }, mergeProps({
              class: [
                `${clsPrefix}-tabs-tab`,
                value === name && `${clsPrefix}-tabs-tab--active`,
                disabled && `${clsPrefix}-tabs-tab--disabled`,
                mergedClosable && `${clsPrefix}-tabs-tab--closable`,
                internalAddable && `${clsPrefix}-tabs-tab--addable`
              ],
              onClick: trigger2 === "click" ? this.activateTab : void 0,
              onMouseenter: trigger2 === "hover" ? this.activateTab : void 0,
              style: internalAddable ? void 0 : style2
            }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)),
            h("span", { class: `${clsPrefix}-tabs-tab__label` }, internalAddable ? h(
              Fragment,
              null,
              h("div", { class: `${clsPrefix}-tabs-tab__height-placeholder` }, " "),
              h(NBaseIcon, { clsPrefix }, {
                default: () => h(AddIcon, null)
              })
            ) : defaultSlot ? defaultSlot() : typeof mergedTab === "object" ? mergedTab : render$1(mergedTab !== null && mergedTab !== void 0 ? mergedTab : name)),
            mergedClosable && this.type === "card" ? h(NBaseClose, { clsPrefix, class: `${clsPrefix}-tabs-tab__close`, onClick: this.handleClose, disabled }) : null
          )
        );
      }
    });
    const style = cB("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [cM("segment-type", [cB("tabs-rail", [c$1("&.transition-disabled", "color: red;", [cB("tabs-tab", `
 transition: none;
 `)])])]), cM("left, right", `
 flex-direction: row;
 `, [cB("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), cM("right", `
 flex-direction: row-reverse;
 `, [cB("tabs-bar", `
 left: 0;
 `)]), cM("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [cB("tabs-bar", `
 top: 0;
 `)]), cB("tabs-rail", `
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cM("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 `), c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), cM("flex", [cB("tabs-nav", {
      width: "100%"
    }, [cB("tabs-wrapper", {
      width: "100%"
    }, [cB("tabs-tab", {
      marginRight: 0
    })])])]), cB("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [cE("prefix, suffix", `
 display: flex;
 align-items: center;
 `), cE("prefix", "padding-right: 16px;"), cE("suffix", "padding-left: 16px;")]), cB("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [cM("shadow-before", [c$1("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-after", [c$1("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), cB("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar", `
 width: 0;
 height: 0;
 `)]), c$1("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 width: 20px;
 z-index: 1;
 `), c$1("&::before", `
 left: 0;
 `), c$1("&::after", `
 right: 0;
 `)]), cB("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 width: fit-content;
 `), cB("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), cB("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), cB("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("disabled", {
      cursor: "not-allowed"
    }), cE("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE("label", `
 display: flex;
 align-items: center;
 `)]), cB("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("&.transition-disabled", `
 transition: none;
 `), cM("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), cB("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), cB("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 padding: var(--n-pane-padding);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [c$1("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), c$1("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), c$1("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), cB("tabs-tab-pad", `
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), cM("line-type, bar-type", [cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [c$1("&:hover", {
      color: "var(--n-tab-text-color-hover)"
    }), cM("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), cM("disabled", {
      color: "var(--n-tab-text-color-disabled)"
    })])]), cB("tabs-nav", [cM("line-type", [cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 border-radius: 0;
 bottom: -1px;
 `)]), cM("card-type", [cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [cM("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 `, [cE("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), cM("closable", "padding-right: 6px;"), cM("active", `
 border-bottom: 1px solid #0000;
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), cM("disabled", "color: var(--n-tab-text-color-disabled);")]), cB("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);")]), cM("left, right", [cB("tabs-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-pad", `
 height: var(--n-tab-gap);
 width: 100%;
 `)])]), cB("tabs-nav-scroll-content", `
 border-bottom: none;
 `)]), cM("left", [cB("tabs-nav-scroll-content", `
 box-sizing: border-box;
 border-right: 1px solid var(--n-tab-border-color);
 `)]), cM("right", [cB("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `)]), cM("bottom", [cB("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 border-bottom: none;
 `)])])]);
    const tabsProps = Object.assign(Object.assign({}, useTheme.props), {
      value: [String, Number],
      defaultValue: [String, Number],
      trigger: {
        type: String,
        default: "click"
      },
      type: {
        type: String,
        default: "bar"
      },
      closable: Boolean,
      justifyContent: String,
      size: {
        type: String,
        default: "medium"
      },
      placement: {
        type: String,
        default: "top"
      },
      tabStyle: [String, Object],
      barWidth: Number,
      paneClass: String,
      paneStyle: [String, Object],
      addable: [Boolean, Object],
      tabsPadding: {
        type: Number,
        default: 0
      },
      animated: Boolean,
      onBeforeLeave: Function,
      onAdd: Function,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onClose: [Function, Array],
      // deprecated
      labelSize: String,
      activeName: [String, Number],
      onActiveNameChange: [Function, Array]
    });
    const NTabs = defineComponent({
      name: "Tabs",
      props: tabsProps,
      setup(props, { slots }) {
        var _a, _b, _c, _d;
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Tabs", "-tabs", style, tabsLight$1, props, mergedClsPrefixRef);
        const tabsElRef = ref(null);
        const barElRef = ref(null);
        const scrollWrapperElRef = ref(null);
        const addTabInstRef = ref(null);
        const xScrollInstRef = ref(null);
        const leftReachedRef = ref(true);
        const rightReachedRef = ref(true);
        const compitableSizeRef = useCompitable(props, ["labelSize", "size"]);
        const compitableValueRef = useCompitable(props, ["activeName", "value"]);
        const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten$3(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);
        const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);
        const tabChangeIdRef = { id: 0 };
        const tabWrapperStyleRef = computed(() => {
          if (!props.justifyContent || props.type === "card")
            return void 0;
          return {
            display: "flex",
            justifyContent: props.justifyContent
          };
        });
        watch(mergedValueRef, () => {
          tabChangeIdRef.id = 0;
          updateCurrentBarStyle();
          updateCurrentScrollPosition();
        });
        function getCurrentEl() {
          var _a2;
          const { value } = mergedValueRef;
          if (value === null)
            return null;
          const tabEl = (_a2 = tabsElRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`[data-name="${value}"]`);
          return tabEl;
        }
        function updateBarStyle(tabEl) {
          if (props.type === "card")
            return;
          const { value: barEl } = barElRef;
          if (!barEl)
            return;
          if (tabEl) {
            const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;
            const { barWidth, placement } = props;
            if (tabEl.dataset.disabled === "true") {
              barEl.classList.add(disabledClassName);
            } else {
              barEl.classList.remove(disabledClassName);
            }
            if (["top", "bottom"].includes(placement)) {
              clearBarStyle(["top", "maxHeight", "height"]);
              if (typeof barWidth === "number" && tabEl.offsetWidth >= barWidth) {
                const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;
                barEl.style.left = `${offsetDiffLeft}px`;
                barEl.style.maxWidth = `${barWidth}px`;
              } else {
                barEl.style.left = `${tabEl.offsetLeft}px`;
                barEl.style.maxWidth = `${tabEl.offsetWidth}px`;
              }
              barEl.style.width = "8192px";
              void barEl.offsetWidth;
            } else {
              clearBarStyle(["left", "maxWidth", "width"]);
              if (typeof barWidth === "number" && tabEl.offsetHeight >= barWidth) {
                const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;
                barEl.style.top = `${offsetDiffTop}px`;
                barEl.style.maxHeight = `${barWidth}px`;
              } else {
                barEl.style.top = `${tabEl.offsetTop}px`;
                barEl.style.maxHeight = `${tabEl.offsetHeight}px`;
              }
              barEl.style.height = "8192px";
              void barEl.offsetHeight;
            }
          }
        }
        function clearBarStyle(styleProps) {
          const { value: barEl } = barElRef;
          if (!barEl)
            return;
          for (const prop of styleProps) {
            barEl.style[prop] = "";
          }
        }
        function updateCurrentBarStyle() {
          if (props.type === "card")
            return;
          const tabEl = getCurrentEl();
          if (tabEl) {
            updateBarStyle(tabEl);
          }
        }
        function updateCurrentScrollPosition(smooth) {
          var _a2;
          const scrollWrapperEl = (_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el;
          if (!scrollWrapperEl)
            return;
          const tabEl = getCurrentEl();
          if (!tabEl)
            return;
          const { scrollLeft: scrollWrapperElScrollLeft, offsetWidth: scrollWrapperElOffsetWidth } = scrollWrapperEl;
          const { offsetLeft: tabElOffsetLeft, offsetWidth: tabElOffsetWidth } = tabEl;
          if (scrollWrapperElScrollLeft > tabElOffsetLeft) {
            scrollWrapperEl.scrollTo({
              top: 0,
              left: tabElOffsetLeft,
              behavior: "smooth"
            });
          } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {
            scrollWrapperEl.scrollTo({
              top: 0,
              left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,
              behavior: "smooth"
            });
          }
        }
        const tabsPaneWrapperRef = ref(null);
        let fromHeight = 0;
        let hangingTransition = null;
        function onAnimationBeforeLeave(el) {
          const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
          if (tabsPaneWrapperEl) {
            fromHeight = el.getBoundingClientRect().height;
            const fromHeightPx = `${fromHeight}px`;
            const applyFromStyle = () => {
              tabsPaneWrapperEl.style.height = fromHeightPx;
              tabsPaneWrapperEl.style.maxHeight = fromHeightPx;
            };
            if (!hangingTransition) {
              hangingTransition = applyFromStyle;
            } else {
              applyFromStyle();
              hangingTransition();
              hangingTransition = null;
            }
          }
        }
        function onAnimationEnter(el) {
          const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
          if (tabsPaneWrapperEl) {
            const targetHeight = el.getBoundingClientRect().height;
            const applyTargetStyle = () => {
              void document.body.offsetHeight;
              tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;
              tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;
            };
            if (!hangingTransition) {
              hangingTransition = applyTargetStyle;
            } else {
              hangingTransition();
              hangingTransition = null;
              applyTargetStyle();
            }
          }
        }
        function onAnimationAfterEnter() {
          const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
          if (tabsPaneWrapperEl) {
            tabsPaneWrapperEl.style.maxHeight = "";
            tabsPaneWrapperEl.style.height = "";
          }
        }
        const renderNameListRef = { value: [] };
        const animationDirectionRef = ref("next");
        function activateTab(panelName) {
          const currentValue = mergedValueRef.value;
          let dir = "next";
          for (const name of renderNameListRef.value) {
            if (name === currentValue) {
              break;
            }
            if (name === panelName) {
              dir = "prev";
              break;
            }
          }
          animationDirectionRef.value = dir;
          doUpdateValue(panelName);
        }
        function doUpdateValue(panelName) {
          const { onActiveNameChange, onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          if (onActiveNameChange) {
            call(onActiveNameChange, panelName);
          }
          if (onUpdateValue)
            call(onUpdateValue, panelName);
          if (_onUpdateValue)
            call(_onUpdateValue, panelName);
          uncontrolledValueRef.value = panelName;
        }
        function handleClose(panelName) {
          const { onClose } = props;
          if (onClose)
            call(onClose, panelName);
        }
        function updateBarPositionInstantly() {
          const { value: barEl } = barElRef;
          if (!barEl)
            return;
          const disableTransitionClassName = "transition-disabled";
          barEl.classList.add(disableTransitionClassName);
          updateCurrentBarStyle();
          barEl.classList.remove(disableTransitionClassName);
        }
        let memorizedWidth = 0;
        function _handleNavResize(entry) {
          var _b2;
          if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {
            return;
          }
          if (memorizedWidth === entry.contentRect.width) {
            return;
          }
          memorizedWidth = entry.contentRect.width;
          const { type: type2 } = props;
          if (type2 === "line" || type2 === "bar") {
            {
              updateBarPositionInstantly();
            }
          }
          if (type2 !== "segment") {
            deriveScrollShadow((_b2 = xScrollInstRef.value) === null || _b2 === void 0 ? void 0 : _b2.$el);
          }
        }
        const handleNavResize = throttle(_handleNavResize, 64);
        watch([() => props.justifyContent, () => props.size], () => {
          void nextTick(() => {
            const { type: type2 } = props;
            if (type2 === "line" || type2 === "bar") {
              updateBarPositionInstantly();
            }
          });
        });
        const addTabFixedRef = ref(false);
        function _handleTabsResize(entry) {
          var _a2;
          const { target, contentRect: { width } } = entry;
          const containerWidth = target.parentElement.offsetWidth;
          if (!addTabFixedRef.value) {
            if (containerWidth < width) {
              addTabFixedRef.value = true;
            }
          } else {
            const { value: addTabInst } = addTabInstRef;
            if (!addTabInst)
              return;
            if (containerWidth - width > addTabInst.$el.offsetWidth) {
              addTabFixedRef.value = false;
            }
          }
          deriveScrollShadow((_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el);
        }
        const handleTabsResize = throttle(_handleTabsResize, 64);
        function handleAdd() {
          const { onAdd } = props;
          if (onAdd)
            onAdd();
          void nextTick(() => {
            const currentEl = getCurrentEl();
            const { value: xScrollInst } = xScrollInstRef;
            if (!currentEl || !xScrollInst)
              return;
            xScrollInst.scrollTo({
              left: currentEl.offsetLeft,
              top: 0,
              behavior: "smooth"
            });
          });
        }
        function deriveScrollShadow(el) {
          if (!el)
            return;
          const { scrollLeft, scrollWidth, offsetWidth } = el;
          leftReachedRef.value = scrollLeft <= 0;
          rightReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;
        }
        const handleScroll = throttle((e) => {
          deriveScrollShadow(e.target);
        }, 64);
        provide(tabsInjectionKey, {
          triggerRef: toRef(props, "trigger"),
          tabStyleRef: toRef(props, "tabStyle"),
          paneClassRef: toRef(props, "paneClass"),
          paneStyleRef: toRef(props, "paneStyle"),
          mergedClsPrefixRef,
          typeRef: toRef(props, "type"),
          closableRef: toRef(props, "closable"),
          valueRef: mergedValueRef,
          tabChangeIdRef,
          onBeforeLeaveRef: toRef(props, "onBeforeLeave"),
          activateTab,
          handleClose,
          handleAdd
        });
        onFontsReady(() => {
          updateCurrentBarStyle();
          updateCurrentScrollPosition();
        });
        watchEffect(() => {
          const { value: el } = scrollWrapperElRef;
          if (!el || ["left", "right"].includes(props.placement))
            return;
          const { value: clsPrefix } = mergedClsPrefixRef;
          const shadowBeforeClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-before`;
          const shadowAfterClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-after`;
          if (leftReachedRef.value) {
            el.classList.remove(shadowBeforeClass);
          } else {
            el.classList.add(shadowBeforeClass);
          }
          if (rightReachedRef.value) {
            el.classList.remove(shadowAfterClass);
          } else {
            el.classList.add(shadowAfterClass);
          }
        });
        const tabsRailElRef = ref(null);
        watch(mergedValueRef, () => {
          if (props.type === "segment") {
            const tabsRailEl = tabsRailElRef.value;
            if (tabsRailEl) {
              void nextTick(() => {
                tabsRailEl.classList.add("transition-disabled");
                void tabsRailEl.offsetWidth;
                tabsRailEl.classList.remove("transition-disabled");
              });
            }
          }
        });
        const exposedMethods = {
          syncBarPosition: () => {
            updateCurrentBarStyle();
          }
        };
        const cssVarsRef = computed(() => {
          const { value: size2 } = compitableSizeRef;
          const { type: type2 } = props;
          const typeSuffix = {
            card: "Card",
            bar: "Bar",
            line: "Line",
            segment: "Segment"
          }[type2];
          const sizeType = `${size2}${typeSuffix}`;
          const { self: { barColor, closeIconColor, closeIconColorHover, closeIconColorPressed, tabColor, tabBorderColor, paneTextColor, tabFontWeight, tabBorderRadius, tabFontWeightActive, colorSegment, fontWeightStrong, tabColorSegment, closeSize, closeIconSize, closeColorHover, closeColorPressed, closeBorderRadius, [createKey("panePadding", size2)]: panePadding, [createKey("tabPadding", sizeType)]: tabPadding, [createKey("tabPaddingVertical", sizeType)]: tabPaddingVertical, [createKey("tabGap", sizeType)]: tabGap, [createKey("tabTextColor", type2)]: tabTextColor, [createKey("tabTextColorActive", type2)]: tabTextColorActive, [createKey("tabTextColorHover", type2)]: tabTextColorHover, [createKey("tabTextColorDisabled", type2)]: tabTextColorDisabled, [createKey("tabFontSize", size2)]: tabFontSize }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-color-segment": colorSegment,
            "--n-bar-color": barColor,
            "--n-tab-font-size": tabFontSize,
            "--n-tab-text-color": tabTextColor,
            "--n-tab-text-color-active": tabTextColorActive,
            "--n-tab-text-color-disabled": tabTextColorDisabled,
            "--n-tab-text-color-hover": tabTextColorHover,
            "--n-pane-text-color": paneTextColor,
            "--n-tab-border-color": tabBorderColor,
            "--n-tab-border-radius": tabBorderRadius,
            "--n-close-size": closeSize,
            "--n-close-icon-size": closeIconSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-tab-color": tabColor,
            "--n-tab-font-weight": tabFontWeight,
            "--n-tab-font-weight-active": tabFontWeightActive,
            "--n-tab-padding": tabPadding,
            "--n-tab-padding-vertical": tabPaddingVertical,
            "--n-tab-gap": tabGap,
            "--n-pane-padding": panePadding,
            "--n-font-weight-strong": fontWeightStrong,
            "--n-tab-color-segment": tabColorSegment
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("tabs", computed(() => {
          return `${compitableSizeRef.value[0]}${props.type[0]}`;
        }), cssVarsRef, props) : void 0;
        return Object.assign({
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          renderedNames: /* @__PURE__ */ new Set(),
          tabsRailElRef,
          tabsPaneWrapperRef,
          tabsElRef,
          barElRef,
          addTabInstRef,
          xScrollInstRef,
          scrollWrapperElRef,
          addTabFixed: addTabFixedRef,
          tabWrapperStyle: tabWrapperStyleRef,
          handleNavResize,
          mergedSize: compitableSizeRef,
          handleScroll,
          handleTabsResize,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          animationDirection: animationDirectionRef,
          renderNameListRef,
          onAnimationBeforeLeave,
          onAnimationEnter,
          onAnimationAfterEnter,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        }, exposedMethods);
      },
      render() {
        const { mergedClsPrefix, type: type2, placement, addTabFixed, addable, mergedSize, renderNameListRef, onRender, $slots: { default: defaultSlot, prefix: prefixSlot, suffix: suffixSlot } } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const tabPaneChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
          return v.type.__TAB_PANE__ === true;
        }) : [];
        const tabChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
          return v.type.__TAB__ === true;
        }) : [];
        const showPane = !tabChildren.length;
        const isCard = type2 === "card";
        const isSegment = type2 === "segment";
        const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;
        renderNameListRef.value = [];
        const scrollContent = () => {
          const tabs = h(
            "div",
            { style: this.tabWrapperStyle, class: [`${mergedClsPrefix}-tabs-wrapper`] },
            mergedJustifyContent ? null : h("div", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }),
            showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
              renderNameListRef.value.push(tabPaneVNode.props.name);
              return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === "center" || mergedJustifyContent === "start" || mergedJustifyContent === "end") }), tabPaneVNode.children ? {
                default: tabPaneVNode.children.tab
              } : void 0));
            }) : tabChildren.map((tabVNode, index) => {
              renderNameListRef.value.push(tabVNode.props.name);
              if (index !== 0 && !mergedJustifyContent) {
                return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));
              } else {
                return justifyTabDynamicProps(tabVNode);
              }
            }),
            !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null,
            mergedJustifyContent ? null : h("div", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } })
          );
          return h(
            "div",
            { ref: "tabsElRef", class: `${mergedClsPrefix}-tabs-nav-scroll-content` },
            isCard && addable ? h(VResizeObserver, { onResize: this.handleTabsResize }, {
              default: () => tabs
            }) : tabs,
            isCard ? h("div", { class: `${mergedClsPrefix}-tabs-pad` }) : null,
            isCard ? null : h("div", { ref: "barElRef", class: `${mergedClsPrefix}-tabs-bar` })
          );
        };
        return h(
          "div",
          { class: [
            `${mergedClsPrefix}-tabs`,
            this.themeClass,
            `${mergedClsPrefix}-tabs--${type2}-type`,
            `${mergedClsPrefix}-tabs--${mergedSize}-size`,
            mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`,
            `${mergedClsPrefix}-tabs--${placement}`
          ], style: this.cssVars },
          h(
            "div",
            { class: [
              // the class should be applied here since it's possible
              // to make tabs nested in tabs, style may influence each
              // other. adding a class will make it easy to write the
              // style.
              `${mergedClsPrefix}-tabs-nav--${type2}-type`,
              `${mergedClsPrefix}-tabs-nav--${placement}`,
              `${mergedClsPrefix}-tabs-nav`
            ] },
            resolveWrappedSlot(prefixSlot, (children) => children && h("div", { class: `${mergedClsPrefix}-tabs-nav__prefix` }, children)),
            isSegment ? h("div", { class: `${mergedClsPrefix}-tabs-rail`, ref: "tabsRailElRef" }, showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
              renderNameListRef.value.push(tabPaneVNode.props.name);
              return h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 }), tabPaneVNode.children ? {
                default: tabPaneVNode.children.tab
              } : void 0);
            }) : tabChildren.map((tabVNode, index) => {
              renderNameListRef.value.push(tabVNode.props.name);
              if (index === 0) {
                return tabVNode;
              } else {
                return createLeftPaddedTabVNode(tabVNode);
              }
            })) : h(VResizeObserver, { onResize: this.handleNavResize }, {
              default: () => h("div", { class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(placement) ? h(VXScroll, { ref: "xScrollInstRef", onScroll: this.handleScroll }, {
                default: scrollContent
              }) : h("div", { class: `${mergedClsPrefix}-tabs-nav-y-scroll` }, scrollContent()))
            }),
            addTabFixed && addable && isCard ? createAddTag(addable, true) : null,
            resolveWrappedSlot(suffixSlot, (children) => children && h("div", { class: `${mergedClsPrefix}-tabs-nav__suffix` }, children))
          ),
          showPane && (this.animated ? h("div", { ref: "tabsPaneWrapperRef", class: `${mergedClsPrefix}-tabs-pane-wrapper` }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames))
        );
      }
    });
    function filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {
      const children = [];
      tabPaneVNodes.forEach((vNode) => {
        const { name, displayDirective, "display-directive": _displayDirective } = vNode.props;
        const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;
        const show = value === name;
        if (vNode.key !== void 0) {
          vNode.key = name;
        }
        if (show || matchDisplayDirective("show") || matchDisplayDirective("show:lazy") && renderedNames.has(name)) {
          if (!renderedNames.has(name)) {
            renderedNames.add(name);
          }
          const useVShow = !matchDisplayDirective("if");
          children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);
        }
      });
      if (!animationDirection) {
        return children;
      }
      return h(TransitionGroup, { name: `${animationDirection}-transition`, onBeforeLeave, onEnter, onAfterEnter }, { default: () => children });
    }
    function createAddTag(addable, internalLeftPadded) {
      return h(Tab, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded, disabled: typeof addable === "object" && addable.disabled });
    }
    function createLeftPaddedTabVNode(tabVNode) {
      const modifiedVNode = cloneVNode(tabVNode);
      if (modifiedVNode.props) {
        modifiedVNode.props.internalLeftPadded = true;
      } else {
        modifiedVNode.props = {
          internalLeftPadded: true
        };
      }
      return modifiedVNode;
    }
    function justifyTabDynamicProps(tabVNode) {
      if (Array.isArray(tabVNode.dynamicProps)) {
        if (!tabVNode.dynamicProps.includes("internalLeftPadded")) {
          tabVNode.dynamicProps.push("internalLeftPadded");
        }
      } else {
        tabVNode.dynamicProps = ["internalLeftPadded"];
      }
      return tabVNode;
    }
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const createColumns = () => {
      return [
        {
          title: "Addr",
          key: "addr"
        },
        {
          title: "Payload",
          key: "payload"
        },
        {
          title: "Type",
          key: "plugin"
        }
      ];
    };
    const _sfc_main = defineComponent({
      components: {
        NDynamicInput,
        NButton,
        NInput,
        NTabs,
        NTabPane,
        NDataTable,
        NCard,
        NFormItem,
        NForm
      },
      setup() {
        return {
          curls: ref([""]),
          log: ref(""),
          resContent: ref(""),
          data: ref([]),
          columns: createColumns(),
          xrayPath: ref(""),
          isdisable: true
        };
      },
      computed: {
        isDisabledFn() {
          return !this.isdisable;
        }
      },
      methods: {
        store() {
          window.xAPI.pathSet(this.xrayPath);
        },
        curlSubmit(curls) {
          this.log = "";
          window.xAPI.curlScan(JSON.stringify(curls));
        },
        xrayStart() {
          if (this.xrayPath != "") {
            this.resContent = "";
            window.xAPI.xrayStart(this.xrayPath);
          } else {
            this.log = "请配置Xray\n" + this.log;
          }
        },
        xrayStop() {
          window.xAPI.xrayStop();
        }
      },
      mounted() {
        window.xAPI.pathExist((event, value) => {
          this.isdisable = value;
        });
        window.xAPI.pathGet((event, value) => {
          this.xrayPath = value;
        });
        window.xAPI.logSender((event, value) => {
          this.log = value + "\n" + this.log;
        });
        window.xAPI.xraySender((event, value) => {
          this.resContent = this.resContent + "\n" + value;
          this.$nextTick(function() {
            var p2 = document.getElementById("xrayOutput");
            p2.scrollTop = p2.scrollHeight;
          });
        });
        window.xAPI.xrayRes((event, value) => {
          console.log(value);
          this.data.push(JSON.parse(value));
        });
      }
    });
    const _hoisted_1 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
    const _hoisted_2 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
    const _hoisted_3 = ["innerHTML"];
    const _hoisted_4 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_n_dynamic_input = resolveComponent("n-dynamic-input");
      const _component_n_button = resolveComponent("n-button");
      const _component_n_input = resolveComponent("n-input");
      const _component_n_tab_pane = resolveComponent("n-tab-pane");
      const _component_n_data_table = resolveComponent("n-data-table");
      const _component_n_form_item = resolveComponent("n-form-item");
      const _component_n_form = resolveComponent("n-form");
      const _component_n_tabs = resolveComponent("n-tabs");
      const _component_n_card = resolveComponent("n-card");
      return openBlock(), createBlock(_component_n_card, {
        title: "",
        style: { "margin-bottom": "16px" }
      }, {
        default: withCtx(() => [
          createVNode(_component_n_tabs, {
            type: "line",
            animated: ""
          }, {
            default: withCtx(() => [
              createVNode(_component_n_tab_pane, {
                name: "scan",
                tab: "Scan"
              }, {
                default: withCtx(() => [
                  createVNode(_component_n_dynamic_input, {
                    value: _ctx.curls,
                    "onUpdate:value": _cache[0] || (_cache[0] = ($event) => _ctx.curls = $event),
                    placeholder: "请输入",
                    min: 1,
                    max: 50
                  }, null, 8, ["value"]),
                  _hoisted_1,
                  createVNode(_component_n_button, {
                    type: "info",
                    onClick: _ctx.xrayStart,
                    disabled: _ctx.isDisabledFn
                  }, {
                    default: withCtx(() => [
                      createTextVNode("开启Xray")
                    ]),
                    _: 1
                  }, 8, ["onClick", "disabled"]),
                  createTextVNode("   "),
                  createVNode(_component_n_button, {
                    type: "info",
                    onClick: _ctx.xrayStop,
                    disabled: _ctx.isDisabledFn
                  }, {
                    default: withCtx(() => [
                      createTextVNode("关闭Xray")
                    ]),
                    _: 1
                  }, 8, ["onClick", "disabled"]),
                  createTextVNode("   "),
                  createVNode(_component_n_button, {
                    type: "info",
                    onClick: _cache[1] || (_cache[1] = ($event) => _ctx.curlSubmit(_ctx.curls)),
                    disabled: _ctx.isDisabledFn
                  }, {
                    default: withCtx(() => [
                      createTextVNode("开始扫描")
                    ]),
                    _: 1
                  }, 8, ["disabled"]),
                  _hoisted_2,
                  createBaseVNode("p", {
                    id: "xrayOutput",
                    innerHTML: _ctx.resContent,
                    style: { "margin": "20px 0 10px 0", "white-space": "pre-wrap", "background": "#000", "color": "#fff", "padding": "10px", "height": "400px", "overflow": "auto" }
                  }, null, 8, _hoisted_3),
                  _hoisted_4,
                  createVNode(_component_n_input, {
                    value: _ctx.log,
                    "onUpdate:value": _cache[2] || (_cache[2] = ($event) => _ctx.log = $event),
                    type: "textarea",
                    placeholder: "",
                    readonly: ""
                  }, null, 8, ["value"])
                ]),
                _: 1
              }),
              createVNode(_component_n_tab_pane, {
                name: "Result",
                tab: "Result"
              }, {
                default: withCtx(() => [
                  createVNode(_component_n_data_table, {
                    columns: _ctx.columns,
                    data: _ctx.data
                  }, null, 8, ["columns", "data"])
                ]),
                _: 1
              }),
              createVNode(_component_n_tab_pane, {
                name: "Config",
                tab: "Config"
              }, {
                default: withCtx(() => [
                  createVNode(_component_n_form, null, {
                    default: withCtx(() => [
                      createVNode(_component_n_form_item, {
                        label: "Xray路径",
                        "label-placement": "left"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_n_input, {
                            placeholder: "",
                            value: _ctx.xrayPath,
                            "onUpdate:value": _cache[3] || (_cache[3] = ($event) => _ctx.xrayPath = $event),
                            clearable: ""
                          }, null, 8, ["value"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_n_button, {
                        type: "info",
                        onClick: _ctx.store
                      }, {
                        default: withCtx(() => [
                          createTextVNode("保存")
                        ]),
                        _: 1
                      }, 8, ["onClick"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
    createApp(App).mount("#app");
  }
});
export default require_index_001();
